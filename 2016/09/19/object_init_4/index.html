<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Object 初始化过程(四) | Corner XX daily log</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Object类初始化前必须完成JVM规范中的加载，链接等。本节继续Object初始化过程(三)继续。">
<meta property="og:type" content="article">
<meta property="og:title" content="Object 初始化过程(四)">
<meta property="og:url" content="http://yoursite.com/2016/09/19/object_init_4/index.html">
<meta property="og:site_name" content="Corner XX daily log">
<meta property="og:description" content="Object类初始化前必须完成JVM规范中的加载，链接等。本节继续Object初始化过程(三)继续。">
<meta property="og:updated_time" content="2017-01-22T06:56:54.301Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Object 初始化过程(四)">
<meta name="twitter:description" content="Object类初始化前必须完成JVM规范中的加载，链接等。本节继续Object初始化过程(三)继续。">
  
    <link rel="alternative" href="/atom.xml" title="Corner XX daily log" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.png">
  
  <script src="/style.js"></script>
</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/img/suolong.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Corner XX</a></h1>
		</hgroup>

		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="#" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/cornerxx" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">Corner XX</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="/img/suolong.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Corner XX</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/cornerxx" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        <article id="post-object_init_4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Object 初始化过程(四)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Object类初始化前必须完成JVM规范中的加载，链接等。本节继续<strong>Object初始化过程(三)</strong>继续。<br><a id="more"></a></p>
<script src="/goodness/style.js"></script>

<h1 id="Object-初始化过程-四"><a href="#Object-初始化过程-四" class="headerlink" title="Object 初始化过程(四)"></a>Object 初始化过程(四)</h1><p>备注：文章中所有的平台都是在Linux上，Windows不做考虑。文中只是部分，后续慢慢更新。文中描述的只涉及相关的知识，不包含特定领域的内容。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Object类初始化前必须完成JVM规范中的加载，链接等。本节继续<strong>Object初始化过程(三)</strong>继续。</p>
<h2 id="执行过程分析"><a href="#执行过程分析" class="headerlink" title="执行过程分析"></a>执行过程分析</h2><p>在前面，我们已经建立运行Java方法的执行栈，下面就描述了加载jvm指令，到jvm指令的执行过程。<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">hotspot\src\cpu\x86\vm\interp_masm_x86_64.cpp:</div><div class="line"></div><div class="line"><span class="keyword">void</span> InterpreterMacroAssembler::dispatch_next(TosState state, <span class="keyword">int</span> step) &#123;</div><div class="line">  <span class="comment">// load next bytecode (load before advancing r13 to prevent AGI)</span></div><div class="line">  load_unsigned_byte(rbx, Address(r13, step));</div><div class="line">  <span class="comment">// advance r13</span></div><div class="line">  increment(r13, step);</div><div class="line">  dispatch_base(state, Interpreter::dispatch_table(state));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<strong>Object初始化过程(三)</strong>中我们知道<strong>r13</strong>寄存器保存了jvm代码段的内存地址。此方法通过访问<strong>r13</strong>寄存器的内容并且将其赋值给<strong>rbx</strong>,并且递增内存地址。<strong>rbx</strong>寄存器保存了jvm的指令。<br>那么TosState表示的是什么意思呢？<strong>MARK</strong><br>这里的TosState是<strong>vtos</strong>。<br>另外，看看此时各个重要寄存器的内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">RAX return adress</div><div class="line">RBX JVM bytecode 字节码</div><div class="line">RCX size of parameters</div><div class="line">RDX constant pool cache</div><div class="line">R13 bcp 指向方法加载字节码的起始地址</div><div class="line">R14 pointer to locals,指向参数的起始地址</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void InterpreterMacroAssembler::dispatch_base(TosState state,</div><div class="line">                                              address* table,</div><div class="line">                                              bool verifyoop) &#123;</div><div class="line">  verify_FPU(1, state);</div><div class="line">  if (VerifyActivationFrameSize) &#123;</div><div class="line">    Label L;</div><div class="line">    mov(rcx, rbp);</div><div class="line">    subptr(rcx, rsp);</div><div class="line">    int32_t min_frame_size =</div><div class="line">      (frame::link_offset - frame::interpreter_frame_initial_sp_offset) *</div><div class="line">      wordSize;</div><div class="line">    cmpptr(rcx, (int32_t)min_frame_size);</div><div class="line">    jcc(Assembler::greaterEqual, L);</div><div class="line">    stop(&quot;broken stack frame&quot;);</div><div class="line">    bind(L);</div><div class="line">  &#125;</div><div class="line">  if (verifyoop) &#123;</div><div class="line">    verify_oop(rax, state);</div><div class="line">  &#125;</div><div class="line">  lea(rscratch1, ExternalAddress((address)table));</div><div class="line">  jmp(Address(rscratch1, rbx, Address::times_8));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>计算table指向的地址，跳转到指定地址执行。那么table指向的是什么地址呢？既然，虚拟机的指令也已经知道，那么后面就是对此指令进行解释执行。所以，这个地址应该是和解释器相关的代码。<br><figure class="highlight"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\interpreter\templateInterpreter.hpp:</div><div class="line"></div><div class="line">  static address*   dispatch_table(TosState state)              &#123; return _active_table.table_for(state); &#125;</div><div class="line"></div><div class="line">  address*   table_for(TosState state)          &#123; return _table[state]; &#125;</div><div class="line"></div><div class="line">hotspot\src\share\vm\interpreter\templateInterpreter.cpp:</div><div class="line">void TemplateInterpreter::initialize() &#123;</div><div class="line">  if (_code != NULL) return;</div><div class="line">  // assertions</div><div class="line">  assert((int)Bytecodes::number_of_codes &lt;= (int)DispatchTable::length,</div><div class="line">         "dispatch table too small");</div><div class="line"></div><div class="line">  AbstractInterpreter::initialize();</div><div class="line"></div><div class="line">  TemplateTable::initialize();</div><div class="line"></div><div class="line">  // generate interpreter</div><div class="line">  &#123; ResourceMark rm;</div><div class="line">    TraceTime timer("Interpreter generation", TraceStartupTime);</div><div class="line">    int code_size = InterpreterCodeSize;</div><div class="line">    NOT_PRODUCT(code_size *= 4;)  // debug uses extra interpreter code space</div><div class="line">    _code = new StubQueue(new InterpreterCodeletInterface, code_size, NULL,</div><div class="line">                          "Interpreter");</div><div class="line">    InterpreterGenerator g(_code);</div><div class="line">    if (PrintInterpreter) print();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // initialize dispatch table</div><div class="line">  _active_table = _normal_table;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void TemplateInterpreterGenerator::set_unimplemented(int i) &#123;</div><div class="line">  address e = _unimplemented_bytecode;</div><div class="line">  EntryPoint entry(e, e, e, e, e, e, e, e, e);</div><div class="line">  Interpreter::_normal_table.set_entry(i, entry);</div><div class="line">  Interpreter::_wentry_point[i] = _unimplemented_bytecode;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void TemplateInterpreterGenerator::set_entry_points(Bytecodes::Code code) &#123;</div><div class="line">  CodeletMark cm(_masm, Bytecodes::name(code), code);</div><div class="line">  // initialize entry points</div><div class="line">  assert(_unimplemented_bytecode    != NULL, "should have been generated before");</div><div class="line">  assert(_illegal_bytecode_sequence != NULL, "should have been generated before");</div><div class="line">  address bep = _illegal_bytecode_sequence;</div><div class="line">  address cep = _illegal_bytecode_sequence;</div><div class="line">  address sep = _illegal_bytecode_sequence;</div><div class="line">  address aep = _illegal_bytecode_sequence;</div><div class="line">  address iep = _illegal_bytecode_sequence;</div><div class="line">  address lep = _illegal_bytecode_sequence;</div><div class="line">  address fep = _illegal_bytecode_sequence;</div><div class="line">  address dep = _illegal_bytecode_sequence;</div><div class="line">  address vep = _unimplemented_bytecode;</div><div class="line">  address wep = _unimplemented_bytecode;</div><div class="line">  // code for short &amp; wide version of bytecode</div><div class="line">  if (Bytecodes::is_defined(code)) &#123;</div><div class="line">    Template* t = TemplateTable::template_for(code);</div><div class="line">    assert(t-&gt;is_valid(), "just checking");</div><div class="line">    set_short_entry_points(t, bep, cep, sep, aep, iep, lep, fep, dep, vep);</div><div class="line">  &#125;</div><div class="line">  if (Bytecodes::wide_is_defined(code)) &#123;</div><div class="line">    Template* t = TemplateTable::template_for_wide(code);</div><div class="line">    assert(t-&gt;is_valid(), "just checking");</div><div class="line">    set_wide_entry_point(t, wep);</div><div class="line">  &#125;</div><div class="line">  // set entry points</div><div class="line">  EntryPoint entry(bep, cep, sep, aep, iep, lep, fep, dep, vep);</div><div class="line">  Interpreter::_normal_table.set_entry(code, entry);</div><div class="line">  Interpreter::_wentry_point[code] = wep;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void TemplateInterpreterGenerator::set_entry_points_for_all_bytes() &#123;</div><div class="line">  for (int i = 0; i &lt; DispatchTable::length; i++) &#123;</div><div class="line">    Bytecodes::Code code = (Bytecodes::Code)i;</div><div class="line">    if (Bytecodes::is_defined(code)) &#123;</div><div class="line">      set_entry_points(code);</div><div class="line">    &#125; else &#123;</div><div class="line">      set_unimplemented(i);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void TemplateInterpreterGenerator::generate_all() &#123;</div><div class="line">  ...</div><div class="line"></div><div class="line">  // Bytecodes</div><div class="line">  set_entry_points_for_all_bytes();</div><div class="line">  set_safepoints_for_all_bytes();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于这段代码的解释，请参考<a href="/2016/09/19/jvm-interpreter-3/">JVM解释器初始化过程(三) </a>。<br>所以<strong>table</strong>指向的是<strong>TemplateInterpreter::_normal_table[vtos]</strong>第一个元素。<br><strong>dispatch_base()</strong>主要工作就是根据解释器跳转表中获取解释器的内存地址，并且到这个地址执行指令。重点的代码如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">lea(rscratch1, ExternalAddress((address)table));</div><div class="line">jmp(Address(rscratch1, rbx, Address::times_8));</div></pre></td></tr></table></figure></p>
<p>第一条指令就是获取<strong>TemplateInterpreter::_normal_table[vtos]</strong>第一个元素的内存地址，第二个就是获取存在rbx的指令编号计算出解释器存放的内存地址，这个内存地址就是这个解释器的内存指令地址。<br>先来看一下Object中<strong>\<clinit\></clinit\></strong>的code属性内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">0 invokestatic #17 &lt;java/lang/Object.registerNatives&gt;</div><div class="line">3 return</div></pre></td></tr></table></figure></p>
<p><strong>invokestatic</strong>指令的字节码编号为184(参考<a href="/2016/09/19/jvm-interpreter-1/">JVM解释器初始化过程(一)</a>)。也就是从<strong>TemplateInterpreter::_normal_table[vtos]</strong>表中的第184个元素获取内存地址，从<a href="/2016/09/19/jvm-interpreter-3/">JVM解释器初始化过程(三) </a>我们可以知道，这个地址就是指令<strong>invokestatic</strong>的解释器地址，根据其定义，其入参为<strong>vtos</strong>，栈中的内容：<br>address&amp; vep：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">  [push   %rax           ] &lt;--- aep </div><div class="line">  [jmpq   L              ]  </div><div class="line">  [sub    $0x8,%rsp      ] &lt;--- fep </div><div class="line">  [movss  %xmm0,(%rsp)   ]   </div><div class="line">  [jmpq   L              ] </div><div class="line">  [sub    $0x10,%rsp     ] &lt;--- dep</div><div class="line">  [movsd  %xmm0,(%rsp)   ] </div><div class="line">  [jmpq   L              ] </div><div class="line">  [sub    $0x10,%rsp     ] &lt;--- lep</div><div class="line">  [mov    %rax,(%rsp)    ] </div><div class="line">  [jmpq   L              ] </div><div class="line">  [push   %rax           ] &lt;--- iep</div><div class="line">L:[                      ] &lt;--- vep</div></pre></td></tr></table></figure></p>
<p>也就是说，执行的时候不做任何操作，执行执行指令。我们来看看指定的定义：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\interpreter\templateTable.cpp:</div><div class="line"></div><div class="line">  def(Bytecodes::<span class="number">_</span>invokestatic        , ubcp|disp|clvm|<span class="number">____</span>, vtos, vtos, invokestatic        , f1_byte      );</div></pre></td></tr></table></figure></p>
<p>解释生成器：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\cpu\x86\vm\templateTable_x86_64.cpp:</div><div class="line"></div><div class="line"><span class="keyword">void</span> TemplateTable::invokestatic(<span class="keyword">int</span> byte_no) &#123;</div><div class="line">  transition(vtos, vtos);</div><div class="line">  assert(byte_no == f1_byte, <span class="string">"use this argument"</span>);</div><div class="line">  prepare_invoke(byte_no, rbx);  <span class="comment">// get f1 methodOop</span></div><div class="line">  <span class="comment">// do the call</span></div><div class="line">  <span class="number">__</span> verify_oop(rbx);</div><div class="line">  <span class="number">__</span> profile_call(rax);</div><div class="line">  <span class="number">__</span> jump_from_interpreted(rbx, rax);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看看<strong>prepare_invoke</strong>的定义：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">void</span> TemplateTable::prepare_invoke(<span class="keyword">int</span> byte_no,</div><div class="line">                                   Register method,  <span class="comment">// linked method (or i-klass)</span></div><div class="line">                                   Register index,   <span class="comment">// itable index, MethodType, etc.</span></div><div class="line">                                   Register recv,    <span class="comment">// if caller wants to see it</span></div><div class="line">                                   Register flags    <span class="comment">// if caller wants to test it</span></div><div class="line">                                   ) &#123;</div><div class="line">  <span class="comment">// determine flags</span></div><div class="line">  <span class="keyword">const</span> Bytecodes::Code code = bytecode();</div><div class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> is_invokeinterface  = code == Bytecodes::<span class="number">_</span>invokeinterface;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> is_invokedynamic    = code == Bytecodes::<span class="number">_</span>invokedynamic;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> is_invokehandle     = code == Bytecodes::<span class="number">_</span>invokehandle;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> is_invokevirtual    = code == Bytecodes::<span class="number">_</span>invokevirtual;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> is_invokespecial    = code == Bytecodes::<span class="number">_</span>invokespecial;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> load_receiver       = (recv  != noreg);</div><div class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> save_flags          = (flags != noreg);</div><div class="line">  assert(load_receiver == (code != Bytecodes::<span class="number">_</span>invokestatic &amp;&amp; code != Bytecodes::<span class="number">_</span>invokedynamic), <span class="string">""</span>);</div><div class="line">  assert(save_flags    == (is_invokeinterface || is_invokevirtual), <span class="string">"need flags for vfinal"</span>);</div><div class="line">  assert(flags == noreg || flags == rdx, <span class="string">""</span>);</div><div class="line">  assert(recv  == noreg || recv  == rcx, <span class="string">""</span>);</div><div class="line"></div><div class="line">  <span class="comment">// setup registers &amp; access constant pool cache</span></div><div class="line">  <span class="keyword">if</span> (recv  == noreg)  recv  = rcx;</div><div class="line">  <span class="keyword">if</span> (flags == noreg)  flags = rdx;</div><div class="line">  assert_different_registers(method, index, recv, flags);</div><div class="line"></div><div class="line">  <span class="comment">// save 'interpreter return address'</span></div><div class="line">  <span class="number">__</span> save_bcp();</div><div class="line"></div><div class="line">  load_invoke_cp_cache_entry(byte_no, method, index, flags, is_invokevirtual, <span class="literal">false</span>, is_invokedynamic);</div><div class="line"></div><div class="line">  <span class="comment">// maybe push appendix to arguments (just before return address)</span></div><div class="line">  <span class="keyword">if</span> (is_invokedynamic || is_invokehandle) &#123;</div><div class="line">    Label L_no_push;</div><div class="line">    <span class="number">__</span> verify_oop(index);</div><div class="line">    <span class="number">__</span> testl(flags, (<span class="number">1</span> &lt;&lt; ConstantPoolCacheEntry::has_appendix_shift));</div><div class="line">    <span class="number">__</span> jccb(Assembler::zero, L_no_push);</div><div class="line">    <span class="comment">// Push the appendix as a trailing parameter.</span></div><div class="line">    <span class="comment">// This must be done before we get the receiver,</span></div><div class="line">    <span class="comment">// since the parameter_size includes it.</span></div><div class="line">    <span class="number">__</span> push(index);  <span class="comment">// push appendix (MethodType, CallSite, etc.)</span></div><div class="line">    <span class="number">__</span> bind(L_no_push);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// load receiver if needed (after appendix is pushed so parameter size is correct)</span></div><div class="line">  <span class="comment">// Note: no return address pushed yet</span></div><div class="line">  <span class="keyword">if</span> (load_receiver) &#123;</div><div class="line">    <span class="number">__</span> movl(recv, flags);</div><div class="line">    <span class="number">__</span> andl(recv, ConstantPoolCacheEntry::parameter_size_mask);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> no_return_pc_pushed_yet = <span class="number">-1</span>;  <span class="comment">// argument slot correction before we push return address</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> receiver_is_at_end      = <span class="number">-1</span>;  <span class="comment">// back off one slot to get receiver</span></div><div class="line">    Address recv_addr = <span class="number">__</span> argument_address(recv, no_return_pc_pushed_yet + receiver_is_at_end);</div><div class="line">    <span class="number">__</span> movptr(recv, recv_addr);</div><div class="line">    <span class="number">__</span> verify_oop(recv);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (save_flags) &#123;</div><div class="line">    <span class="number">__</span> movl(r13, flags);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// compute return type</span></div><div class="line">  <span class="number">__</span> shrl(flags, ConstantPoolCacheEntry::tos_state_shift);</div><div class="line">  <span class="comment">// Make sure we don't need to mask flags after the above shift</span></div><div class="line">  ConstantPoolCacheEntry::verify_tos_state_shift();</div><div class="line">  <span class="comment">// load return address</span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">const</span> address table_addr = (is_invokeinterface || is_invokedynamic) ?</div><div class="line">        (address)Interpreter::return_5_addrs_by_index_table() :</div><div class="line">        (address)Interpreter::return_3_addrs_by_index_table();</div><div class="line">    <span class="function">ExternalAddress <span class="title">table</span><span class="params">(table_addr)</span></span>;</div><div class="line">    <span class="number">__</span> lea(rscratch1, table);</div><div class="line">    <span class="number">__</span> movptr(flags, Address(rscratch1, flags, Address::times_ptr));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// push return address</span></div><div class="line">  <span class="number">__</span> push(flags);</div><div class="line"></div><div class="line">  <span class="comment">// Restore flags value from the constant pool cache, and restore rsi</span></div><div class="line">  <span class="comment">// for later null checks.  r13 is the bytecode pointer</span></div><div class="line">  <span class="keyword">if</span> (save_flags) &#123;</div><div class="line">    <span class="number">__</span> movl(flags, r13);</div><div class="line">    <span class="number">__</span> restore_bcp();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>更细致的，<strong>__ save_bcp()</strong>,从当前栈中获取bcp(指向字节码代码位置)的地址，即栈中<strong>saved r13</strong>(参考<a href="2016/09/19/object_init_2/">Object 初始化过程(二)</a>的栈内容):<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/|\</div><div class="line"> |  低地址方向</div><div class="line"> |</div><div class="line"> </div><div class="line">// [ monitor entry      ] &lt;--- rsp</div><div class="line">//   ...</div><div class="line">// [ monitor entry      ]</div><div class="line">// [ expr. stack bottom ] &lt;--- expression stack bottom(rsp调用地址)</div><div class="line">// [ saved r13          ] &lt;--- bcp，************就是在这儿************，保存指向当前处理字节码的地址</div><div class="line">// [ current r14        ] &lt;--- locals pointer</div><div class="line">// [ rdx                ] &lt;--- constant pool cache</div><div class="line">// [ 0                  ] &lt;--- method data pointer</div><div class="line">// [ methodOop          ]</div><div class="line">// [ NULL_WORD          ] &lt;--- last_sp 32bit</div><div class="line">// [ saved r13          ] &lt;--- sender sp 这个地方也保存了r13?</div><div class="line">// [ saved ebp          ] &lt;--- rbp</div><div class="line">// [ return address     ] &lt;--- rax=return address</div><div class="line">// [ local variable m   ]</div><div class="line">//   ...</div><div class="line">// [ local variable 1   ]</div><div class="line">// [ parameter n        ]</div><div class="line">//   ...</div><div class="line">// [ parameter 1        ] &lt;--- r14</div></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Interpreter-specific registers</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_bcp</span><span class="params">()</span> </span>&#123;</div><div class="line">  movptr(Address(rbp, frame::interpreter_frame_bcx_offset * wordSize), r13);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\cpu\x86\vm\templateTable_x86_64.cpp:</div><div class="line"></div><div class="line"><span class="keyword">void</span> TemplateTable::load_invoke_cp_cache_entry(<span class="keyword">int</span> byte_no,</div><div class="line">                                               Register method,</div><div class="line">                                               Register itable_index,</div><div class="line">                                               Register flags,</div><div class="line">                                               <span class="keyword">bool</span> is_invokevirtual,</div><div class="line">                                               <span class="keyword">bool</span> is_invokevfinal, <span class="comment">/*unused*/</span></div><div class="line">                                               <span class="keyword">bool</span> is_invokedynamic) &#123;</div><div class="line">  <span class="comment">// setup registers</span></div><div class="line">  <span class="keyword">const</span> Register cache = rcx;</div><div class="line">  <span class="keyword">const</span> Register index = rdx;</div><div class="line">  assert_different_registers(method, flags);</div><div class="line">  assert_different_registers(method, cache, index);</div><div class="line">  assert_different_registers(itable_index, flags);</div><div class="line">  assert_different_registers(itable_index, cache, index);</div><div class="line">  <span class="comment">// determine constant pool cache field offsets</span></div><div class="line">  assert(is_invokevirtual == (byte_no == f2_byte), <span class="string">"is_invokevirtual flag redundant"</span>);</div><div class="line">  <span class="keyword">const</span> <span class="keyword">int</span> method_offset = in_bytes(</div><div class="line">    constantPoolCacheOopDesc::base_offset() +</div><div class="line">      ((byte_no == f2_byte)</div><div class="line">       ? ConstantPoolCacheEntry::f2_offset()</div><div class="line">       : ConstantPoolCacheEntry::f1_offset()));</div><div class="line">  <span class="keyword">const</span> <span class="keyword">int</span> flags_offset = in_bytes(constantPoolCacheOopDesc::base_offset() +</div><div class="line">                                    ConstantPoolCacheEntry::flags_offset());</div><div class="line">  <span class="comment">// access constant pool cache fields</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">int</span> index_offset = in_bytes(constantPoolCacheOopDesc::base_offset() +</div><div class="line">                                    ConstantPoolCacheEntry::f2_offset());</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (byte_no == f12_oop) &#123;</div><div class="line">    <span class="comment">// Resolved f1_oop (CallSite, MethodType, etc.) goes into 'itable_index'.</span></div><div class="line">    <span class="comment">// Resolved f2_oop (methodOop invoker) will go into 'method' (at index_offset).</span></div><div class="line">    <span class="comment">// See ConstantPoolCacheEntry::set_dynamic_call and set_method_handle.</span></div><div class="line">    <span class="keyword">size_t</span> index_size = (is_invokedynamic ? <span class="keyword">sizeof</span>(u4) : <span class="keyword">sizeof</span>(u2));</div><div class="line">    resolve_cache_and_index(byte_no, itable_index, cache, index, index_size);</div><div class="line">    <span class="number">__</span> movptr(method, Address(cache, index, Address::times_ptr, index_offset));</div><div class="line">    itable_index = noreg;  <span class="comment">// hack to disable load below</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    resolve_cache_and_index(byte_no, noreg, cache, index, <span class="keyword">sizeof</span>(u2));</div><div class="line">    <span class="number">__</span> movptr(method, Address(cache, index, Address::times_ptr, method_offset));</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (itable_index != noreg) &#123;</div><div class="line">    <span class="comment">// pick up itable index from f2 also:</span></div><div class="line">    assert(byte_no == f1_byte, <span class="string">"already picked up f1"</span>);</div><div class="line">    <span class="number">__</span> movptr(itable_index, Address(cache, index, Address::times_ptr, index_offset));</div><div class="line">  &#125;</div><div class="line">  <span class="number">__</span> movl(flags, Address(cache, index, Address::times_ptr, flags_offset));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>invokestatic</strong>指令的长度为f1_byte，也就是说byte_no为f1_byte，所以调用<strong>resolve_cache_and_index</strong>：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\cpu\x86\vm\templateTable_x86_64.cpp:</div><div class="line"></div><div class="line"><span class="keyword">void</span> TemplateTable::resolve_cache_and_index(<span class="keyword">int</span> byte_no,</div><div class="line">                                            Register result,</div><div class="line">                                            Register Rcache,</div><div class="line">                                            Register index,</div><div class="line">                                            <span class="keyword">size_t</span> index_size) &#123;</div><div class="line">  <span class="keyword">const</span> Register temp = rbx;</div><div class="line">  assert_different_registers(result, Rcache, index, temp);</div><div class="line"></div><div class="line">  Label resolved;</div><div class="line">  <span class="keyword">if</span> (byte_no == f12_oop) &#123;</div><div class="line">    <span class="comment">// We are resolved if the f1 field contains a non-null object (CallSite, MethodType, etc.)</span></div><div class="line">    <span class="comment">// This kind of CP cache entry does not need to match bytecode_1 or bytecode_2, because</span></div><div class="line">    <span class="comment">// there is a 1-1 relation between bytecode type and CP entry type.</span></div><div class="line">    <span class="comment">// The caller will also load a methodOop from f2.</span></div><div class="line">    assert(result != noreg, <span class="string">""</span>); <span class="comment">//else do cmpptr(Address(...), (int32_t) NULL_WORD)</span></div><div class="line">    <span class="number">__</span> get_cache_and_index_at_bcp(Rcache, index, <span class="number">1</span>, index_size);</div><div class="line">    <span class="number">__</span> movptr(result, Address(Rcache, index, Address::times_ptr, constantPoolCacheOopDesc::base_offset() + ConstantPoolCacheEntry::f1_offset()));</div><div class="line">    <span class="number">__</span> testptr(result, result);</div><div class="line">    <span class="number">__</span> jcc(Assembler::notEqual, resolved);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    assert(byte_no == f1_byte || byte_no == f2_byte, <span class="string">"byte_no out of range"</span>);</div><div class="line">    assert(result == noreg, <span class="string">""</span>);  <span class="comment">//else change code for setting result</span></div><div class="line">    <span class="number">__</span> get_cache_and_index_and_bytecode_at_bcp(Rcache, index, temp, byte_no, <span class="number">1</span>, index_size);</div><div class="line">    <span class="number">__</span> cmpl(temp, (<span class="keyword">int</span>) bytecode());  <span class="comment">// have we resolved this bytecode?</span></div><div class="line">    <span class="number">__</span> jcc(Assembler::equal, resolved);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// resolve first time through</span></div><div class="line">  address entry;</div><div class="line">  <span class="keyword">switch</span> (bytecode()) &#123;</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>getstatic:</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>putstatic:</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>getfield:</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>putfield:</div><div class="line">    entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_get_put);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>invokevirtual:</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>invokespecial:</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>invokestatic:</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>invokeinterface:</div><div class="line">    entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_invoke);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>invokehandle:</div><div class="line">    entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_invokehandle);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>invokedynamic:</div><div class="line">    entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_invokedynamic);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_f</span>ast_aldc:</div><div class="line">    entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_f</span>ast_aldc_w:</div><div class="line">    entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">default</span>:</div><div class="line">    fatal(err_msg(<span class="string">"unexpected bytecode: %s"</span>, Bytecodes::name(bytecode())));</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="number">__</span> movl(temp, (<span class="keyword">int</span>) bytecode());</div><div class="line">  <span class="number">__</span> call_VM(noreg, entry, temp);</div><div class="line"></div><div class="line">  <span class="comment">// Update registers with resolved info</span></div><div class="line">  <span class="number">__</span> get_cache_and_index_at_bcp(Rcache, index, <span class="number">1</span>, index_size);</div><div class="line">  <span class="keyword">if</span> (result != noreg)</div><div class="line">    <span class="number">__</span> movptr(result, Address(Rcache, index, Address::times_ptr, constantPoolCacheOopDesc::base_offset() + ConstantPoolCacheEntry::f1_offset()));</div><div class="line">  <span class="number">__</span> bind(resolved);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>后续调用<strong>get_cache_and_index_and_bytecode_at_bcp</strong>:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\cpu\x86\vm\interp_masm_x86_64.cpp:</div><div class="line"></div><div class="line"><span class="keyword">void</span> InterpreterMacroAssembler::get_cache_and_index_and_bytecode_at_bcp(Register cache,</div><div class="line">                                                                        Register index,</div><div class="line">                                                                        Register bytecode,</div><div class="line">                                                                        <span class="keyword">int</span> byte_no,</div><div class="line">                                                                        <span class="keyword">int</span> bcp_offset,</div><div class="line">                                                                        <span class="keyword">size_t</span> index_size) &#123;</div><div class="line">  get_cache_and_index_at_bcp(cache, index, bcp_offset, index_size);</div><div class="line">  <span class="comment">// We use a 32-bit load here since the layout of 64-bit words on</span></div><div class="line">  <span class="comment">// little-endian machines allow us that.</span></div><div class="line">  movl(bytecode, Address(cache, index, Address::times_ptr, constantPoolCacheOopDesc::base_offset() + ConstantPoolCacheEntry::indices_offset()));</div><div class="line">  <span class="keyword">const</span> <span class="keyword">int</span> shift_count = (<span class="number">1</span> + byte_no) * BitsPerByte;</div><div class="line">  assert((byte_no == TemplateTable::f1_byte &amp;&amp; shift_count == ConstantPoolCacheEntry::bytecode_1_shift) ||</div><div class="line">         (byte_no == TemplateTable::f2_byte &amp;&amp; shift_count == ConstantPoolCacheEntry::bytecode_2_shift),</div><div class="line">         <span class="string">"correct shift count"</span>);</div><div class="line">  shrl(bytecode, shift_count);</div><div class="line">  assert(ConstantPoolCacheEntry::bytecode_1_mask == ConstantPoolCacheEntry::bytecode_2_mask, <span class="string">"common mask"</span>);</div><div class="line">  andl(bytecode, ConstantPoolCacheEntry::bytecode_1_mask);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> InterpreterMacroAssembler::get_cache_and_index_at_bcp(Register cache,</div><div class="line">                                                           Register index,</div><div class="line">                                                           <span class="keyword">int</span> bcp_offset,</div><div class="line">                                                           <span class="keyword">size_t</span> index_size) &#123;</div><div class="line">  assert_different_registers(cache, index);</div><div class="line">  get_cache_index_at_bcp(index, bcp_offset, index_size);</div><div class="line">  movptr(cache, Address(rbp, frame::interpreter_frame_cache_offset * wordSize));</div><div class="line">  assert(<span class="keyword">sizeof</span>(ConstantPoolCacheEntry) == <span class="number">4</span> * wordSize, <span class="string">"adjust code below"</span>);</div><div class="line">  <span class="comment">// convert from field index to ConstantPoolCacheEntry index</span></div><div class="line">  shll(index, <span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> InterpreterMacroAssembler::get_cache_index_at_bcp(Register index,</div><div class="line">                                                       <span class="keyword">int</span> bcp_offset,</div><div class="line">                                                       <span class="keyword">size_t</span> index_size) &#123;</div><div class="line">  assert(bcp_offset &gt; <span class="number">0</span>, <span class="string">"bcp is still pointing to start of bytecode"</span>);</div><div class="line">  <span class="keyword">if</span> (index_size == <span class="keyword">sizeof</span>(u2)) &#123;</div><div class="line">    load_unsigned_short(index, Address(r13, bcp_offset));</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index_size == <span class="keyword">sizeof</span>(u4)) &#123;</div><div class="line">    assert(EnableInvokeDynamic, <span class="string">"giant index used only for JSR 292"</span>);</div><div class="line">    movl(index, Address(r13, bcp_offset));</div><div class="line">    <span class="comment">// Check if the secondary index definition is still ~x, otherwise</span></div><div class="line">    <span class="comment">// we have to change the following assembler code to calculate the</span></div><div class="line">    <span class="comment">// plain index.</span></div><div class="line">    assert(constantPoolCacheOopDesc::decode_secondary_index(~<span class="number">123</span>) == <span class="number">123</span>, <span class="string">"else change next line"</span>);</div><div class="line">    notl(index);  <span class="comment">// convert to plain index</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index_size == <span class="keyword">sizeof</span>(u1)) &#123;</div><div class="line">    assert(EnableInvokeDynamic, <span class="string">"tiny index used only for JSR 292"</span>);</div><div class="line">    load_unsigned_byte(index, Address(r13, bcp_offset));</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    ShouldNotReachHere();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于<strong>**指令的参数长度为u2,index_size为sizeof(u2),bcp_offset为1，所以</strong>get_cache_index_at_bcp<strong>的作用就是从字节码的开始的地址加载2个无符号字节放入到index,而index即寄存器</strong>rdx<strong>。我们返回来看</strong>get_cache_and_index_at_bcp**，通过方法栈获取methodOop的指针地址，并且左移2位，这里为什么左移2位后面会有描述，获取ConstantPoolCacheEntry的索引值，此时：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">RDX    invokestatic指令的参数，ConstantPoolCacheEntry的索引值</div><div class="line">RCX    此方法对应的methodOop结构</div></pre></td></tr></table></figure></p>
<p><strong>get_cache_and_index_and_bytecode_at_bcp</strong>方法计算出了rdx，rcx后，看不出来了，晕！，先回去看类加载吧，看看几个重要的数据结构！</p>
<p><strong>MARK</strong></p>
<p>这里涉及运行时解析链接的工作。我们详细了解一下这个过程。首先我们理解一下ConstantPoolCacheEntry的结构，如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\oops\cpCache.hpp:</div><div class="line"></div><div class="line">  volatile intx     _indices;  // constant pool index &amp; rewrite bytecodes</div><div class="line">  volatile Metadata*   _f1;       // entry specific metadata field</div><div class="line">  volatile intx        _f2;       // entry specific int/metadata field</div><div class="line">  volatile intx     _flags;    // flags</div></pre></td></tr></table></figure></p>
<p>这些域的含义随着后续的阅读，会慢慢理解其中的含义。在x84_64中，这个结构的大小为32个字节，占四个字长。这里涉及重载的过程，如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\interpreter\rewriter.cpp:</div><div class="line"></div><div class="line"><span class="keyword">void</span> Rewriter::make_constant_pool_cache(TRAPS) &#123;</div><div class="line">  ClassLoaderData* loader_data = <span class="number">_</span>pool-&gt;pool_holder()-&gt;class_loader_data();</div><div class="line">  ConstantPoolCache* cache =</div><div class="line">      ConstantPoolCache::allocate(loader_data, <span class="number">_</span>cp_cache_map,</div><div class="line">                                  <span class="number">_</span>invokedynamic_cp_cache_map,</div><div class="line">                                  <span class="number">_</span>invokedynamic_references_map, CHECK);</div><div class="line"></div><div class="line">  <span class="comment">// initialize object cache in constant pool</span></div><div class="line">  <span class="number">_</span>pool-&gt;initialize_resolved_references(loader_data, <span class="number">_</span>resolved_references_map,</div><div class="line">                                        <span class="number">_</span>resolved_reference_limit,</div><div class="line">                                        CHECK);</div><div class="line">  <span class="number">_</span>pool-&gt;set_cache(cache);</div><div class="line">  cache-&gt;set_constant_pool(<span class="number">_</span>pool());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虚拟机为每一个类，即Klass的常量池建立一个cache，这个cache主要用于各种各样的场景，而我们这里是其中一个场景。Rewiter会在重写的时候讲这个cache的索引值写入对应字节码的位置，需要注意的是，经过复写后，字节码后面跟随的不是常量池索引了，而是这个cache的索引。这个cache的结构即ConstantPoolCache类。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> --------------------------</div><div class="line">| cache header             |</div><div class="line"> --------------------------</div><div class="line">| ConstantPoolCacheEntry 0 |</div><div class="line"> --------------------------</div><div class="line">| ConstantPoolCacheEntry 1 |</div><div class="line"> --------------------------</div><div class="line">| ...                      |</div><div class="line"> --------------------------</div><div class="line">| ConstantPoolCacheEntry N |</div><div class="line"> --------------------------</div></pre></td></tr></table></figure></p>
<p>ConstantPoolCache包含控制结构header和每一个子项，每个子项映射了cache和对应项的映射关系(常量池索引等等)。我们可以根据cache的索引获取对应的结构信息，因为这里每个子项大小为32，那么根据index需要左移5位，就可以找到对应项的地址。我们返回到前面有一个问题<strong>从内存加载的index为什么左移2位？</strong>，由于在X86_64每个指针默认大小为8位，也就是左移3位，那么根据这个index还需要左移2位才能获取cache真正需要的地址位置。所以这里需要左移2位。加载真正的地址的时候由于系统为8个字节，所以会偏移8个字节进行寻址，后面我们会看到这点(这个在intel中术语叫scale)。<br>我们继续往下看:<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">hotspot\src\cpu\x86\vm\interp_masm_x86_64.cpp:</div><div class="line"></div><div class="line"><span class="keyword">void</span> InterpreterMacroAssembler::get_cache_and_index_and_bytecode_at_bcp(Register cache,</div><div class="line">                                                                        Register index,</div><div class="line">                                                                        Register bytecode,</div><div class="line">                                                                        <span class="keyword">int</span> byte_no,</div><div class="line">                                                                        <span class="keyword">int</span> bcp_offset,</div><div class="line">                                                                        <span class="keyword">size_t</span> index_size) &#123;</div><div class="line">  get_cache_and_index_at_bcp(cache, index, bcp_offset, index_size);</div><div class="line">  <span class="comment">// We use a 32-bit load here since the layout of 64-bit words on</span></div><div class="line">  <span class="comment">// little-endian machines allow us that.</span></div><div class="line">  movl(bytecode, Address(cache, index, Address::times_ptr, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::indices_offset()));         <span class="comment">// 1</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">int</span> shift_count = (<span class="number">1</span> + byte_no) * BitsPerByte;</div><div class="line">  assert((byte_no == TemplateTable::f1_byte &amp;&amp; shift_count == ConstantPoolCacheEntry::bytecode_1_shift) ||</div><div class="line">         (byte_no == TemplateTable::f2_byte &amp;&amp; shift_count == ConstantPoolCacheEntry::bytecode_2_shift),</div><div class="line">         <span class="string">"correct shift count"</span>);</div><div class="line">  shrl(bytecode, shift_count);</div><div class="line">  assert(ConstantPoolCacheEntry::bytecode_1_mask == ConstantPoolCacheEntry::bytecode_2_mask, <span class="string">"common mask"</span>);</div><div class="line">  andl(bytecode, ConstantPoolCacheEntry::bytecode_1_mask);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有了以上的知识，我们看这段代码就很简单了，第一步就是从常量池缓存中获取对应子项的内容，在这个场景中，我们可以知道子项_indices包保存的是常量池索引或者是已经经过链接的字节码。所以我们可以根据这个值来判断是否已经经过链接。这里是第一次运行，所以我们还没有链接，我们继续往下。<br>后面就是真正执行链接过程了：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">hotspot\src\cpu\x86\vm\templateTable_x86_64.cpp:</div><div class="line"></div><div class="line"><span class="keyword">void</span> TemplateTable::resolve_cache_and_index(<span class="keyword">int</span> byte_no,</div><div class="line">                                            Register Rcache,</div><div class="line">                                            Register index,</div><div class="line">                                            <span class="keyword">size_t</span> index_size) &#123;</div><div class="line">  <span class="keyword">const</span> Register temp = rbx;</div><div class="line">  assert_different_registers(Rcache, index, temp);</div><div class="line"></div><div class="line">  Label resolved;</div><div class="line">    assert(byte_no == f1_byte || byte_no == f2_byte, <span class="string">"byte_no out of range"</span>);</div><div class="line">    <span class="number">__</span> get_cache_and_index_and_bytecode_at_bcp(Rcache, index, temp, byte_no, <span class="number">1</span>, index_size);</div><div class="line">    <span class="number">__</span> cmpl(temp, (<span class="keyword">int</span>) bytecode());  <span class="comment">// have we resolved this bytecode?</span></div><div class="line">    <span class="number">__</span> jcc(Assembler::equal, resolved);</div><div class="line"></div><div class="line"> <span class="comment">// resolve first time through</span></div><div class="line">  address entry;</div><div class="line">  <span class="keyword">switch</span> (bytecode()) &#123;</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>getstatic:</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>putstatic:</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>getfield:</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>putfield:</div><div class="line">    entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_get_put);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>invokevirtual:</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>invokespecial:</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>invokestatic:</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>invokeinterface:</div><div class="line">    entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_invoke);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>invokehandle:</div><div class="line">    entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_invokehandle);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>invokedynamic:</div><div class="line">    entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_invokedynamic);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">default</span>:</div><div class="line">    fatal(err_msg(<span class="string">"unexpected bytecode: %s"</span>, Bytecodes::name(bytecode())));</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="number">__</span> movl(temp, (<span class="keyword">int</span>) bytecode());</div><div class="line">  <span class="number">__</span> call_VM(noreg, entry, temp);</div><div class="line"></div><div class="line">  <span class="comment">// Update registers with resolved info</span></div><div class="line">  <span class="number">__</span> get_cache_and_index_at_bcp(Rcache, index, <span class="number">1</span>, index_size);</div><div class="line">  <span class="number">__</span> bind(resolved);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于我们是第一次执行，所以这里字节码比较是不同的，我们这里调用的是<strong>_invokestatic</strong>，另外需要注意这里执行的是解释器运行的时候动态生成的指令，而不是这段代码，我们这里描述的执行过程，并不是运行的时候和这段代码一模一样，但是这段代码和运行时逻辑是一样的。下面就是真正执行链接的过程了，用C++代码写的，上面是生成的指令,这里的链接过程主要就是根据常量池的索引找到对应方法的描述，然后替换这个地址，链接只会执行一次，后续的调用发现已经链接过，直接执行目标方法：<br><figure class="highlight"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\interpreter\interpreterRuntime.cpp：</div><div class="line"></div><div class="line">IRT_ENTRY(void, InterpreterRuntime::resolve_invoke(JavaThread* thread, Bytecodes::Code bytecode)) &#123;</div><div class="line">  // extract receiver from the outgoing argument list if necessary</div><div class="line">  Handle receiver(thread, NULL);</div><div class="line">  if (bytecode == Bytecodes::_invokevirtual || bytecode == Bytecodes::_invokeinterface) &#123;</div><div class="line">    ResourceMark rm(thread);</div><div class="line">    methodHandle m (thread, method(thread));</div><div class="line">    Bytecode_invoke call(m, bci(thread));</div><div class="line">    Symbol* signature = call.signature();</div><div class="line">    receiver = Handle(thread,</div><div class="line">                  thread-&gt;last_frame().interpreter_callee_receiver(signature));</div><div class="line">    assert(Universe::heap()-&gt;is_in_reserved_or_null(receiver()),</div><div class="line">           "sanity check");</div><div class="line">    assert(receiver.is_null() ||</div><div class="line">           !Universe::heap()-&gt;is_in_reserved(receiver-&gt;klass()),</div><div class="line">           "sanity check");</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>这里我们不会执行到，所以跳过：<br><figure class="highlight"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\interpreter\interpreterRuntime.cpp：</div><div class="line"></div><div class="line">  // resolve method</div><div class="line">  CallInfo info;</div><div class="line">  constantPoolHandle pool(thread, method(thread)-&gt;constants());</div><div class="line"></div><div class="line">  &#123;</div><div class="line">    JvmtiHideSingleStepping jhss(thread);</div><div class="line">    LinkResolver::resolve_invoke(info, receiver, pool,</div><div class="line">                                 get_index_u2_cpcache(thread, bytecode), bytecode, CHECK);</div><div class="line">    if (JvmtiExport::can_hotswap_or_post_breakpoint()) &#123;</div><div class="line">      int retry_count = 0;</div><div class="line">      while (info.resolved_method()-&gt;is_old()) &#123;</div><div class="line">        // It is very unlikely that method is redefined more than 100 times</div><div class="line">        // in the middle of resolve. If it is looping here more than 100 times</div><div class="line">        // means then there could be a bug here.</div><div class="line">        guarantee((retry_count++ &lt; 100),</div><div class="line">                  "Could not resolve to latest version of redefined method");</div><div class="line">        // method is redefined in the middle of resolve so re-try.</div><div class="line">        LinkResolver::resolve_invoke(info, receiver, pool,</div><div class="line">                                     get_index_u2_cpcache(thread, bytecode), bytecode, CHECK);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125; // end JvmtiHideSingleStepping</div></pre></td></tr></table></figure></p>
<p>从上面看真正执行的是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">    LinkResolver::resolve_invoke(info, receiver, pool,</div><div class="line">                                 get_index_u2_cpcache(thread, bytecode), bytecode, CHECK);</div><div class="line"></div><div class="line">hotspot\src\share\vm\interpreter\linkResolver.cpp：</div><div class="line"></div><div class="line">void LinkResolver::resolve_invoke(CallInfo&amp; result, Handle recv, constantPoolHandle pool, int index, Bytecodes::Code byte, TRAPS) &#123;</div><div class="line">  switch (byte) &#123;</div><div class="line">    case Bytecodes::_invokestatic   : resolve_invokestatic   (result,       pool, index, CHECK); break;</div><div class="line">    case Bytecodes::_invokespecial  : resolve_invokespecial  (result,       pool, index, CHECK); break;</div><div class="line">    case Bytecodes::_invokevirtual  : resolve_invokevirtual  (result, recv, pool, index, CHECK); break;</div><div class="line">    case Bytecodes::_invokehandle   : resolve_invokehandle   (result,       pool, index, CHECK); break;</div><div class="line">    case Bytecodes::_invokedynamic  : resolve_invokedynamic  (result,       pool, index, CHECK); break;</div><div class="line">    case Bytecodes::_invokeinterface: resolve_invokeinterface(result, recv, pool, index, CHECK); break;</div><div class="line">  &#125;</div><div class="line">  return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void LinkResolver::resolve_invokestatic(CallInfo&amp; result, constantPoolHandle pool, int index, TRAPS) &#123;</div><div class="line">  KlassHandle  resolved_klass;</div><div class="line">  Symbol* method_name = NULL;</div><div class="line">  Symbol* method_signature = NULL;</div><div class="line">  KlassHandle  current_klass;</div><div class="line">  resolve_pool(resolved_klass, method_name,  method_signature, current_klass, pool, index, CHECK);</div><div class="line">  resolve_static_call(result, resolved_klass, method_name, method_signature, current_klass, true, true, CHECK);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们先看<strong>resolve_pool</strong>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\interpreter\linkResolver.cpp：</div><div class="line"></div><div class="line">void LinkResolver::resolve_pool(KlassHandle&amp; resolved_klass, Symbol*&amp; method_name, Symbol*&amp; method_signature,</div><div class="line">                                KlassHandle&amp; current_klass, constantPoolHandle pool, int index, TRAPS) &#123;</div><div class="line">   // resolve klass</div><div class="line">  resolve_klass(resolved_klass, pool, index, CHECK);</div><div class="line"></div><div class="line">  // Get name, signature, and static klass</div><div class="line">  method_name      = pool-&gt;name_ref_at(index);</div><div class="line">  method_signature = pool-&gt;signature_ref_at(index);</div><div class="line">  current_klass    = KlassHandle(THREAD, pool-&gt;pool_holder());</div><div class="line">&#125;</div><div class="line"></div><div class="line">void LinkResolver::resolve_klass(KlassHandle&amp; result, constantPoolHandle pool, int index, TRAPS) &#123;</div><div class="line">  Klass* result_oop = pool-&gt;klass_ref_at(index, CHECK);</div><div class="line">  result = KlassHandle(THREAD, result_oop);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里主要根据常量池索引获取对应的Klass内存表示。这里可能涉及类的加载等工作。<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="keyword">void</span> LinkResolver::resolve_static_call(CallInfo&amp; result, KlassHandle&amp; resolved_klass, Symbol* method_name,</div><div class="line">                                       Symbol* method_signature, KlassHandle current_klass,</div><div class="line">                                       <span class="keyword">bool</span> check_access, <span class="keyword">bool</span> initialize_class, TRAPS) &#123;</div><div class="line">  methodHandle resolved_method;</div><div class="line">  linktime_resolve_static_method(resolved_method, resolved_klass, method_name, method_signature, current_klass, check_access, CHECK);</div><div class="line">  resolved_klass = KlassHandle(THREAD, resolved_method-&gt;method_holder());</div><div class="line"></div><div class="line">  <span class="comment">// Initialize klass (this should only happen if everything is ok)</span></div><div class="line">  <span class="keyword">if</span> (initialize_class &amp;&amp; resolved_klass-&gt;should_be_initialized()) &#123;</div><div class="line">    resolved_klass-&gt;initialize(CHECK);</div><div class="line">    linktime_resolve_static_method(resolved_method, resolved_klass, method_name, method_signature, current_klass, check_access, CHECK);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// setup result</span></div><div class="line">  result.set_static(resolved_klass, resolved_method, CHECK);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// throws linktime exceptions</span></div><div class="line"><span class="keyword">void</span> LinkResolver::linktime_resolve_static_method(methodHandle&amp; resolved_method, KlassHandle resolved_klass,</div><div class="line">                                                  Symbol* method_name, Symbol* method_signature,</div><div class="line">                                                  KlassHandle current_klass, <span class="keyword">bool</span> check_access, TRAPS) &#123;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!resolved_klass-&gt;is_interface()) &#123;</div><div class="line">    resolve_method(resolved_method, resolved_klass, method_name, method_signature, current_klass, check_access, <span class="literal">false</span>, CHECK);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    resolve_interface_method(resolved_method, resolved_klass, method_name, method_signature, current_klass, check_access, <span class="literal">false</span>, CHECK);</div><div class="line">  &#125;</div><div class="line">  assert(resolved_method-&gt;name() != vmSymbols::class_initializer_name(), <span class="string">"should have been checked in verifier"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// check if static</span></div><div class="line">  <span class="keyword">if</span> (!resolved_method-&gt;is_static()) &#123;</div><div class="line">    <span class="function">ResourceMark <span class="title">rm</span><span class="params">(THREAD)</span></span>;</div><div class="line">    <span class="keyword">char</span> buf[<span class="number">200</span>];</div><div class="line">    jio_snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"Expected static method %s"</span>, Method::name_and_sig_as_C_string(resolved_klass(),</div><div class="line">                                                      resolved_method-&gt;name(),</div><div class="line">                                                      resolved_method-&gt;signature()));</div><div class="line">    THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>后面的代码就比较简单了，主要就是从目标加载的Klass中获取对应的方法调用地址。重点看找到对应的方法调用地址虚拟机的回填动作。<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\interpreter\interpreterRuntime.cpp：</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (already_resolved(thread)) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (bytecode == Bytecodes::<span class="number">_</span>invokeinterface) &#123;</div><div class="line">    <span class="keyword">if</span> (TraceItables &amp;&amp; Verbose) &#123;</div><div class="line">      <span class="function">ResourceMark <span class="title">rm</span><span class="params">(thread)</span></span>;</div><div class="line">      tty-&gt;print_cr(<span class="string">"Resolving: klass: %s to method: %s"</span>, info.resolved_klass()-&gt;name()-&gt;as_C_string(), info.resolved_method()-&gt;name()-&gt;as_C_string());</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></div><div class="line">  <span class="keyword">if</span> (bytecode == Bytecodes::<span class="number">_</span>invokeinterface) &#123;</div><div class="line">    <span class="keyword">if</span> (info.resolved_method()-&gt;method_holder() ==</div><div class="line">                                            SystemDictionary::Object_klass()) &#123;</div><div class="line">      <span class="comment">// <span class="doctag">NOTE:</span> THIS IS A FIX FOR A CORNER CASE in the JVM spec</span></div><div class="line">      <span class="comment">// (see also CallInfo::set_interface for details)</span></div><div class="line">      assert(info.call_kind() == CallInfo::vtable_call ||</div><div class="line">             info.call_kind() == CallInfo::direct_call, <span class="string">""</span>);</div><div class="line">      methodHandle rm = info.resolved_method();</div><div class="line">      assert(rm-&gt;is_final() || info.has_vtable_index(),</div><div class="line">             <span class="string">"should have been set already"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!info.resolved_method()-&gt;has_itable_index()) &#123;</div><div class="line">      <span class="comment">// Resolved something like CharSequence.toString.  Use vtable not itable.</span></div><div class="line">      assert(info.call_kind() != CallInfo::itable_call, <span class="string">""</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// Setup itable entry</span></div><div class="line">      assert(info.call_kind() == CallInfo::itable_call, <span class="string">""</span>);</div><div class="line">      <span class="keyword">int</span> index = info.resolved_method()-&gt;itable_index();</div><div class="line">      assert(info.itable_index() == index, <span class="string">""</span>);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    assert(info.call_kind() == CallInfo::direct_call ||</div><div class="line">           info.call_kind() == CallInfo::vtable_call, <span class="string">""</span>);</div><div class="line">  &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">  <span class="keyword">switch</span> (info.call_kind()) &#123;</div><div class="line">  <span class="keyword">case</span> CallInfo::direct_call:</div><div class="line">    cache_entry(thread)-&gt;set_direct_call(</div><div class="line">      bytecode,</div><div class="line">      info.resolved_method());</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> CallInfo::vtable_call:</div><div class="line">    cache_entry(thread)-&gt;set_vtable_call(</div><div class="line">      bytecode,</div><div class="line">      info.resolved_method(),</div><div class="line">      info.vtable_index());</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> CallInfo::itable_call:</div><div class="line">    cache_entry(thread)-&gt;set_itable_call(</div><div class="line">      bytecode,</div><div class="line">      info.resolved_method(),</div><div class="line">      info.itable_index());</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">default</span>:  ShouldNotReachHere();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">IRT_END</div></pre></td></tr></table></figure></p>
<p>我们跟踪到查找方法的实现中，会发现返回的<strong>info.call_kind()</strong>为direct_call，所以我们重点看：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">hotspot\src\share\vm\interpreter\interpreterRuntime.hpp:</div><div class="line"></div><div class="line">  static ConstantPoolCacheEntry* cache_entry_at(JavaThread *thread, int i)  &#123; return method(thread)-&gt;constants()-&gt;cache()-&gt;entry_at(i); &#125;</div><div class="line">  static ConstantPoolCacheEntry* cache_entry(JavaThread *thread)            &#123; return cache_entry_at(thread, Bytes::get_native_u2(bcp(thread) + 1)); &#125;</div><div class="line"></div><div class="line">hotspot\src\share\vm\oops\cpCache.cpp:</div><div class="line"></div><div class="line">void ConstantPoolCacheEntry::set_direct_or_vtable_call(Bytecodes::Code invoke_code,</div><div class="line">                                                       methodHandle method,</div><div class="line">                                                       int vtable_index) &#123;</div><div class="line">  bool is_vtable_call = (vtable_index &gt;= 0);  // FIXME: split this method on this boolean</div><div class="line">  assert(method-&gt;interpreter_entry() != NULL, &quot;should have been set at this point&quot;);</div><div class="line">  assert(!method-&gt;is_obsolete(),  &quot;attempt to write obsolete method to cpCache&quot;);</div><div class="line"></div><div class="line">  int byte_no = -1;</div><div class="line">  bool change_to_virtual = false;</div><div class="line"></div><div class="line">  switch (invoke_code) &#123;</div><div class="line">    case Bytecodes::_invokeinterface:</div><div class="line">      // We get here from InterpreterRuntime::resolve_invoke when an invokeinterface</div><div class="line">      // instruction somehow links to a non-interface method (in Object).</div><div class="line">      // In that case, the method has no itable index and must be invoked as a virtual.</div><div class="line">      // Set a flag to keep track of this corner case.</div><div class="line">      change_to_virtual = true;</div><div class="line"></div><div class="line">      // ...and fall through as if we were handling invokevirtual:</div><div class="line">    case Bytecodes::_invokevirtual:</div><div class="line">      &#123;</div><div class="line">        if (!is_vtable_call) &#123;</div><div class="line">          assert(method-&gt;can_be_statically_bound(), &quot;&quot;);</div><div class="line">          // set_f2_as_vfinal_method checks if is_vfinal flag is true.</div><div class="line">          set_method_flags(as_TosState(method-&gt;result_type()),</div><div class="line">                           (                             1      &lt;&lt; is_vfinal_shift) |</div><div class="line">                           ((method-&gt;is_final_method() ? 1 : 0) &lt;&lt; is_final_shift)  |</div><div class="line">                           ((change_to_virtual         ? 1 : 0) &lt;&lt; is_forced_virtual_shift),</div><div class="line">                           method()-&gt;size_of_parameters());</div><div class="line">          set_f2_as_vfinal_method(method());</div><div class="line">        &#125; else &#123;</div><div class="line">          assert(!method-&gt;can_be_statically_bound(), &quot;&quot;);</div><div class="line">          assert(vtable_index &gt;= 0, &quot;valid index&quot;);</div><div class="line">          assert(!method-&gt;is_final_method(), &quot;sanity&quot;);</div><div class="line">          set_method_flags(as_TosState(method-&gt;result_type()),</div><div class="line">                           ((change_to_virtual ? 1 : 0) &lt;&lt; is_forced_virtual_shift),</div><div class="line">                           method()-&gt;size_of_parameters());</div><div class="line">          set_f2(vtable_index);</div><div class="line">        &#125;</div><div class="line">        byte_no = 2;</div><div class="line">        break;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    case Bytecodes::_invokespecial:</div><div class="line">    case Bytecodes::_invokestatic:</div><div class="line">      assert(!is_vtable_call, &quot;&quot;);</div><div class="line">      // Note:  Read and preserve the value of the is_vfinal flag on any</div><div class="line">      // invokevirtual bytecode shared with this constant pool cache entry.</div><div class="line">      // It is cheap and safe to consult is_vfinal() at all times.</div><div class="line">      // Once is_vfinal is set, it must stay that way, lest we get a dangling oop.</div><div class="line">      set_method_flags(as_TosState(method-&gt;result_type()),</div><div class="line">                       ((is_vfinal()               ? 1 : 0) &lt;&lt; is_vfinal_shift) |</div><div class="line">                       ((method-&gt;is_final_method() ? 1 : 0) &lt;&lt; is_final_shift),</div><div class="line">                       method()-&gt;size_of_parameters());</div><div class="line">      set_f1(method());</div><div class="line">      byte_no = 1;</div><div class="line">      break;</div><div class="line">    default:</div><div class="line">      ShouldNotReachHere();</div><div class="line">      break;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // Note:  byte_no also appears in TemplateTable::resolve.</div><div class="line">  if (byte_no == 1) &#123;</div><div class="line">    assert(invoke_code != Bytecodes::_invokevirtual &amp;&amp;</div><div class="line">           invoke_code != Bytecodes::_invokeinterface, &quot;&quot;);</div><div class="line">    set_bytecode_1(invoke_code);</div><div class="line">  &#125; else if (byte_no == 2)  &#123;</div><div class="line">    if (change_to_virtual) &#123;</div><div class="line">      assert(invoke_code == Bytecodes::_invokeinterface, &quot;&quot;);</div><div class="line">      // NOTE: THIS IS A HACK - BE VERY CAREFUL!!!</div><div class="line">      //</div><div class="line">      // Workaround for the case where we encounter an invokeinterface, but we</div><div class="line">      // should really have an _invokevirtual since the resolved method is a</div><div class="line">      // virtual method in java.lang.Object. This is a corner case in the spec</div><div class="line">      // but is presumably legal. javac does not generate this code.</div><div class="line">      //</div><div class="line">      // We set bytecode_1() to _invokeinterface, because that is the</div><div class="line">      // bytecode # used by the interpreter to see if it is resolved.</div><div class="line">      // We set bytecode_2() to _invokevirtual.</div><div class="line">      // See also interpreterRuntime.cpp. (8/25/2000)</div><div class="line">      // Only set resolved for the invokeinterface case if method is public.</div><div class="line">      // Otherwise, the method needs to be reresolved with caller for each</div><div class="line">      // interface call.</div><div class="line">      if (method-&gt;is_public()) set_bytecode_1(invoke_code);</div><div class="line">    &#125; else &#123;</div><div class="line">      assert(invoke_code == Bytecodes::_invokevirtual, &quot;&quot;);</div><div class="line">    &#125;</div><div class="line">    // set up for invokevirtual, even if linking for invokeinterface also:</div><div class="line">    set_bytecode_2(Bytecodes::_invokevirtual);</div><div class="line">  &#125; else &#123;</div><div class="line">    ShouldNotReachHere();</div><div class="line">  &#125;</div><div class="line">  NOT_PRODUCT(verify(tty));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>重点看：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">case Bytecodes::_invokestatic:</div><div class="line">  assert(!is_vtable_call, &quot;&quot;);</div><div class="line">  // Note:  Read and preserve the value of the is_vfinal flag on any</div><div class="line">  // invokevirtual bytecode shared with this constant pool cache entry.</div><div class="line">  // It is cheap and safe to consult is_vfinal() at all times.</div><div class="line">  // Once is_vfinal is set, it must stay that way, lest we get a dangling oop.</div><div class="line">  set_method_flags(as_TosState(method-&gt;result_type()),</div><div class="line">                   ((is_vfinal()               ? 1 : 0) &lt;&lt; is_vfinal_shift) |</div><div class="line">                   ((method-&gt;is_final_method() ? 1 : 0) &lt;&lt; is_final_shift),</div><div class="line">                   method()-&gt;size_of_parameters());</div><div class="line">  set_f1(method());</div><div class="line">  byte_no = 1;</div><div class="line">  break;</div></pre></td></tr></table></figure></p>
<p>这里重点就是设置缓存项的标志位，将f1指向方法描述。将字节码回填到<strong>_indices</strong>。上面就是链接的过程，主要就是缓存项的内容，我们这里详细描述一下每一个域：</p>
<ul>
<li>_indices<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> --------------------------------------------</div><div class="line">| code               |        cp_index       |</div><div class="line"> --------------------------------------------</div><div class="line">|31 -------------- 16| 15 ----------------- 0|</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这个域主要存储链接后的字节码和常量池索引</p>
<ul>
<li><p>flags<br>这个域主要存储的是描述信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">enum &#123;</div><div class="line">  // high order bits are the TosState corresponding to field type or method return type</div><div class="line">  tos_state_bits             = 4,</div><div class="line">  tos_state_mask             = right_n_bits(tos_state_bits),</div><div class="line">  tos_state_shift            = BitsPerInt - tos_state_bits,  // see verify_tos_state_shift below</div><div class="line">  // misc. option bits; can be any bit position in [16..27]</div><div class="line">  is_field_entry_shift       = 26,  // (F) is it a field or a method?</div><div class="line">  has_method_type_shift      = 25,  // (M) does the call site have a MethodType?</div><div class="line">  has_appendix_shift         = 24,  // (A) does the call site have an appendix argument?</div><div class="line">  is_forced_virtual_shift    = 23,  // (I) is the interface reference forced to virtual mode?</div><div class="line">  is_final_shift             = 22,  // (f) is the field or method final?</div><div class="line">  is_volatile_shift          = 21,  // (v) is the field volatile?</div><div class="line">  is_vfinal_shift            = 20,  // (vf) did the call resolve to a final method?</div><div class="line">  // low order bits give field index (for FieldInfo) or method parameter size:</div><div class="line">  field_index_bits           = 16,</div><div class="line">  field_index_mask           = right_n_bits(field_index_bits),</div><div class="line">  parameter_size_bits        = 8,  // subset of field_index_mask, range is 0..255</div><div class="line">  parameter_size_mask        = right_n_bits(parameter_size_bits),</div><div class="line">  option_bits_mask           = ~(((-1) &lt;&lt; tos_state_shift) | (field_index_mask | parameter_size_mask))</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>f1<br>entry specific metadata field,在本章存储的是method</p>
</li>
<li>f2<br>entry specific int/metadata field</li>
</ul>
<p>以上工作主要就是为了查找对应的方法描述符并且存储到rbx寄存器中，这个过程叫做链接，属于方法链接的详细步骤。我们可以知道虚拟机的链接是运行时触发的，不是在加载类文件时候就已经链接好了，是懒模式的典型应用。<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="keyword">void</span> InterpreterMacroAssembler::jump_from_interpreted(Register method, Register temp) &#123;</div><div class="line">  prepare_to_jump_from_interpreted();</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (JvmtiExport::can_post_interpreter_events()) &#123;</div><div class="line">    Label run_compiled_code;</div><div class="line">    <span class="comment">// JVMTI events, such as single-stepping, are implemented partly by avoiding running</span></div><div class="line">    <span class="comment">// compiled code in threads for which the event is enabled.  Check here for</span></div><div class="line">    <span class="comment">// interp_only_mode if these events CAN be enabled.</span></div><div class="line">    <span class="comment">// interp_only is an int, on little endian it is sufficient to test the byte only</span></div><div class="line">    <span class="comment">// Is a cmpl faster?</span></div><div class="line">    cmpb(Address(r15_thread, JavaThread::interp_only_mode_offset()), <span class="number">0</span>);</div><div class="line">    jccb(Assembler::zero, run_compiled_code);</div><div class="line">    jmp(Address(method, Method::interpreter_entry_offset()));</div><div class="line">    bind(run_compiled_code);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  jmp(Address(method, Method::from_interpreted_offset()));</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码就很简单了，根据方法描述符的位移获取方法解释器的地址进行调用，就完成一次<strong>invokestatic</strong>的调用过程。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/09/19/object_init_4/" class="archive-article-date">
  	<time datetime="2016-09-19T12:43:37.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-09-19</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/JVM/">JVM</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
    <a href="/2016/09/20/linux-kernel-main/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="icon-circle-left"></i>
      <div class="article-nav-title">
        
          linux_kernel_main
        
      </div>
    </a>
  
  
    <a href="/2016/09/19/object_init_3/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Object 初始化过程(三)</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>




<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
	    <a class="jiathis_button_twitter"></a>
	    <a class="jiathis_button_plus"></a> 
	    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="object_init_4" data-title="Object 初始化过程(四)" data-url="http://yoursite.com/2016/09/19/object_init_4/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>





      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 Corner XX
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/"
	}
</script>

<script src="/./main.js"></script>





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/Hadoop-Eagle-Storm/" style="font-size: 10px;">Hadoop Eagle Storm</a> <a href="/tags/Hadoop-Hdfs/" style="font-size: 10px;">Hadoop Hdfs</a> <a href="/tags/Hadoop-Yran/" style="font-size: 10px;">Hadoop Yran</a> <a href="/tags/Hbase/" style="font-size: 16.67px;">Hbase</a> <a href="/tags/Hdfs/" style="font-size: 13.33px;">Hdfs</a> <a href="/tags/JVM/" style="font-size: 20px;">JVM</a> <a href="/tags/Kernel/" style="font-size: 13.33px;">Kernel</a> <a href="/tags/OpenJDK/" style="font-size: 13.33px;">OpenJDK</a> <a href="/tags/Phoenix/" style="font-size: 10px;">Phoenix</a> <a href="/tags/algorithm/" style="font-size: 16.67px;">algorithm</a> <a href="/tags/streamset/" style="font-size: 10px;">streamset</a>
    			</div>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">记录点点滴滴</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>