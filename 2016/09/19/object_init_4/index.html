<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Object 初始化过程(四) | Corner XX daily log</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Object类初始化前必须完成JVM规范中的加载，链接等。本节继续Object初始化过程(三)继续。">
<meta property="og:type" content="article">
<meta property="og:title" content="Object 初始化过程(四)">
<meta property="og:url" content="http://yoursite.com/2016/09/19/object_init_4/index.html">
<meta property="og:site_name" content="Corner XX daily log">
<meta property="og:description" content="Object类初始化前必须完成JVM规范中的加载，链接等。本节继续Object初始化过程(三)继续。">
<meta property="og:updated_time" content="2016-09-21T02:46:12.247Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Object 初始化过程(四)">
<meta name="twitter:description" content="Object类初始化前必须完成JVM规范中的加载，链接等。本节继续Object初始化过程(三)继续。">
  
    <link rel="alternative" href="/atom.xml" title="Corner XX daily log" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.png">
  
  <script src="/style.js"></script>
</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/img/suolong.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Corner XX</a></h1>
		</hgroup>

		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="#" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/cornerxx" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">Corner XX</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="/img/suolong.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Corner XX</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/cornerxx" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        <article id="post-object_init_4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Object 初始化过程(四)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Object类初始化前必须完成JVM规范中的加载，链接等。本节继续<strong>Object初始化过程(三)</strong>继续。<br><a id="more"></a></p>
<script src="/goodness/style.js"></script>

<h1 id="Object-初始化过程-四"><a href="#Object-初始化过程-四" class="headerlink" title="Object 初始化过程(四)"></a>Object 初始化过程(四)</h1><p>备注：文章中所有的平台都是在Linux上，Windows不做考虑。文中只是部分，后续慢慢更新。文中描述的只涉及相关的知识，不包含特定领域的内容。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Object类初始化前必须完成JVM规范中的加载，链接等。本节继续<strong>Object初始化过程(三)</strong>继续。</p>
<h2 id="执行过程分析"><a href="#执行过程分析" class="headerlink" title="执行过程分析"></a>执行过程分析</h2><p>在前面，我们已经建立运行Java方法的执行栈，下面就描述了加载jvm指令，到jvm指令的执行过程。<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">hotspot\src\cpu\x86\vm\interp_masm_x86_64.cpp:</div><div class="line"></div><div class="line"><span class="keyword">void</span> InterpreterMacroAssembler::dispatch_next(TosState state, <span class="keyword">int</span> step) &#123;</div><div class="line">  <span class="comment">// load next bytecode (load before advancing r13 to prevent AGI)</span></div><div class="line">  load_unsigned_byte(rbx, Address(r13, step));</div><div class="line">  <span class="comment">// advance r13</span></div><div class="line">  increment(r13, step);</div><div class="line">  dispatch_base(state, Interpreter::dispatch_table(state));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<strong>Object初始化过程(三)</strong>中我们知道<strong>r13</strong>寄存器保存了jvm代码段的内存地址。此方法通过访问<strong>r13</strong>寄存器的内容并且将其赋值给<strong>rbx</strong>,并且递增内存地址。<strong>rbx</strong>寄存器保存了jvm的指令。<br>那么TosState表示的是什么意思呢？<strong>MARK</strong><br>这里的TosState是<strong>vtos</strong>。<br>另外，看看此时各个重要寄存器的内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">RAX return adress</div><div class="line">RBX JVM bytecode 字节码</div><div class="line">RCX size of parameters</div><div class="line">RDX constant pool cache</div><div class="line">R13 bcp 指向方法加载字节码的起始地址</div><div class="line">R14 pointer to locals,指向参数的起始地址</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void InterpreterMacroAssembler::dispatch_base(TosState state,</div><div class="line">                                              address* table,</div><div class="line">                                              bool verifyoop) &#123;</div><div class="line">  verify_FPU(1, state);</div><div class="line">  if (VerifyActivationFrameSize) &#123;</div><div class="line">    Label L;</div><div class="line">    mov(rcx, rbp);</div><div class="line">    subptr(rcx, rsp);</div><div class="line">    int32_t min_frame_size =</div><div class="line">      (frame::link_offset - frame::interpreter_frame_initial_sp_offset) *</div><div class="line">      wordSize;</div><div class="line">    cmpptr(rcx, (int32_t)min_frame_size);</div><div class="line">    jcc(Assembler::greaterEqual, L);</div><div class="line">    stop(&quot;broken stack frame&quot;);</div><div class="line">    bind(L);</div><div class="line">  &#125;</div><div class="line">  if (verifyoop) &#123;</div><div class="line">    verify_oop(rax, state);</div><div class="line">  &#125;</div><div class="line">  lea(rscratch1, ExternalAddress((address)table));</div><div class="line">  jmp(Address(rscratch1, rbx, Address::times_8));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>计算table指向的地址，跳转到指定地址执行。那么table指向的是什么地址呢？既然，虚拟机的指令也已经知道，那么后面就是对此指令进行解释执行。所以，这个地址应该是和解释器相关的代码。<br><figure class="highlight"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\interpreter\templateInterpreter.hpp:</div><div class="line"></div><div class="line">  static address*   dispatch_table(TosState state)              &#123; return _active_table.table_for(state); &#125;</div><div class="line"></div><div class="line">  address*   table_for(TosState state)          &#123; return _table[state]; &#125;</div><div class="line"></div><div class="line">hotspot\src\share\vm\interpreter\templateInterpreter.cpp:</div><div class="line">void TemplateInterpreter::initialize() &#123;</div><div class="line">  if (_code != NULL) return;</div><div class="line">  // assertions</div><div class="line">  assert((int)Bytecodes::number_of_codes &lt;= (int)DispatchTable::length,</div><div class="line">         "dispatch table too small");</div><div class="line"></div><div class="line">  AbstractInterpreter::initialize();</div><div class="line"></div><div class="line">  TemplateTable::initialize();</div><div class="line"></div><div class="line">  // generate interpreter</div><div class="line">  &#123; ResourceMark rm;</div><div class="line">    TraceTime timer("Interpreter generation", TraceStartupTime);</div><div class="line">    int code_size = InterpreterCodeSize;</div><div class="line">    NOT_PRODUCT(code_size *= 4;)  // debug uses extra interpreter code space</div><div class="line">    _code = new StubQueue(new InterpreterCodeletInterface, code_size, NULL,</div><div class="line">                          "Interpreter");</div><div class="line">    InterpreterGenerator g(_code);</div><div class="line">    if (PrintInterpreter) print();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // initialize dispatch table</div><div class="line">  _active_table = _normal_table;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void TemplateInterpreterGenerator::set_unimplemented(int i) &#123;</div><div class="line">  address e = _unimplemented_bytecode;</div><div class="line">  EntryPoint entry(e, e, e, e, e, e, e, e, e);</div><div class="line">  Interpreter::_normal_table.set_entry(i, entry);</div><div class="line">  Interpreter::_wentry_point[i] = _unimplemented_bytecode;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void TemplateInterpreterGenerator::set_entry_points(Bytecodes::Code code) &#123;</div><div class="line">  CodeletMark cm(_masm, Bytecodes::name(code), code);</div><div class="line">  // initialize entry points</div><div class="line">  assert(_unimplemented_bytecode    != NULL, "should have been generated before");</div><div class="line">  assert(_illegal_bytecode_sequence != NULL, "should have been generated before");</div><div class="line">  address bep = _illegal_bytecode_sequence;</div><div class="line">  address cep = _illegal_bytecode_sequence;</div><div class="line">  address sep = _illegal_bytecode_sequence;</div><div class="line">  address aep = _illegal_bytecode_sequence;</div><div class="line">  address iep = _illegal_bytecode_sequence;</div><div class="line">  address lep = _illegal_bytecode_sequence;</div><div class="line">  address fep = _illegal_bytecode_sequence;</div><div class="line">  address dep = _illegal_bytecode_sequence;</div><div class="line">  address vep = _unimplemented_bytecode;</div><div class="line">  address wep = _unimplemented_bytecode;</div><div class="line">  // code for short &amp; wide version of bytecode</div><div class="line">  if (Bytecodes::is_defined(code)) &#123;</div><div class="line">    Template* t = TemplateTable::template_for(code);</div><div class="line">    assert(t-&gt;is_valid(), "just checking");</div><div class="line">    set_short_entry_points(t, bep, cep, sep, aep, iep, lep, fep, dep, vep);</div><div class="line">  &#125;</div><div class="line">  if (Bytecodes::wide_is_defined(code)) &#123;</div><div class="line">    Template* t = TemplateTable::template_for_wide(code);</div><div class="line">    assert(t-&gt;is_valid(), "just checking");</div><div class="line">    set_wide_entry_point(t, wep);</div><div class="line">  &#125;</div><div class="line">  // set entry points</div><div class="line">  EntryPoint entry(bep, cep, sep, aep, iep, lep, fep, dep, vep);</div><div class="line">  Interpreter::_normal_table.set_entry(code, entry);</div><div class="line">  Interpreter::_wentry_point[code] = wep;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void TemplateInterpreterGenerator::set_entry_points_for_all_bytes() &#123;</div><div class="line">  for (int i = 0; i &lt; DispatchTable::length; i++) &#123;</div><div class="line">    Bytecodes::Code code = (Bytecodes::Code)i;</div><div class="line">    if (Bytecodes::is_defined(code)) &#123;</div><div class="line">      set_entry_points(code);</div><div class="line">    &#125; else &#123;</div><div class="line">      set_unimplemented(i);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void TemplateInterpreterGenerator::generate_all() &#123;</div><div class="line">  ...</div><div class="line"></div><div class="line">  // Bytecodes</div><div class="line">  set_entry_points_for_all_bytes();</div><div class="line">  set_safepoints_for_all_bytes();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于这段代码的解释，请参考<a href="/2016/09/19/jvm-interpreter-3/">JVM解释器初始化过程(三) </a>。<br>所以<strong>table</strong>指向的是<strong>TemplateInterpreter::_normal_table[vtos]</strong>第一个元素。<br><strong>dispatch_base()</strong>主要工作就是根据解释器跳转表中获取解释器的内存地址，并且到这个地址执行指令。重点的代码如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">lea(rscratch1, ExternalAddress((address)table));</div><div class="line">jmp(Address(rscratch1, rbx, Address::times_8));</div></pre></td></tr></table></figure></p>
<p>第一条指令就是获取<strong>TemplateInterpreter::_normal_table[vtos]</strong>第一个元素的内存地址，第二个就是获取存在rbx的指令编号计算出解释器存放的内存地址，这个内存地址就是这个解释器的内存指令地址。<br>先来看一下Object中<strong>\<clinit\></clinit\></strong>的code属性内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">0 invokestatic #17 &lt;java/lang/Object.registerNatives&gt;</div><div class="line">3 return</div></pre></td></tr></table></figure></p>
<p><strong>invokestatic</strong>指令的字节码编号为184(参考<a href="/2016/09/19/jvm-interpreter-1/">JVM解释器初始化过程(一)</a>)。也就是从<strong>TemplateInterpreter::_normal_table[vtos]</strong>表中的第184个元素获取内存地址，从<a href="/2016/09/19/jvm-interpreter-3/">JVM解释器初始化过程(三) </a>我们可以知道，这个地址就是指令<strong>invokestatic</strong>的解释器地址，根据其定义，其入参为<strong>vtos</strong>，栈中的内容：<br>address&amp; vep：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">  [push   %rax           ] &lt;--- aep </div><div class="line">  [jmpq   L              ]  </div><div class="line">  [sub    $0x8,%rsp      ] &lt;--- fep </div><div class="line">  [movss  %xmm0,(%rsp)   ]   </div><div class="line">  [jmpq   L              ] </div><div class="line">  [sub    $0x10,%rsp     ] &lt;--- dep</div><div class="line">  [movsd  %xmm0,(%rsp)   ] </div><div class="line">  [jmpq   L              ] </div><div class="line">  [sub    $0x10,%rsp     ] &lt;--- lep</div><div class="line">  [mov    %rax,(%rsp)    ] </div><div class="line">  [jmpq   L              ] </div><div class="line">  [push   %rax           ] &lt;--- iep</div><div class="line">L:[                      ] &lt;--- vep</div></pre></td></tr></table></figure></p>
<p>也就是说，执行的时候不做任何操作，执行执行指令。我们来看看指定的定义：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\interpreter\templateTable.cpp:</div><div class="line"></div><div class="line">  def(Bytecodes::<span class="number">_</span>invokestatic        , ubcp|disp|clvm|<span class="number">____</span>, vtos, vtos, invokestatic        , f1_byte      );</div></pre></td></tr></table></figure></p>
<p>解释生成器：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\cpu\x86\vm\templateTable_x86_64.cpp:</div><div class="line"></div><div class="line"><span class="keyword">void</span> TemplateTable::invokestatic(<span class="keyword">int</span> byte_no) &#123;</div><div class="line">  transition(vtos, vtos);</div><div class="line">  assert(byte_no == f1_byte, <span class="string">"use this argument"</span>);</div><div class="line">  prepare_invoke(byte_no, rbx);  <span class="comment">// get f1 methodOop</span></div><div class="line">  <span class="comment">// do the call</span></div><div class="line">  <span class="number">__</span> verify_oop(rbx);</div><div class="line">  <span class="number">__</span> profile_call(rax);</div><div class="line">  <span class="number">__</span> jump_from_interpreted(rbx, rax);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看看<strong>prepare_invoke</strong>的定义：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">void</span> TemplateTable::prepare_invoke(<span class="keyword">int</span> byte_no,</div><div class="line">                                   Register method,  <span class="comment">// linked method (or i-klass)</span></div><div class="line">                                   Register index,   <span class="comment">// itable index, MethodType, etc.</span></div><div class="line">                                   Register recv,    <span class="comment">// if caller wants to see it</span></div><div class="line">                                   Register flags    <span class="comment">// if caller wants to test it</span></div><div class="line">                                   ) &#123;</div><div class="line">  <span class="comment">// determine flags</span></div><div class="line">  <span class="keyword">const</span> Bytecodes::Code code = bytecode();</div><div class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> is_invokeinterface  = code == Bytecodes::<span class="number">_</span>invokeinterface;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> is_invokedynamic    = code == Bytecodes::<span class="number">_</span>invokedynamic;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> is_invokehandle     = code == Bytecodes::<span class="number">_</span>invokehandle;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> is_invokevirtual    = code == Bytecodes::<span class="number">_</span>invokevirtual;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> is_invokespecial    = code == Bytecodes::<span class="number">_</span>invokespecial;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> load_receiver       = (recv  != noreg);</div><div class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> save_flags          = (flags != noreg);</div><div class="line">  assert(load_receiver == (code != Bytecodes::<span class="number">_</span>invokestatic &amp;&amp; code != Bytecodes::<span class="number">_</span>invokedynamic), <span class="string">""</span>);</div><div class="line">  assert(save_flags    == (is_invokeinterface || is_invokevirtual), <span class="string">"need flags for vfinal"</span>);</div><div class="line">  assert(flags == noreg || flags == rdx, <span class="string">""</span>);</div><div class="line">  assert(recv  == noreg || recv  == rcx, <span class="string">""</span>);</div><div class="line"></div><div class="line">  <span class="comment">// setup registers &amp; access constant pool cache</span></div><div class="line">  <span class="keyword">if</span> (recv  == noreg)  recv  = rcx;</div><div class="line">  <span class="keyword">if</span> (flags == noreg)  flags = rdx;</div><div class="line">  assert_different_registers(method, index, recv, flags);</div><div class="line"></div><div class="line">  <span class="comment">// save 'interpreter return address'</span></div><div class="line">  <span class="number">__</span> save_bcp();</div><div class="line"></div><div class="line">  load_invoke_cp_cache_entry(byte_no, method, index, flags, is_invokevirtual, <span class="literal">false</span>, is_invokedynamic);</div><div class="line"></div><div class="line">  <span class="comment">// maybe push appendix to arguments (just before return address)</span></div><div class="line">  <span class="keyword">if</span> (is_invokedynamic || is_invokehandle) &#123;</div><div class="line">    Label L_no_push;</div><div class="line">    <span class="number">__</span> verify_oop(index);</div><div class="line">    <span class="number">__</span> testl(flags, (<span class="number">1</span> &lt;&lt; ConstantPoolCacheEntry::has_appendix_shift));</div><div class="line">    <span class="number">__</span> jccb(Assembler::zero, L_no_push);</div><div class="line">    <span class="comment">// Push the appendix as a trailing parameter.</span></div><div class="line">    <span class="comment">// This must be done before we get the receiver,</span></div><div class="line">    <span class="comment">// since the parameter_size includes it.</span></div><div class="line">    <span class="number">__</span> push(index);  <span class="comment">// push appendix (MethodType, CallSite, etc.)</span></div><div class="line">    <span class="number">__</span> bind(L_no_push);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// load receiver if needed (after appendix is pushed so parameter size is correct)</span></div><div class="line">  <span class="comment">// Note: no return address pushed yet</span></div><div class="line">  <span class="keyword">if</span> (load_receiver) &#123;</div><div class="line">    <span class="number">__</span> movl(recv, flags);</div><div class="line">    <span class="number">__</span> andl(recv, ConstantPoolCacheEntry::parameter_size_mask);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> no_return_pc_pushed_yet = <span class="number">-1</span>;  <span class="comment">// argument slot correction before we push return address</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> receiver_is_at_end      = <span class="number">-1</span>;  <span class="comment">// back off one slot to get receiver</span></div><div class="line">    Address recv_addr = <span class="number">__</span> argument_address(recv, no_return_pc_pushed_yet + receiver_is_at_end);</div><div class="line">    <span class="number">__</span> movptr(recv, recv_addr);</div><div class="line">    <span class="number">__</span> verify_oop(recv);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (save_flags) &#123;</div><div class="line">    <span class="number">__</span> movl(r13, flags);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// compute return type</span></div><div class="line">  <span class="number">__</span> shrl(flags, ConstantPoolCacheEntry::tos_state_shift);</div><div class="line">  <span class="comment">// Make sure we don't need to mask flags after the above shift</span></div><div class="line">  ConstantPoolCacheEntry::verify_tos_state_shift();</div><div class="line">  <span class="comment">// load return address</span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">const</span> address table_addr = (is_invokeinterface || is_invokedynamic) ?</div><div class="line">        (address)Interpreter::return_5_addrs_by_index_table() :</div><div class="line">        (address)Interpreter::return_3_addrs_by_index_table();</div><div class="line">    <span class="function">ExternalAddress <span class="title">table</span><span class="params">(table_addr)</span></span>;</div><div class="line">    <span class="number">__</span> lea(rscratch1, table);</div><div class="line">    <span class="number">__</span> movptr(flags, Address(rscratch1, flags, Address::times_ptr));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// push return address</span></div><div class="line">  <span class="number">__</span> push(flags);</div><div class="line"></div><div class="line">  <span class="comment">// Restore flags value from the constant pool cache, and restore rsi</span></div><div class="line">  <span class="comment">// for later null checks.  r13 is the bytecode pointer</span></div><div class="line">  <span class="keyword">if</span> (save_flags) &#123;</div><div class="line">    <span class="number">__</span> movl(flags, r13);</div><div class="line">    <span class="number">__</span> restore_bcp();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>更细致的，<strong>__ save_bcp()</strong>,从注释中，我们可以看到，这个计算的是解释器返回的地址，即栈中return_from_Java(参考<a href="2016/09/19/object_init_2/">Object 初始化过程(二)</a>的栈内容):<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Interpreter-specific registers</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_bcp</span><span class="params">()</span> </span>&#123;</div><div class="line">  movptr(Address(rbp, frame::interpreter_frame_bcx_offset * wordSize), r13);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\cpu\x86\vm\templateTable_x86_64.cpp:</div><div class="line"></div><div class="line"><span class="keyword">void</span> TemplateTable::load_invoke_cp_cache_entry(<span class="keyword">int</span> byte_no,</div><div class="line">                                               Register method,</div><div class="line">                                               Register itable_index,</div><div class="line">                                               Register flags,</div><div class="line">                                               <span class="keyword">bool</span> is_invokevirtual,</div><div class="line">                                               <span class="keyword">bool</span> is_invokevfinal, <span class="comment">/*unused*/</span></div><div class="line">                                               <span class="keyword">bool</span> is_invokedynamic) &#123;</div><div class="line">  <span class="comment">// setup registers</span></div><div class="line">  <span class="keyword">const</span> Register cache = rcx;</div><div class="line">  <span class="keyword">const</span> Register index = rdx;</div><div class="line">  assert_different_registers(method, flags);</div><div class="line">  assert_different_registers(method, cache, index);</div><div class="line">  assert_different_registers(itable_index, flags);</div><div class="line">  assert_different_registers(itable_index, cache, index);</div><div class="line">  <span class="comment">// determine constant pool cache field offsets</span></div><div class="line">  assert(is_invokevirtual == (byte_no == f2_byte), <span class="string">"is_invokevirtual flag redundant"</span>);</div><div class="line">  <span class="keyword">const</span> <span class="keyword">int</span> method_offset = in_bytes(</div><div class="line">    constantPoolCacheOopDesc::base_offset() +</div><div class="line">      ((byte_no == f2_byte)</div><div class="line">       ? ConstantPoolCacheEntry::f2_offset()</div><div class="line">       : ConstantPoolCacheEntry::f1_offset()));</div><div class="line">  <span class="keyword">const</span> <span class="keyword">int</span> flags_offset = in_bytes(constantPoolCacheOopDesc::base_offset() +</div><div class="line">                                    ConstantPoolCacheEntry::flags_offset());</div><div class="line">  <span class="comment">// access constant pool cache fields</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">int</span> index_offset = in_bytes(constantPoolCacheOopDesc::base_offset() +</div><div class="line">                                    ConstantPoolCacheEntry::f2_offset());</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (byte_no == f12_oop) &#123;</div><div class="line">    <span class="comment">// Resolved f1_oop (CallSite, MethodType, etc.) goes into 'itable_index'.</span></div><div class="line">    <span class="comment">// Resolved f2_oop (methodOop invoker) will go into 'method' (at index_offset).</span></div><div class="line">    <span class="comment">// See ConstantPoolCacheEntry::set_dynamic_call and set_method_handle.</span></div><div class="line">    <span class="keyword">size_t</span> index_size = (is_invokedynamic ? <span class="keyword">sizeof</span>(u4) : <span class="keyword">sizeof</span>(u2));</div><div class="line">    resolve_cache_and_index(byte_no, itable_index, cache, index, index_size);</div><div class="line">    <span class="number">__</span> movptr(method, Address(cache, index, Address::times_ptr, index_offset));</div><div class="line">    itable_index = noreg;  <span class="comment">// hack to disable load below</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    resolve_cache_and_index(byte_no, noreg, cache, index, <span class="keyword">sizeof</span>(u2));</div><div class="line">    <span class="number">__</span> movptr(method, Address(cache, index, Address::times_ptr, method_offset));</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (itable_index != noreg) &#123;</div><div class="line">    <span class="comment">// pick up itable index from f2 also:</span></div><div class="line">    assert(byte_no == f1_byte, <span class="string">"already picked up f1"</span>);</div><div class="line">    <span class="number">__</span> movptr(itable_index, Address(cache, index, Address::times_ptr, index_offset));</div><div class="line">  &#125;</div><div class="line">  <span class="number">__</span> movl(flags, Address(cache, index, Address::times_ptr, flags_offset));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>invokestatic</strong>指令的长度为f1_byte，也就是说byte_no为f1_byte，所以调用<strong>resolve_cache_and_index</strong>：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\cpu\x86\vm\templateTable_x86_64.cpp:</div><div class="line"></div><div class="line"><span class="keyword">void</span> TemplateTable::resolve_cache_and_index(<span class="keyword">int</span> byte_no,</div><div class="line">                                            Register result,</div><div class="line">                                            Register Rcache,</div><div class="line">                                            Register index,</div><div class="line">                                            <span class="keyword">size_t</span> index_size) &#123;</div><div class="line">  <span class="keyword">const</span> Register temp = rbx;</div><div class="line">  assert_different_registers(result, Rcache, index, temp);</div><div class="line"></div><div class="line">  Label resolved;</div><div class="line">  <span class="keyword">if</span> (byte_no == f12_oop) &#123;</div><div class="line">    <span class="comment">// We are resolved if the f1 field contains a non-null object (CallSite, MethodType, etc.)</span></div><div class="line">    <span class="comment">// This kind of CP cache entry does not need to match bytecode_1 or bytecode_2, because</span></div><div class="line">    <span class="comment">// there is a 1-1 relation between bytecode type and CP entry type.</span></div><div class="line">    <span class="comment">// The caller will also load a methodOop from f2.</span></div><div class="line">    assert(result != noreg, <span class="string">""</span>); <span class="comment">//else do cmpptr(Address(...), (int32_t) NULL_WORD)</span></div><div class="line">    <span class="number">__</span> get_cache_and_index_at_bcp(Rcache, index, <span class="number">1</span>, index_size);</div><div class="line">    <span class="number">__</span> movptr(result, Address(Rcache, index, Address::times_ptr, constantPoolCacheOopDesc::base_offset() + ConstantPoolCacheEntry::f1_offset()));</div><div class="line">    <span class="number">__</span> testptr(result, result);</div><div class="line">    <span class="number">__</span> jcc(Assembler::notEqual, resolved);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    assert(byte_no == f1_byte || byte_no == f2_byte, <span class="string">"byte_no out of range"</span>);</div><div class="line">    assert(result == noreg, <span class="string">""</span>);  <span class="comment">//else change code for setting result</span></div><div class="line">    <span class="number">__</span> get_cache_and_index_and_bytecode_at_bcp(Rcache, index, temp, byte_no, <span class="number">1</span>, index_size);</div><div class="line">    <span class="number">__</span> cmpl(temp, (<span class="keyword">int</span>) bytecode());  <span class="comment">// have we resolved this bytecode?</span></div><div class="line">    <span class="number">__</span> jcc(Assembler::equal, resolved);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// resolve first time through</span></div><div class="line">  address entry;</div><div class="line">  <span class="keyword">switch</span> (bytecode()) &#123;</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>getstatic:</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>putstatic:</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>getfield:</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>putfield:</div><div class="line">    entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_get_put);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>invokevirtual:</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>invokespecial:</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>invokestatic:</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>invokeinterface:</div><div class="line">    entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_invoke);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>invokehandle:</div><div class="line">    entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_invokehandle);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_</span>invokedynamic:</div><div class="line">    entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_invokedynamic);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_f</span>ast_aldc:</div><div class="line">    entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> Bytecodes::<span class="number">_f</span>ast_aldc_w:</div><div class="line">    entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">default</span>:</div><div class="line">    fatal(err_msg(<span class="string">"unexpected bytecode: %s"</span>, Bytecodes::name(bytecode())));</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="number">__</span> movl(temp, (<span class="keyword">int</span>) bytecode());</div><div class="line">  <span class="number">__</span> call_VM(noreg, entry, temp);</div><div class="line"></div><div class="line">  <span class="comment">// Update registers with resolved info</span></div><div class="line">  <span class="number">__</span> get_cache_and_index_at_bcp(Rcache, index, <span class="number">1</span>, index_size);</div><div class="line">  <span class="keyword">if</span> (result != noreg)</div><div class="line">    <span class="number">__</span> movptr(result, Address(Rcache, index, Address::times_ptr, constantPoolCacheOopDesc::base_offset() + ConstantPoolCacheEntry::f1_offset()));</div><div class="line">  <span class="number">__</span> bind(resolved);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>后续调用<strong>get_cache_and_index_and_bytecode_at_bcp</strong>:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\cpu\x86\vm\interp_masm_x86_64.cpp:</div><div class="line"></div><div class="line"><span class="keyword">void</span> InterpreterMacroAssembler::get_cache_and_index_and_bytecode_at_bcp(Register cache,</div><div class="line">                                                                        Register index,</div><div class="line">                                                                        Register bytecode,</div><div class="line">                                                                        <span class="keyword">int</span> byte_no,</div><div class="line">                                                                        <span class="keyword">int</span> bcp_offset,</div><div class="line">                                                                        <span class="keyword">size_t</span> index_size) &#123;</div><div class="line">  get_cache_and_index_at_bcp(cache, index, bcp_offset, index_size);</div><div class="line">  <span class="comment">// We use a 32-bit load here since the layout of 64-bit words on</span></div><div class="line">  <span class="comment">// little-endian machines allow us that.</span></div><div class="line">  movl(bytecode, Address(cache, index, Address::times_ptr, constantPoolCacheOopDesc::base_offset() + ConstantPoolCacheEntry::indices_offset()));</div><div class="line">  <span class="keyword">const</span> <span class="keyword">int</span> shift_count = (<span class="number">1</span> + byte_no) * BitsPerByte;</div><div class="line">  assert((byte_no == TemplateTable::f1_byte &amp;&amp; shift_count == ConstantPoolCacheEntry::bytecode_1_shift) ||</div><div class="line">         (byte_no == TemplateTable::f2_byte &amp;&amp; shift_count == ConstantPoolCacheEntry::bytecode_2_shift),</div><div class="line">         <span class="string">"correct shift count"</span>);</div><div class="line">  shrl(bytecode, shift_count);</div><div class="line">  assert(ConstantPoolCacheEntry::bytecode_1_mask == ConstantPoolCacheEntry::bytecode_2_mask, <span class="string">"common mask"</span>);</div><div class="line">  andl(bytecode, ConstantPoolCacheEntry::bytecode_1_mask);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> InterpreterMacroAssembler::get_cache_and_index_at_bcp(Register cache,</div><div class="line">                                                           Register index,</div><div class="line">                                                           <span class="keyword">int</span> bcp_offset,</div><div class="line">                                                           <span class="keyword">size_t</span> index_size) &#123;</div><div class="line">  assert_different_registers(cache, index);</div><div class="line">  get_cache_index_at_bcp(index, bcp_offset, index_size);</div><div class="line">  movptr(cache, Address(rbp, frame::interpreter_frame_cache_offset * wordSize));</div><div class="line">  assert(<span class="keyword">sizeof</span>(ConstantPoolCacheEntry) == <span class="number">4</span> * wordSize, <span class="string">"adjust code below"</span>);</div><div class="line">  <span class="comment">// convert from field index to ConstantPoolCacheEntry index</span></div><div class="line">  shll(index, <span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> InterpreterMacroAssembler::get_cache_index_at_bcp(Register index,</div><div class="line">                                                       <span class="keyword">int</span> bcp_offset,</div><div class="line">                                                       <span class="keyword">size_t</span> index_size) &#123;</div><div class="line">  assert(bcp_offset &gt; <span class="number">0</span>, <span class="string">"bcp is still pointing to start of bytecode"</span>);</div><div class="line">  <span class="keyword">if</span> (index_size == <span class="keyword">sizeof</span>(u2)) &#123;</div><div class="line">    load_unsigned_short(index, Address(r13, bcp_offset));</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index_size == <span class="keyword">sizeof</span>(u4)) &#123;</div><div class="line">    assert(EnableInvokeDynamic, <span class="string">"giant index used only for JSR 292"</span>);</div><div class="line">    movl(index, Address(r13, bcp_offset));</div><div class="line">    <span class="comment">// Check if the secondary index definition is still ~x, otherwise</span></div><div class="line">    <span class="comment">// we have to change the following assembler code to calculate the</span></div><div class="line">    <span class="comment">// plain index.</span></div><div class="line">    assert(constantPoolCacheOopDesc::decode_secondary_index(~<span class="number">123</span>) == <span class="number">123</span>, <span class="string">"else change next line"</span>);</div><div class="line">    notl(index);  <span class="comment">// convert to plain index</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index_size == <span class="keyword">sizeof</span>(u1)) &#123;</div><div class="line">    assert(EnableInvokeDynamic, <span class="string">"tiny index used only for JSR 292"</span>);</div><div class="line">    load_unsigned_byte(index, Address(r13, bcp_offset));</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    ShouldNotReachHere();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于<strong>invokestatic</strong>指令的参数长度为u2,index_size为sizeof(u2),bcp_offset为1，所以<strong>get_cache_index_at_bcp</strong>的作用就是从字节码的开始的地址加载2个无符号字节放入到index,而index即寄存器<strong>rdx</strong>。我们返回来看<strong>get_cache_and_index_at_bcp</strong>，通过方法栈获取methodOop的指针地址，并且左移2位，获取ConstantPoolCacheEntry的索引值，此时：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">RDX    invokestatic指令的参数，ConstantPoolCacheEntry的索引值</div><div class="line">RCX    此方法对应的methodOop结构</div></pre></td></tr></table></figure></p>
<p><strong>get_cache_and_index_and_bytecode_at_bcp</strong>方法计算出了rdx，rcx后，看不出来了，晕！，先回去看类加载吧，看看几个重要的数据结构！</p>
<p><strong>MARK</strong></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/09/19/object_init_4/" class="archive-article-date">
  	<time datetime="2016-09-19T12:43:37.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-09-19</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/JVM/">JVM</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
    <a href="/2016/09/20/linux-kernel-main/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="icon-circle-left"></i>
      <div class="article-nav-title">
        
          linux_kernel_main
        
      </div>
    </a>
  
  
    <a href="/2016/09/19/object_init_3/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Object 初始化过程(三)</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>




<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
	    <a class="jiathis_button_twitter"></a>
	    <a class="jiathis_button_plus"></a> 
	    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="object_init_4" data-title="Object 初始化过程(四)" data-url="http://yoursite.com/2016/09/19/object_init_4/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>





      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Corner XX
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/"
	}
</script>

<script src="/./main.js"></script>





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Hadoop-Hdfs/" style="font-size: 10px;">Hadoop Hdfs</a> <a href="/tags/Hadoop-Yran/" style="font-size: 10px;">Hadoop Yran</a> <a href="/tags/Hbase/" style="font-size: 16.67px;">Hbase</a> <a href="/tags/JVM/" style="font-size: 20px;">JVM</a> <a href="/tags/Kernel/" style="font-size: 13.33px;">Kernel</a> <a href="/tags/Phoenix/" style="font-size: 10px;">Phoenix</a>
    			</div>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">记录点点滴滴</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>