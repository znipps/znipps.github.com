<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>JVM 基础设施之内存分配 | Corner XX daily log</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="这篇文章介绍JVM中的内存分配，包括ResourceObj,CHeapObj,StackObj,ValueObj以及AllStatic。这些表明不同的角色，分别用在不同的场景。虚拟机提供了方便以及明确的内存分配定义。JVM还提供了很多工具，简化了内存分配的复杂性，提供模块化的内存分配功能。">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM 基础设施之内存分配">
<meta property="og:url" content="http://yoursite.com/2016/09/21/jvm-memory-allocate/index.html">
<meta property="og:site_name" content="Corner XX daily log">
<meta property="og:description" content="这篇文章介绍JVM中的内存分配，包括ResourceObj,CHeapObj,StackObj,ValueObj以及AllStatic。这些表明不同的角色，分别用在不同的场景。虚拟机提供了方便以及明确的内存分配定义。JVM还提供了很多工具，简化了内存分配的复杂性，提供模块化的内存分配功能。">
<meta property="og:updated_time" content="2016-09-21T08:08:34.435Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JVM 基础设施之内存分配">
<meta name="twitter:description" content="这篇文章介绍JVM中的内存分配，包括ResourceObj,CHeapObj,StackObj,ValueObj以及AllStatic。这些表明不同的角色，分别用在不同的场景。虚拟机提供了方便以及明确的内存分配定义。JVM还提供了很多工具，简化了内存分配的复杂性，提供模块化的内存分配功能。">
  
    <link rel="alternative" href="/atom.xml" title="Corner XX daily log" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.png">
  
  <script src="/style.js"></script>
</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/img/suolong.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Corner XX</a></h1>
		</hgroup>

		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="#" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">Corner XX</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="/img/suolong.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Corner XX</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        <article id="post-jvm-memory-allocate" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JVM 基础设施之内存分配
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这篇文章介绍JVM中的内存分配，包括ResourceObj,CHeapObj,StackObj,ValueObj以及AllStatic。这些表明不同的角色，分别用在不同的场景。虚拟机提供了方便以及明确的内存分配定义。JVM还提供了很多工具，简化了内存分配的复杂性，提供模块化的内存分配功能。<br><a id="more"></a></p>
<h1 id="JVM-基础设施之内存分配"><a href="#JVM-基础设施之内存分配" class="headerlink" title="JVM 基础设施之内存分配"></a>JVM 基础设施之内存分配</h1><p>这个系列文章介绍JVM提供的基础设置，提供了各类帮助工具。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这篇文章介绍JVM中的内存分配，包括ResourceObj,CHeapObj,StackObj,ValueObj以及AllStatic。这些表明不同的角色，分别用在不同的场景。虚拟机提供了方便以及明确的内存分配定义。JVM还提供了很多工具，简化了内存分配的复杂性，提供模块化的内存分配功能。</p>
<h2 id="主要数据结构"><a href="#主要数据结构" class="headerlink" title="主要数据结构"></a>主要数据结构</h2><p>CHeapObj表明使用<strong>free &amp; malloc</strong>来管理内存的分配，虚拟机中分配各种数据和管理对象基本都是在此分配的。可以调用new和delete操作。此类是此类对象的积累。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">\hotspot\src\share\vm\memory\allocation.hpp:</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;MEMFLAGS F&gt; <span class="keyword">class</span> CHeapObj ALLOCATION_SUPER_CLASS_SPEC &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="number">_</span><span class="function">NOINLINE_ <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, address caller_pc = <span class="number">0</span>)</span></span>;</div><div class="line">  <span class="number">_</span><span class="function">NOINLINE_ <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>&amp;  nothrow_constant,</span></span></div><div class="line">                               address caller_pc = <span class="number">0</span>);</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span>  <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p)</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>StackObj表明在栈中分配空间，任何此类对象调用new和delete都会报错，这个类是所有栈上分配空间类的基类。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\memory\allocation.hpp:</div><div class="line"></div><div class="line"><span class="comment">// Base class for objects allocated on the stack only.</span></div><div class="line"><span class="comment">// Calling new or delete will result in fatal error.</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> StackObj ALLOCATION_SUPER_CLASS_SPEC &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span>  <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p)</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>继承此类使用VALUE_OBJ_CLASS_SPEC代替，在gcc表示为空：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\memory\allocation.hpp:</div><div class="line"></div><div class="line"><span class="comment">// Base class for objects used as value objects.</span></div><div class="line"><span class="comment">// Calling new or delete will result in fatal error.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Portability note: Certain compilers (e.g. gcc) will</span></div><div class="line"><span class="comment">// always make classes bigger if it has a superclass, even</span></div><div class="line"><span class="comment">// if the superclass does not have any virtual methods or</span></div><div class="line"><span class="comment">// instance fields. The HotSpot implementation relies on this</span></div><div class="line"><span class="comment">// not to happen. So never make a ValueObj class a direct subclass</span></div><div class="line"><span class="comment">// of this object, but use the VALUE_OBJ_CLASS_SPEC class instead, e.g.,</span></div><div class="line"><span class="comment">// like this:</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//   class A VALUE_OBJ_CLASS_SPEC &#123;</span></div><div class="line"><span class="comment">//     ...</span></div><div class="line"><span class="comment">//   &#125;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// With gcc and possible other compilers the VALUE_OBJ_CLASS_SPEC can</span></div><div class="line"><span class="comment">// be defined as a an empty string "".</span></div><div class="line"><span class="comment">//</span></div><div class="line">hotspot\src\share\vm\memory\allocation.hpp:</div><div class="line"></div><div class="line"><span class="keyword">class</span> <span class="number">_</span>ValueObj &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p)</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>任何调用此类的方法都会报错：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\memory\allocation.hpp:</div><div class="line"><span class="comment">// Base class for classes that constitute name spaces.</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> AllStatic &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  AllStatic()  &#123; ShouldNotCallThis(); &#125;</div><div class="line">  ~AllStatic() &#123; ShouldNotCallThis(); &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>JVM为每个线程分配一个<strong>资源区</strong>的概念，有些对象是在这种内存中分配，而这种对象代表的结构如下，这是这种对象的基类：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\memory\allocation.hpp:</div><div class="line"></div><div class="line"><span class="comment">//----------------------------------------------------------------------</span></div><div class="line"><span class="comment">// Base class for objects allocated in the resource area per default.</span></div><div class="line"><span class="comment">// Optionally, objects may be allocated on the C heap with</span></div><div class="line"><span class="comment">// new(ResourceObj::C_HEAP) Foo(...) or in an Arena with new (&amp;arena)</span></div><div class="line"><span class="comment">// ResourceObj's can be allocated within other objects, but don't use</span></div><div class="line"><span class="comment">// new or delete (allocation_type is unknown).  If new is used to allocate,</span></div><div class="line"><span class="comment">// use delete to deallocate.</span></div><div class="line"><span class="keyword">class</span> ResourceObj ALLOCATION_SUPER_CLASS_SPEC &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">enum</span> allocation_type &#123; STACK_OR_EMBEDDED = <span class="number">0</span>, RESOURCE_AREA, C_HEAP, ARENA, allocation_mask = <span class="number">0x3</span> &#125;;</div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_allocation_type</span><span class="params">(address res, allocation_type type)</span> NOT_DEBUG_RETURN</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="comment">// When this object is allocated on stack the new() operator is not</span></div><div class="line">  <span class="comment">// called but garbage on stack may look like a valid allocation_type.</span></div><div class="line">  <span class="comment">// Store negated 'this' pointer when new() is called to distinguish cases.</span></div><div class="line">  <span class="comment">// Use second array's element for verification value to distinguish garbage.</span></div><div class="line">  <span class="keyword">uintptr_t</span> <span class="keyword">_allocation_t</span>[<span class="number">2</span>];</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">is_type_set</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="function">allocation_type <span class="title">get_allocation_type</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">allocated_on_stack</span><span class="params">()</span>    <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> get_allocation_type() == STACK_OR_EMBEDDED; &#125;</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">allocated_on_res_area</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> get_allocation_type() == RESOURCE_AREA; &#125;</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">allocated_on_C_heap</span><span class="params">()</span>   <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> get_allocation_type() == C_HEAP; &#125;</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">allocated_on_arena</span><span class="params">()</span>    <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> get_allocation_type() == ARENA; &#125;</div><div class="line">  ResourceObj(); <span class="comment">// default construtor</span></div><div class="line">  ResourceObj(<span class="keyword">const</span> ResourceObj&amp; r); <span class="comment">// default copy construtor</span></div><div class="line">  ResourceObj&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ResourceObj&amp; r); <span class="comment">// default copy assignment</span></div><div class="line">  ~ResourceObj();</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ASSERT</span></span></div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, allocation_type type, MEMFLAGS flags)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, Arena *arena)</span> </span>&#123;</div><div class="line">      address res = (address)arena-&gt;Amalloc(size);</div><div class="line">      DEBUG_ONLY(set_allocation_type(res, ARENA);)</div><div class="line">      <span class="keyword">return</span> res;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">      address res = (address)resource_allocate_bytes(size);</div><div class="line">      DEBUG_ONLY(set_allocation_type(res, RESOURCE_AREA);)</div><div class="line">      <span class="keyword">return</span> res;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>&amp; nothrow_constant)</span> </span>&#123;</div><div class="line">    address res = (address)resource_allocate_bytes(size, AllocFailStrategy::RETURN_NULL);</div><div class="line">    DEBUG_ONLY(<span class="keyword">if</span> (res != <span class="literal">NULL</span>) set_allocation_type(res, RESOURCE_AREA);)</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span>  <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p)</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>可以看出比较重要的是ResouceObj，CHeapObj，StackObj，下面分别对这些进行详细的说明。</p>
<h2 id="CHeapObj"><a href="#CHeapObj" class="headerlink" title="CHeapObj"></a>CHeapObj</h2><p>重新贴出来：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\memory\allocation.hpp:</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;MEMFLAGS F&gt; <span class="keyword">class</span> CHeapObj ALLOCATION_SUPER_CLASS_SPEC &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="number">_</span><span class="function">NOINLINE_ <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, address caller_pc = <span class="number">0</span>)</span></span>;</div><div class="line">  <span class="number">_</span><span class="function">NOINLINE_ <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>&amp;  nothrow_constant,</span></span></div><div class="line">                               address caller_pc = <span class="number">0</span>);</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span>  <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p)</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">hotspot\src\share\vm\adlc\arena.cpp:</div><div class="line"></div><div class="line"><span class="keyword">void</span>* CHeapObj::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) <span class="built_in">malloc</span>(size);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> CHeapObj::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p)</span></span>&#123;</div><div class="line"> <span class="built_in">free</span>(p);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ALLOCATION_SUPER_CLASS_SPEC这个预定义是为调试准备的：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PRODUCT</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ALLOCATION_SUPER_CLASS_SPEC</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ALLOCATION_SUPER_CLASS_SPEC : public AllocatedObj</span></div><div class="line"><span class="keyword">class</span> AllocatedObj &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="comment">// Printing support</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print_value</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print_on</span><span class="params">(outputStream* st)</span> <span class="keyword">const</span></span>;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print_value_on</span><span class="params">(outputStream* st)</span> <span class="keyword">const</span></span>;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<p>可以看出此类调用直接使用操作系统的系统函数<strong>malloc，delete</strong>。也就是直接在程序中的堆结构中分配内存。看看程序的结构,程序栈空间在顶部，数据区域在低部，栈向低地址伸展，数据区域向高地址伸展：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> ----------</div><div class="line">|          |   </div><div class="line">|  stack   |  |</div><div class="line">|          |  |   高</div><div class="line">|          | \ /</div><div class="line"> ----------</div><div class="line">|          |</div><div class="line">|          |</div><div class="line">|   hole   |</div><div class="line">|          |</div><div class="line">|          |</div><div class="line">|          |</div><div class="line"> ----------  / \</div><div class="line">|    bss   |  |   低</div><div class="line">|          |  |</div><div class="line"> ----------</div><div class="line">|   data   |</div><div class="line">|          |</div><div class="line"> ----------</div></pre></td></tr></table></figure></p>
<h2 id="StackObj"><a href="#StackObj" class="headerlink" title="StackObj"></a>StackObj</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\memory\allocation.hpp:</div><div class="line"></div><div class="line"><span class="keyword">class</span> StackObj ALLOCATION_SUPER_CLASS_SPEC &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span>  <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p)</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">hotspot\src\share\vm\memory\allocation.cpp:</div><div class="line"><span class="keyword">void</span>* StackObj::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span>  </span>&#123; ShouldNotCallThis(); <span class="keyword">return</span> <span class="number">0</span>; &#125;;</div><div class="line"><span class="keyword">void</span>  StackObj::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p)</span>   </span>&#123; ShouldNotCallThis(); &#125;;</div></pre></td></tr></table></figure>
<p>可以看出，在栈中分配的对象，不允许调用<strong>new</strong>和<strong>delete</strong>,之允许在栈中开辟空间存储。</p>
<h2 id="ResouceObj"><a href="#ResouceObj" class="headerlink" title="ResouceObj"></a>ResouceObj</h2><p>虚拟机为每一个线程分配了一个数据结构为<strong>ResourceArea</strong>的<strong>资源区</strong>。而ResouceObj对象就是在这个区域分配的。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\memory\allocation.hpp:</div><div class="line"></div><div class="line"><span class="keyword">class</span> ResourceObj ALLOCATION_SUPER_CLASS_SPEC &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">enum</span> allocation_type &#123; STACK_OR_EMBEDDED = <span class="number">0</span>, RESOURCE_AREA, C_HEAP, ARENA, allocation_mask = <span class="number">0x3</span> &#125;;</div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_allocation_type</span><span class="params">(address res, allocation_type type)</span> NOT_DEBUG_RETURN</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="comment">// When this object is allocated on stack the new() operator is not</span></div><div class="line">  <span class="comment">// called but garbage on stack may look like a valid allocation_type.</span></div><div class="line">  <span class="comment">// Store negated 'this' pointer when new() is called to distinguish cases.</span></div><div class="line">  <span class="comment">// Use second array's element for verification value to distinguish garbage.</span></div><div class="line">  <span class="keyword">uintptr_t</span> <span class="keyword">_allocation_t</span>[<span class="number">2</span>];</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">is_type_set</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="function">allocation_type <span class="title">get_allocation_type</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">allocated_on_stack</span><span class="params">()</span>    <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> get_allocation_type() == STACK_OR_EMBEDDED; &#125;</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">allocated_on_res_area</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> get_allocation_type() == RESOURCE_AREA; &#125;</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">allocated_on_C_heap</span><span class="params">()</span>   <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> get_allocation_type() == C_HEAP; &#125;</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">allocated_on_arena</span><span class="params">()</span>    <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> get_allocation_type() == ARENA; &#125;</div><div class="line">  ResourceObj(); <span class="comment">// default construtor</span></div><div class="line">  ResourceObj(<span class="keyword">const</span> ResourceObj&amp; r); <span class="comment">// default copy construtor</span></div><div class="line">  ResourceObj&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ResourceObj&amp; r); <span class="comment">// default copy assignment</span></div><div class="line">  ~ResourceObj();</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ASSERT</span></span></div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, allocation_type type, MEMFLAGS flags)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, Arena *arena)</span> </span>&#123;</div><div class="line">      address res = (address)arena-&gt;Amalloc(size);</div><div class="line">      DEBUG_ONLY(set_allocation_type(res, ARENA);)</div><div class="line">      <span class="keyword">return</span> res;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">      address res = (address)resource_allocate_bytes(size);</div><div class="line">      DEBUG_ONLY(set_allocation_type(res, RESOURCE_AREA);)</div><div class="line">      <span class="keyword">return</span> res;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>&amp; nothrow_constant)</span> </span>&#123;</div><div class="line">    address res = (address)resource_allocate_bytes(size, AllocFailStrategy::RETURN_NULL);</div><div class="line">    DEBUG_ONLY(<span class="keyword">if</span> (res != <span class="literal">NULL</span>) set_allocation_type(res, RESOURCE_AREA);)</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span>  <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p)</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>先来看看第一个内存分配方法：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\memory\allocation.cpp:</div><div class="line"></div><div class="line"><span class="keyword">void</span>* ResourceObj::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, allocation_type type, MEMFLAGS flags)</span> </span>&#123;</div><div class="line">  address res;</div><div class="line">  <span class="keyword">switch</span> (type) &#123;</div><div class="line">   <span class="keyword">case</span> C_HEAP:</div><div class="line">    res = (address)AllocateHeap(size, flags, CALLER_PC);</div><div class="line">    DEBUG_ONLY(set_allocation_type(res, C_HEAP);)</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">   <span class="keyword">case</span> RESOURCE_AREA:</div><div class="line">    <span class="comment">// new(size) sets allocation type RESOURCE_AREA.</span></div><div class="line">    res = (address)<span class="keyword">operator</span> <span class="keyword">new</span>(size);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">   <span class="keyword">default</span>:</div><div class="line">    ShouldNotReachHere();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> ResourceObj::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p)</span> </span>&#123;</div><div class="line">  assert(((ResourceObj *)p)-&gt;allocated_on_C_heap(),</div><div class="line">         <span class="string">"delete only allowed for C_HEAP objects"</span>);</div><div class="line">  DEBUG_ONLY(((ResourceObj *)p)-&gt;<span class="keyword">_allocation_t</span>[<span class="number">0</span>] = (<span class="keyword">uintptr_t</span>)badHeapOopVal;)</div><div class="line">  FreeHeap(p);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过这种方式分配的内存支持的类型有<strong>C_HEAP,RESOURCE_AREA</strong>,这两种分别表示：</p>
<ul>
<li>C_HEAP : 直接在内存中分配，而flags表示为各种不同的类型分配的内存，主要用在<strong>MemTracker</strong></li>
<li>RESOURCE_AREA : 在资源区分配内存。<br>其中MEMFLAGS可以为，用于区分不同的内存类型：<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\memory\allocation.hpp:</div><div class="line"></div><div class="line">/*</div><div class="line"> * MemoryType bitmap layout:</div><div class="line"> * | 16 15 14 13 12 11 10 09 | 08 07 06 05 | 04 03 02 01 |</div><div class="line"> * |      memory type        |   object    | reserved    |</div><div class="line"> * |                         |     type    |             |</div><div class="line"> */</div><div class="line">enum MemoryType &#123;</div><div class="line">  // Memory type by sub systems. It occupies lower byte.</div><div class="line">  mtNone              = 0x0000,  // undefined</div><div class="line">  mtClass             = 0x0100,  // memory class for Java classes</div><div class="line">  mtThread            = 0x0200,  // memory for thread objects</div><div class="line">  mtThreadStack       = 0x0300,</div><div class="line">  mtCode              = 0x0400,  // memory for generated code</div><div class="line">  mtGC                = 0x0500,  // memory for GC</div><div class="line">  mtCompiler          = 0x0600,  // memory for compiler</div><div class="line">  mtInternal          = 0x0700,  // memory used by VM, but does not belong to</div><div class="line">                                 // any of above categories, and not used for</div><div class="line">                                 // native memory tracking</div><div class="line">  mtOther             = 0x0800,  // memory not used by VM</div><div class="line">  mtSymbol            = 0x0900,  // symbol</div><div class="line">  mtNMT               = 0x0A00,  // memory used by native memory tracking</div><div class="line">  mtChunk             = 0x0B00,  // chunk that holds content of arenas</div><div class="line">  mtJavaHeap          = 0x0C00,  // Java heap</div><div class="line">  mtClassShared       = 0x0D00,  // class data sharing</div><div class="line">  mtTest              = 0x0E00,  // Test type for verifying NMT</div><div class="line">  mtTracing           = 0x0F00,  // memory used for Tracing</div><div class="line">  mt_number_of_types  = 0x000F,  // number of memory types (mtDontTrack</div><div class="line">                                 // is not included as validate type)</div><div class="line">  mtDontTrack         = 0x1000,  // memory we do not or cannot track</div><div class="line">  mt_masks            = 0x7F00,</div><div class="line"></div><div class="line">  // object type mask</div><div class="line">  otArena             = 0x0010, // an arena object</div><div class="line">  otNMTRecorder       = 0x0020, // memory recorder object</div><div class="line">  ot_masks            = 0x00F0</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>第二种分配方式，可以在制定的资源去分配对象：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\memory\allocation.hpp:</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, Arena *arena)</span> </span>&#123;</div><div class="line">      address res = (address)arena-&gt;Amalloc(size);</div><div class="line">      DEBUG_ONLY(set_allocation_type(res, ARENA);)</div><div class="line">      <span class="keyword">return</span> res;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>第三种分配方式，可以在当前线程进行分配对象：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\memory\allocation.hpp:</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">      address res = (address)resource_allocate_bytes(size);</div><div class="line">      DEBUG_ONLY(set_allocation_type(res, RESOURCE_AREA);)</div><div class="line">      <span class="keyword">return</span> res;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>第四种分配方式和第三种类似，只有很小的区别：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\memory\allocation.hpp:</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>&amp; nothrow_constant)</span> </span>&#123;</div><div class="line">    address res = (address)resource_allocate_bytes(size, AllocFailStrategy::RETURN_NULL);</div><div class="line">    DEBUG_ONLY(<span class="keyword">if</span> (res != <span class="literal">NULL</span>) set_allocation_type(res, RESOURCE_AREA);)</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>第三种和第四种的区别主要在分配失败所采取的策略，第三种直接OOM报错，第三种忽略错误，返回NULL。在资源区分配对象采用了一种必要特别的管理方式，即<strong>Arena</strong>，采用小块分配的方式。</p>
<h3 id="Arena"><a href="#Arena" class="headerlink" title="Arena"></a>Arena</h3><p>ResourceArea也是Area的一种类型，Area采用Chunk的内存管理方式，将内存根据大小划分为<strong>大，种，小</strong>ChunkPool，内存申请如果发现内存不够，那么就直接从缓冲池中获取。由于ChunkPool继承CHeapObj<mtinternal>,表明类型为mtInternal的内存，如果ChunkPool内存不够，就直接从操作系统申请内存，扩充ChunkPool，我们来看看实现。<br>先看看ResourceArea的定义：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\memory\allocation.hpp:</div><div class="line"></div><div class="line"><span class="comment">//------------------------------ResourceArea-----------------------------------</span></div><div class="line"><span class="comment">// A ResourceArea is an Arena that supports safe usage of ResourceMark.</span></div><div class="line"><span class="keyword">class</span> ResourceArea: <span class="keyword">public</span> Arena &#123;</div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> ResourceMark;</div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> DeoptResourceMark;</div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> VMStructs;</div><div class="line">  debug_only(<span class="keyword">int</span> <span class="number">_</span>nesting;)             <span class="comment">// current # of nested ResourceMarks</span></div><div class="line">  debug_only(<span class="keyword">static</span> <span class="keyword">int</span> <span class="number">_</span>warned;)       <span class="comment">// to suppress multiple warnings</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ResourceArea() &#123;</div><div class="line">    debug_only(<span class="number">_</span>nesting = <span class="number">0</span>;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ResourceArea(<span class="keyword">size_t</span> init_size) : Arena(init_size) &#123;</div><div class="line">    debug_only(<span class="number">_</span>nesting = <span class="number">0</span>;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">allocate_bytes</span><span class="params">(<span class="keyword">size_t</span> size, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM)</span> </span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></div><div class="line">    <span class="keyword">if</span> (<span class="number">_</span>nesting &lt; <span class="number">1</span> &amp;&amp; !<span class="number">_</span>warned++)</div><div class="line">      fatal(<span class="string">"memory leak: allocating without ResourceMark"</span>);</div><div class="line">    <span class="keyword">if</span> (UseMallocOnly) &#123;</div><div class="line">      <span class="comment">// use malloc, but save pointer in res. area for later freeing</span></div><div class="line">      <span class="keyword">char</span>** save = (<span class="keyword">char</span>**)internal_malloc_4(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</div><div class="line">      <span class="keyword">return</span> (*save = (<span class="keyword">char</span>*)os::<span class="built_in">malloc</span>(size, mtThread));</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)Amalloc(size, alloc_failmode);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  debug_only(<span class="keyword">int</span> nesting() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="number">_</span>nesting; &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></mtinternal></p>
<p>可以知道从<strong>ResourceArea</strong>申请内存，实际调用的是<strong>Arena::Amalloc</strong>，满足Arena的内存申请规范。继续往下看，Area的定义：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\memory\allocation.hpp:</div><div class="line"></div><div class="line"><span class="comment">//------------------------------Arena------------------------------------------</span></div><div class="line"><span class="comment">// Fast allocation of memory</span></div><div class="line"><span class="keyword">class</span> Arena : <span class="keyword">public</span> CHeapObj&lt;mtNone|otArena&gt; &#123;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> ResourceMark;</div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> HandleMark;</div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> NoHandleMark;</div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> VMStructs;</div><div class="line"></div><div class="line">  Chunk *<span class="number">_f</span>irst;                <span class="comment">// First chunk</span></div><div class="line">  Chunk *<span class="number">_</span>chunk;                <span class="comment">// current chunk</span></div><div class="line">  <span class="keyword">char</span> *<span class="number">_</span>hwm, *<span class="number">_</span>max;            <span class="comment">// High water mark and max in current chunk</span></div><div class="line">  <span class="keyword">size_t</span> <span class="number">_</span>size_in_bytes;        <span class="comment">// Size of arena (used for native memory tracking)</span></div><div class="line"></div><div class="line">  <span class="comment">// Get a new Chunk of at least size x</span></div><div class="line">  <span class="function"><span class="keyword">void</span>* <span class="title">grow</span><span class="params">(<span class="keyword">size_t</span> x, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM)</span></span>;</div><div class="line">  NOT_PRODUCT(<span class="keyword">static</span> julong <span class="number">_b</span>ytes_allocated;) <span class="comment">// total #bytes allocated since start</span></div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> AllocStats;</div><div class="line">  debug_only(<span class="keyword">void</span>* <span class="built_in">malloc</span>(<span class="keyword">size_t</span> size);)</div><div class="line">  debug_only(<span class="keyword">void</span>* internal_malloc_4(<span class="keyword">size_t</span> x);)</div><div class="line">  NOT_PRODUCT(<span class="keyword">void</span> inc_bytes_allocated(<span class="keyword">size_t</span> x);)</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">signal_out_of_memory</span><span class="params">(<span class="keyword">size_t</span> request, <span class="keyword">const</span> <span class="keyword">char</span>* whence)</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">check_for_overflow</span><span class="params">(<span class="keyword">size_t</span> request, <span class="keyword">const</span> <span class="keyword">char</span>* whence,</span></span></div><div class="line">      AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">if</span> (UINTPTR_MAX - request &lt; (<span class="keyword">uintptr_t</span>)<span class="number">_</span>hwm) &#123;</div><div class="line">      <span class="keyword">if</span> (alloc_failmode == AllocFailStrategy::RETURN_NULL) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">      &#125;</div><div class="line">      signal_out_of_memory(request, whence);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  Arena();</div><div class="line">  Arena(<span class="keyword">size_t</span> init_size);</div><div class="line">  ~Arena();</div><div class="line">  <span class="function"><span class="keyword">void</span>  <span class="title">destruct_contents</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">hwm</span><span class="params">()</span> <span class="keyword">const</span>             </span>&#123; <span class="keyword">return</span> <span class="number">_</span>hwm; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// new operators</span></div><div class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>&amp; nothrow_constant)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">// dynamic memory type tagging</span></div><div class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, MEMFLAGS flags)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>&amp; nothrow_constant, MEMFLAGS flags)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span>  <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">// Fast allocate in the arena.  Common case is: pointer test + increment.</span></div><div class="line">  <span class="function"><span class="keyword">void</span>* <span class="title">Amalloc</span><span class="params">(<span class="keyword">size_t</span> x, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM)</span> </span>&#123;</div><div class="line">    assert(is_power_of_2(ARENA_AMALLOC_ALIGNMENT) , <span class="string">"should be a power of 2"</span>);</div><div class="line">    x = ARENA_ALIGN(x);</div><div class="line">    debug_only(<span class="keyword">if</span> (UseMallocOnly) <span class="keyword">return</span> <span class="built_in">malloc</span>(x);)</div><div class="line">    <span class="keyword">if</span> (!check_for_overflow(x, <span class="string">"Arena::Amalloc"</span>, alloc_failmode))</div><div class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    NOT_PRODUCT(inc_bytes_allocated(x);)</div><div class="line">    <span class="keyword">if</span> (<span class="number">_</span>hwm + x &gt; <span class="number">_</span>max) &#123;</div><div class="line">      <span class="keyword">return</span> grow(x, alloc_failmode);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">char</span> *old = <span class="number">_</span>hwm;</div><div class="line">      <span class="number">_</span>hwm += x;</div><div class="line">      <span class="keyword">return</span> old;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// Further assume size is padded out to words</span></div><div class="line">  <span class="function"><span class="keyword">void</span> *<span class="title">Amalloc_4</span><span class="params">(<span class="keyword">size_t</span> x, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM)</span> </span>&#123;</div><div class="line">    assert( (x&amp;(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*)<span class="number">-1</span>)) == <span class="number">0</span>, <span class="string">"misaligned size"</span> );</div><div class="line">    debug_only(<span class="keyword">if</span> (UseMallocOnly) <span class="keyword">return</span> <span class="built_in">malloc</span>(x);)</div><div class="line">    <span class="keyword">if</span> (!check_for_overflow(x, <span class="string">"Arena::Amalloc_4"</span>, alloc_failmode))</div><div class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    NOT_PRODUCT(inc_bytes_allocated(x);)</div><div class="line">    <span class="keyword">if</span> (<span class="number">_</span>hwm + x &gt; <span class="number">_</span>max) &#123;</div><div class="line">      <span class="keyword">return</span> grow(x, alloc_failmode);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">char</span> *old = <span class="number">_</span>hwm;</div><div class="line">      <span class="number">_</span>hwm += x;</div><div class="line">      <span class="keyword">return</span> old;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Allocate with 'double' alignment. It is 8 bytes on sparc.</span></div><div class="line">  <span class="comment">// In other cases Amalloc_D() should be the same as Amalloc_4().</span></div><div class="line">  <span class="function"><span class="keyword">void</span>* <span class="title">Amalloc_D</span><span class="params">(<span class="keyword">size_t</span> x, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM)</span> </span>&#123;</div><div class="line">    assert( (x&amp;(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*)<span class="number">-1</span>)) == <span class="number">0</span>, <span class="string">"misaligned size"</span> );</div><div class="line">    debug_only(<span class="keyword">if</span> (UseMallocOnly) <span class="keyword">return</span> <span class="built_in">malloc</span>(x);)</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(SPARC) &amp;&amp; !defined(_LP64)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DALIGN_M1 7</span></div><div class="line">    <span class="keyword">size_t</span> delta = (((<span class="keyword">size_t</span>)<span class="number">_</span>hwm + DALIGN_M1) &amp; ~DALIGN_M1) - (<span class="keyword">size_t</span>)<span class="number">_</span>hwm;</div><div class="line">    x += delta;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">if</span> (!check_for_overflow(x, <span class="string">"Arena::Amalloc_D"</span>, alloc_failmode))</div><div class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    NOT_PRODUCT(inc_bytes_allocated(x);)</div><div class="line">    <span class="keyword">if</span> (<span class="number">_</span>hwm + x &gt; <span class="number">_</span>max) &#123;</div><div class="line">      <span class="keyword">return</span> grow(x, alloc_failmode); <span class="comment">// grow() returns a result aligned &gt;= 8 bytes.</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">char</span> *old = <span class="number">_</span>hwm;</div><div class="line">      <span class="number">_</span>hwm += x;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(SPARC) &amp;&amp; !defined(_LP64)</span></div><div class="line">      old += delta; <span class="comment">// align to 8-bytes</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">      <span class="keyword">return</span> old;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Fast delete in area.  Common case is: NOP (except for storage reclaimed)</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Afree</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></div><div class="line">    <span class="keyword">if</span> (ZapResourceArea) <span class="built_in">memset</span>(ptr, badResourceValue, size); <span class="comment">// zap freed memory</span></div><div class="line">    <span class="keyword">if</span> (UseMallocOnly) <span class="keyword">return</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">if</span> (((<span class="keyword">char</span>*)ptr) + size == <span class="number">_</span>hwm) <span class="number">_</span>hwm = (<span class="keyword">char</span>*)ptr;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> *<span class="title">Arealloc</span><span class="params">( <span class="keyword">void</span> *old_ptr, <span class="keyword">size_t</span> old_size, <span class="keyword">size_t</span> new_size,</span></span></div><div class="line">     AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);</div><div class="line"></div><div class="line">  <span class="comment">// Move contents of this arena into an empty arena</span></div><div class="line">  <span class="function">Arena *<span class="title">move_contents</span><span class="params">(Arena *empty_arena)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">// Determine if pointer belongs to this Arena or not.</span></div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">( <span class="keyword">const</span> <span class="keyword">void</span> *ptr )</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">// Total of all chunks in use (not thread-safe)</span></div><div class="line">  <span class="keyword">size_t</span> used() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Total # of bytes used</span></div><div class="line">  <span class="keyword">size_t</span> size_in_bytes() <span class="keyword">const</span>         &#123;  <span class="keyword">return</span> <span class="number">_</span>size_in_bytes; &#125;;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_size_in_bytes</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">free_malloced_objects</span><span class="params">(Chunk* chunk, <span class="keyword">char</span>* hwm, <span class="keyword">char</span>* max, <span class="keyword">char</span>* hwm2)</span>  PRODUCT_RETURN</span>;</div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">free_all</span><span class="params">(<span class="keyword">char</span>** start, <span class="keyword">char</span>** end)</span>                                     PRODUCT_RETURN</span>;</div><div class="line"></div><div class="line">  <span class="comment">// how many arena instances</span></div><div class="line">  NOT_PRODUCT(<span class="keyword">static</span> <span class="keyword">volatile</span> jint <span class="number">_</span>instance_count;)</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="comment">// Reset this Arena to empty, access will trigger grow if necessary</span></div><div class="line">  <span class="function"><span class="keyword">void</span>   <span class="title">reset</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="number">_f</span>irst = <span class="number">_</span>chunk = <span class="literal">NULL</span>;</div><div class="line">    <span class="number">_</span>hwm = <span class="number">_</span>max = <span class="literal">NULL</span>;</div><div class="line">    set_size_in_bytes(<span class="number">0</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>Arena</strong>维护了以下成员：</p>
<ul>
<li>_first：记录了这个内存区域，通过chunk中的next形成一个链表</li>
<li>_chunk：记录当前指向的chunk</li>
<li>_hwm：记录当前已经分配的内存地址，可以直接加上指定申请的内存大小快速分配内存</li>
<li>_max：记录当前最大可以分配的内存地址</li>
<li>_size_in_bytes：记录当前内存区域的大小。理论上是所有chunk的大小之和</li>
</ul>
<p>同时看看分配的最小单元<strong>Chunk</strong>：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\memory\allocation.hpp:</div><div class="line"></div><div class="line"><span class="comment">//------------------------------Chunk------------------------------------------</span></div><div class="line"><span class="comment">// Linked list of raw memory chunks</span></div><div class="line"><span class="keyword">class</span> Chunk: CHeapObj&lt;mtChunk&gt; &#123;</div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> VMStructs;</div><div class="line"></div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">  Chunk*       <span class="number">_</span>next;     <span class="comment">// Next Chunk in list</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> <span class="number">_l</span>en;      <span class="comment">// Size of this Chunk</span></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, AllocFailType alloc_failmode, <span class="keyword">size_t</span> length)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span>  <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p)</span></span>;</div><div class="line">  Chunk(<span class="keyword">size_t</span> length);</div><div class="line"></div><div class="line">  <span class="keyword">enum</span> &#123;</div><div class="line">    <span class="comment">// default sizes; make them slightly smaller than 2**k to guard against</span></div><div class="line">    <span class="comment">// buddy-system style malloc implementations</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LP64</span></div><div class="line">    slack      = <span class="number">40</span>,            <span class="comment">// [RGV] Not sure if this is right, but make it</span></div><div class="line">                                <span class="comment">//       a multiple of 8.</span></div><div class="line">#<span class="keyword">else</span></div><div class="line">    slack      = <span class="number">20</span>,            <span class="comment">// suspected sizeof(Chunk) + internal malloc headers</span></div><div class="line">#endif</div><div class="line"></div><div class="line">    init_size  =  <span class="number">1</span>*K  - slack, <span class="comment">// Size of first chunk</span></div><div class="line">    medium_size= <span class="number">10</span>*K  - slack, <span class="comment">// Size of medium-sized chunk</span></div><div class="line">    size       = <span class="number">32</span>*K  - slack, <span class="comment">// Default size of an Arena chunk (following the first)</span></div><div class="line">    non_pool_size = init_size + <span class="number">32</span> <span class="comment">// An initial size which is not one of above</span></div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">chop</span><span class="params">()</span></span>;                  <span class="comment">// Chop this chunk</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">next_chop</span><span class="params">()</span></span>;             <span class="comment">// Chop next chunk</span></div><div class="line">  <span class="function"><span class="keyword">static</span> size_t <span class="title">aligned_overhead_size</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="keyword">return</span> ARENA_ALIGN(<span class="keyword">sizeof</span>(Chunk)); &#125;</div><div class="line"></div><div class="line">  <span class="keyword">size_t</span> length() <span class="keyword">const</span>         &#123; <span class="keyword">return</span> <span class="number">_l</span>en;  &#125;</div><div class="line">  <span class="function">Chunk* <span class="title">next</span><span class="params">()</span> <span class="keyword">const</span>           </span>&#123; <span class="keyword">return</span> <span class="number">_</span>next;  &#125;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_next</span><span class="params">(Chunk* n)</span>       </span>&#123; <span class="number">_</span>next = n;  &#125;</div><div class="line">  <span class="comment">// Boundaries of data area (possibly unused)</span></div><div class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">bottom</span><span class="params">()</span> <span class="keyword">const</span>          </span>&#123; <span class="keyword">return</span> ((<span class="keyword">char</span>*) <span class="keyword">this</span>) + aligned_overhead_size();  &#125;</div><div class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">top</span><span class="params">()</span>    <span class="keyword">const</span>          </span>&#123; <span class="keyword">return</span> bottom() + <span class="number">_l</span>en; &#125;</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">char</span>* p)</span> <span class="keyword">const</span>  </span>&#123; <span class="keyword">return</span> bottom() &lt;= p &amp;&amp; p &lt;= top(); &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Start the chunk_pool cleaner task</span></div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start_chunk_pool_cleaner_task</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clean_chunk_pool</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>Chunk</strong>是Area扩充的最小单元，也就是说如果Area发现内存不足，扩充时最小的大小就是<strong>Chunk</strong>。其通过<strong>_next</strong>指针，将各个<strong>Chunk</strong>形成一个单向的链表。<strong>_len</strong>表示其可管理的内存大小。<br>另外<strong>Chunk</strong>自身的分配也是通过池化来管理的，Chunk根据大小分为<strong> 大，中，小 </strong>：<br>大：size       = 32<em>K  - slack<br>中：medium_size= 10</em>K  - slack<br>小：init_size  =  1*K  - slack</p>
<p>同样看看ChunkPool的结构：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\memory\allocation.hpp:</div><div class="line"></div><div class="line"><span class="keyword">class</span> ChunkPool: <span class="keyword">public</span> CHeapObj&lt;mtInternal&gt; &#123;</div><div class="line">  Chunk*       <span class="number">_f</span>irst;        <span class="comment">// first cached Chunk; its first word points to next chunk</span></div><div class="line">  <span class="keyword">size_t</span>       <span class="number">_</span>num_chunks;   <span class="comment">// number of unused chunks in pool</span></div><div class="line">  <span class="keyword">size_t</span>       <span class="number">_</span>num_used;     <span class="comment">// number of chunks currently checked out</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> <span class="number">_</span>size;         <span class="comment">// size of each chunk (must be uniform)</span></div><div class="line"></div><div class="line">  <span class="comment">// Our three static pools</span></div><div class="line">  <span class="keyword">static</span> ChunkPool* <span class="number">_l</span>arge_pool;</div><div class="line">  <span class="keyword">static</span> ChunkPool* <span class="number">_</span>medium_pool;</div><div class="line">  <span class="keyword">static</span> ChunkPool* <span class="number">_</span>small_pool;</div><div class="line"></div><div class="line">  <span class="comment">// return first element or null</span></div><div class="line">  <span class="function"><span class="keyword">void</span>* <span class="title">get_first</span><span class="params">()</span> </span>&#123;</div><div class="line">    Chunk* c = <span class="number">_f</span>irst;</div><div class="line">    <span class="keyword">if</span> (<span class="number">_f</span>irst) &#123;</div><div class="line">      <span class="number">_f</span>irst = <span class="number">_f</span>irst-&gt;next();</div><div class="line">      <span class="number">_</span>num_chunks--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> c;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="comment">// All chunks in a ChunkPool has the same size</span></div><div class="line">   ChunkPool(<span class="keyword">size_t</span> size) : <span class="number">_</span>size(size) &#123; <span class="number">_f</span>irst = <span class="literal">NULL</span>; <span class="number">_</span>num_chunks = <span class="number">_</span>num_used = <span class="number">0</span>; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Allocate a new chunk from the pool (might expand the pool)</span></div><div class="line">  <span class="number">_</span><span class="function">NOINLINE_ <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> bytes, AllocFailType alloc_failmode)</span> </span>&#123;</div><div class="line">    assert(bytes == <span class="number">_</span>size, <span class="string">"bad size"</span>);</div><div class="line">    <span class="keyword">void</span>* p = <span class="literal">NULL</span>;</div><div class="line">    <span class="comment">// No VM lock can be taken inside ThreadCritical lock, so os::malloc</span></div><div class="line">    <span class="comment">// should be done outside ThreadCritical lock due to NMT</span></div><div class="line">    &#123; ThreadCritical tc;</div><div class="line">      <span class="number">_</span>num_used++;</div><div class="line">      p = get_first();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) p = os::<span class="built_in">malloc</span>(bytes, mtChunk, CURRENT_PC);</div><div class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> &amp;&amp; alloc_failmode == AllocFailStrategy::EXIT_OOM) &#123;</div><div class="line">      vm_exit_out_of_memory(bytes, <span class="string">"ChunkPool::allocate"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Return a chunk to the pool</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(Chunk* chunk)</span> </span>&#123;</div><div class="line">    assert(chunk-&gt;length() + Chunk::aligned_overhead_size() == <span class="number">_</span>size, <span class="string">"bad size"</span>);</div><div class="line">    ThreadCritical tc;</div><div class="line">    <span class="number">_</span>num_used--;</div><div class="line"></div><div class="line">    <span class="comment">// Add chunk to list</span></div><div class="line">    chunk-&gt;set_next(<span class="number">_f</span>irst);</div><div class="line">    <span class="number">_f</span>irst = chunk;</div><div class="line">    <span class="number">_</span>num_chunks++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Prune the pool</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">free_all_but</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123;</div><div class="line">    Chunk* cur = <span class="literal">NULL</span>;</div><div class="line">    Chunk* next;</div><div class="line">    &#123;</div><div class="line">    <span class="comment">// if we have more than n chunks, free all of them</span></div><div class="line">    ThreadCritical tc;</div><div class="line">    <span class="keyword">if</span> (<span class="number">_</span>num_chunks &gt; n) &#123;</div><div class="line">      <span class="comment">// free chunks at end of queue, for better locality</span></div><div class="line">        cur = <span class="number">_f</span>irst;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; (n - <span class="number">1</span>) &amp;&amp; cur != <span class="literal">NULL</span>; i++) cur = cur-&gt;next();</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123;</div><div class="line">          next = cur-&gt;next();</div><div class="line">        cur-&gt;set_next(<span class="literal">NULL</span>);</div><div class="line">        cur = next;</div><div class="line"></div><div class="line">          <span class="number">_</span>num_chunks = n;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Free all remaining chunks, outside of ThreadCritical</span></div><div class="line">    <span class="comment">// to avoid deadlock with NMT</span></div><div class="line">        <span class="keyword">while</span>(cur != <span class="literal">NULL</span>) &#123;</div><div class="line">          next = cur-&gt;next();</div><div class="line">      os::<span class="built_in">free</span>(cur, mtChunk);</div><div class="line">          cur = next;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Accessors to preallocated pool's</span></div><div class="line">  <span class="function"><span class="keyword">static</span> ChunkPool* <span class="title">large_pool</span><span class="params">()</span>  </span>&#123; assert(<span class="number">_l</span>arge_pool  != <span class="literal">NULL</span>, <span class="string">"must be initialized"</span>); <span class="keyword">return</span> <span class="number">_l</span>arge_pool;  &#125;</div><div class="line">  <span class="function"><span class="keyword">static</span> ChunkPool* <span class="title">medium_pool</span><span class="params">()</span> </span>&#123; assert(<span class="number">_</span>medium_pool != <span class="literal">NULL</span>, <span class="string">"must be initialized"</span>); <span class="keyword">return</span> <span class="number">_</span>medium_pool; &#125;</div><div class="line">  <span class="function"><span class="keyword">static</span> ChunkPool* <span class="title">small_pool</span><span class="params">()</span>  </span>&#123; assert(<span class="number">_</span>small_pool  != <span class="literal">NULL</span>, <span class="string">"must be initialized"</span>); <span class="keyword">return</span> <span class="number">_</span>small_pool;  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="number">_l</span>arge_pool  = <span class="keyword">new</span> ChunkPool(Chunk::size        + Chunk::aligned_overhead_size());</div><div class="line">    <span class="number">_</span>medium_pool = <span class="keyword">new</span> ChunkPool(Chunk::medium_size + Chunk::aligned_overhead_size());</div><div class="line">    <span class="number">_</span>small_pool  = <span class="keyword">new</span> ChunkPool(Chunk::init_size   + Chunk::aligned_overhead_size());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">enum</span> &#123; BlocksToKeep = <span class="number">5</span> &#125;;</div><div class="line">     <span class="number">_</span>small_pool-&gt;free_all_but(BlocksToKeep);</div><div class="line">     <span class="number">_</span>medium_pool-&gt;free_all_but(BlocksToKeep);</div><div class="line">     <span class="number">_l</span>arge_pool-&gt;free_all_but(BlocksToKeep);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>ChunkPool</strong>的结构成员：<br>_first：指向第一个chunk<br>_num_chunks：空闲chunk的个数<br>_num_used：在使用的chunk个数<br>_size：管理chunk的大小<br>_large_pool：静态成员，chunk的大小为大的都在这个池中<br>_medium_pool：静态成员，chunk的大小为中的都在这个池中<br>_small_pool：静态成员，chunk的大小为小的都在这个池中</p>
<p><strong>Arena,Chunk,ChunkPool</strong>都是<strong>CHeapObj\<mtinternal\></mtinternal\></strong>类型的对象，说明这几种结构都是在CHeapObj分配。这些结构都是提供管理的数据结构，内存类型为<strong>mtInternal</strong></p>
<h3 id="Arena分配过程"><a href="#Arena分配过程" class="headerlink" title="Arena分配过程"></a>Arena分配过程</h3><p>从前面我们知道<strong>ResouceArea</strong>调用<strong>Area::Amalloc</strong>分配：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\memory\allocation.hpp:</div><div class="line"></div><div class="line">  <span class="comment">// Fast allocate in the arena.  Common case is: pointer test + increment.</span></div><div class="line">  <span class="function"><span class="keyword">void</span>* <span class="title">Amalloc</span><span class="params">(<span class="keyword">size_t</span> x, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM)</span> </span>&#123;</div><div class="line">    assert(is_power_of_2(ARENA_AMALLOC_ALIGNMENT) , <span class="string">"should be a power of 2"</span>);</div><div class="line">    x = ARENA_ALIGN(x);</div><div class="line">    debug_only(<span class="keyword">if</span> (UseMallocOnly) <span class="keyword">return</span> <span class="built_in">malloc</span>(x);)</div><div class="line">    <span class="keyword">if</span> (!check_for_overflow(x, <span class="string">"Arena::Amalloc"</span>, alloc_failmode))</div><div class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    NOT_PRODUCT(inc_bytes_allocated(x);)</div><div class="line">    <span class="keyword">if</span> (<span class="number">_</span>hwm + x &gt; <span class="number">_</span>max) &#123;</div><div class="line">      <span class="keyword">return</span> grow(x, alloc_failmode);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">char</span> *old = <span class="number">_</span>hwm;</div><div class="line">      <span class="number">_</span>hwm += x;</div><div class="line">      <span class="keyword">return</span> old;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>1.首先检测内存是否溢出，如果发现没有溢出，并且存在的内存还能够按照请求的大小分配，那么这里只是所以一个记录，将<strong>_hwm</strong>加上申请的内存大小，直接返回，可以看出，这里就做了一个记录工作，所以分配是很快的<br>2.如果以上的条件不满足，说明现存的Chunk已经不满足内存的分配了，需要扩充Chunk。通过调用<strong>grow</strong>：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\memory\allocation.cpp:</div><div class="line"></div><div class="line"><span class="comment">// Grow a new Chunk</span></div><div class="line"><span class="keyword">void</span>* Arena::grow(<span class="keyword">size_t</span> x, AllocFailType alloc_failmode) &#123;</div><div class="line">  <span class="comment">// Get minimal required size.  Either real big, or even bigger for giant objs</span></div><div class="line">  <span class="keyword">size_t</span> len = MAX2(x, (<span class="keyword">size_t</span>) Chunk::size);</div><div class="line"></div><div class="line">  Chunk *k = <span class="number">_</span>chunk;            <span class="comment">// Get filled-up chunk address</span></div><div class="line">  <span class="number">_</span>chunk = <span class="keyword">new</span> (alloc_failmode, len) Chunk(len);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="number">_</span>chunk == <span class="literal">NULL</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (k) k-&gt;set_next(<span class="number">_</span>chunk);   <span class="comment">// Append new chunk to end of linked list</span></div><div class="line">  <span class="keyword">else</span> <span class="number">_f</span>irst = <span class="number">_</span>chunk;</div><div class="line">  <span class="number">_</span>hwm  = <span class="number">_</span>chunk-&gt;bottom();     <span class="comment">// Save the cached hwm, max</span></div><div class="line">  <span class="number">_</span>max =  <span class="number">_</span>chunk-&gt;top();</div><div class="line">  set_size_in_bytes(size_in_bytes() + len);</div><div class="line">  <span class="keyword">void</span>* result = <span class="number">_</span>hwm;</div><div class="line">  <span class="number">_</span>hwm += x;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.由于Chunk是内存管理的最小单元，所以分配的最小单元每次扩充只能是Chunk，需要注意的是，Area分配的内存最小是<strong>Chunk::size</strong>，<strong>Chunk::size</strong>的值为32 <em> K  - slack。也就是说直接从大的<strong>ChunkPool</strong>分配内存。如果申请的内存大于这个大小，那么直接从内存中分配，相当于每次调用都需要调用系统开辟内存，<strong>Chunk</strong>的效率提升也就不明显了,反而是累赘，但一般都是小与此值的。<br>4.申请好了<strong>Chunk</strong>后，就将这个<strong>Chunk</strong>链入<strong>Arena</strong>的<strong>_chunk</strong>链表,组成一个单向链表，将当前的<strong>_chunk</strong>指向分配的<strong>Chunk</strong>，将<strong>_hwm</strong>指向<strong>Chunk</strong>的内存地址(这个地址不是分配<strong>Chunk</strong>的地址，而是<strong>Chunk</strong>的内存地址机上<strong>Chunk</strong>结构的大小，<strong>Chunk</strong>是管理的角色)。<strong>_max</strong>指向<strong>Chunk</strong>可管理的结尾(通过bottom()+len)。且记录当前<strong>Area</strong>的大小后，分配内存返回。<br>5.上面将这个方法调用的介绍完了，还没有深入<strong>Chunk</strong>和<em>*ChunkPool</em></em>，我们继续：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\memory\allocation.cpp:</div><div class="line"></div><div class="line"><span class="keyword">void</span>* Chunk::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> requested_size, AllocFailType alloc_failmode, <span class="keyword">size_t</span> length)</span> </span>&#123;</div><div class="line">  <span class="comment">// requested_size is equal to sizeof(Chunk) but in order for the arena</span></div><div class="line">  <span class="comment">// allocations to come out aligned as expected the size must be aligned</span></div><div class="line">  <span class="comment">// to expected arean alignment.</span></div><div class="line">  <span class="comment">// expect requested_size but if sizeof(Chunk) doesn't match isn't proper size we must align it.</span></div><div class="line">  assert(ARENA_ALIGN(requested_size) == aligned_overhead_size(), <span class="string">"Bad alignment"</span>);</div><div class="line">  <span class="keyword">size_t</span> bytes = ARENA_ALIGN(requested_size) + length;</div><div class="line">  <span class="keyword">switch</span> (length) &#123;</div><div class="line">   <span class="keyword">case</span> Chunk::size:        <span class="keyword">return</span> ChunkPool::large_pool()-&gt;allocate(bytes, alloc_failmode);</div><div class="line">   <span class="keyword">case</span> Chunk::medium_size: <span class="keyword">return</span> ChunkPool::medium_pool()-&gt;allocate(bytes, alloc_failmode);</div><div class="line">   <span class="keyword">case</span> Chunk::init_size:   <span class="keyword">return</span> ChunkPool::small_pool()-&gt;allocate(bytes, alloc_failmode);</div><div class="line">   <span class="keyword">default</span>: &#123;</div><div class="line">     <span class="keyword">void</span> *p =  os::<span class="built_in">malloc</span>(bytes, mtChunk, CALLER_PC);</div><div class="line">     <span class="keyword">if</span> (p == <span class="literal">NULL</span> &amp;&amp; alloc_failmode == AllocFailStrategy::EXIT_OOM) &#123;</div><div class="line">       vm_exit_out_of_memory(bytes, <span class="string">"Chunk::new"</span>);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> p;</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正如描述的，Chunk会根据ChunkPool各个管理的Chunk大小来分配Chunk，共四类(大，中，小，默认)。<br>6.ChunkPool的分配：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\memory\allocation.cpp:</div><div class="line"></div><div class="line">  <span class="number">_</span><span class="function">NOINLINE_ <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> bytes, AllocFailType alloc_failmode)</span> </span>&#123;</div><div class="line">    assert(bytes == <span class="number">_</span>size, <span class="string">"bad size"</span>);</div><div class="line">    <span class="keyword">void</span>* p = <span class="literal">NULL</span>;</div><div class="line">    <span class="comment">// No VM lock can be taken inside ThreadCritical lock, so os::malloc</span></div><div class="line">    <span class="comment">// should be done outside ThreadCritical lock due to NMT</span></div><div class="line">    &#123; ThreadCritical tc;</div><div class="line">      <span class="number">_</span>num_used++;</div><div class="line">      p = get_first();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) p = os::<span class="built_in">malloc</span>(bytes, mtChunk, CURRENT_PC);</div><div class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> &amp;&amp; alloc_failmode == AllocFailStrategy::EXIT_OOM) &#123;</div><div class="line">      vm_exit_out_of_memory(bytes, <span class="string">"ChunkPool::allocate"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p><strong>ChunkPool</strong>会通过<strong>_first</strong>维护一个链表，如果这个非空，就从这个缓存中直接获取一个返回，否则直接从操作系统分配一个。至此，<strong>Chunk</strong>的分配就已经结束了，<strong>Chunk</strong>从主体上利用缓存在提升效率。</p>
<p><strong>Arena回收过程</strong><br><strong>Arena</strong>的回收会直接释放内存,也就无法利用<strong>Chunk</strong>的缓存效益：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\memory\allocation.cpp:</div><div class="line"></div><div class="line"><span class="keyword">void</span> Arena::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p)</span> </span>&#123;</div><div class="line">  FreeHeap(p);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一般采用<strong>_chunk-&gt;next_chop();</strong>释放：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\memory\allocation.cpp:</div><div class="line"></div><div class="line"><span class="keyword">void</span> Chunk::next_chop() &#123;</div><div class="line">  <span class="number">_</span>next-&gt;chop();</div><div class="line">  <span class="number">_</span>next = <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Chunk::chop() &#123;</div><div class="line">  Chunk *k = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">while</span>( k ) &#123;</div><div class="line">    Chunk *tmp = k-&gt;next();</div><div class="line">    <span class="comment">// clear out this chunk (to detect allocation bugs)</span></div><div class="line">    <span class="keyword">if</span> (ZapResourceArea) <span class="built_in">memset</span>(k-&gt;bottom(), badResourceValue, k-&gt;length());</div><div class="line">    <span class="keyword">delete</span> k;                   <span class="comment">// Free chunk (was malloc'd)</span></div><div class="line">    k = tmp;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Chunk::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p)</span> </span>&#123;</div><div class="line">  Chunk* c = (Chunk*)p;</div><div class="line">  <span class="keyword">switch</span> (c-&gt;length()) &#123;</div><div class="line">   <span class="keyword">case</span> Chunk::size:        ChunkPool::large_pool()-&gt;<span class="built_in">free</span>(c); <span class="keyword">break</span>;</div><div class="line">   <span class="keyword">case</span> Chunk::medium_size: ChunkPool::medium_pool()-&gt;<span class="built_in">free</span>(c); <span class="keyword">break</span>;</div><div class="line">   <span class="keyword">case</span> Chunk::init_size:   ChunkPool::small_pool()-&gt;<span class="built_in">free</span>(c); <span class="keyword">break</span>;</div><div class="line">   <span class="keyword">default</span>:                 os::<span class="built_in">free</span>(c, mtChunk);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(Chunk* chunk)</span> </span>&#123;</div><div class="line">    assert(chunk-&gt;length() + Chunk::aligned_overhead_size() == <span class="number">_</span>size, <span class="string">"bad size"</span>);</div><div class="line">    ThreadCritical tc;</div><div class="line">    <span class="number">_</span>num_used--;</div><div class="line"></div><div class="line">    <span class="comment">// Add chunk to list</span></div><div class="line">    chunk-&gt;set_next(<span class="number">_f</span>irst);</div><div class="line">    <span class="number">_f</span>irst = chunk;</div><div class="line">    <span class="number">_</span>num_chunks++;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，此调用回将当前的<strong>Chunk</strong>回收，返回到<strong>ChunkPoop</strong>的<strong>_first</strong>链表缓存，以待下次使用，减少系统调用的次数，缓存内存页，提升内存分配的性能。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JVM提供了各种内存分配的结构，这些通用的结构简化了开发功能。通过区分各种不同的内存类型，从结构上也明确了各个对象的从属关系，内存归属类别。使得程序更加清晰明了。<br>内存分配中，特别是<strong>资源区</strong>的分配，JVM提供了一套精密的分配方式，缓存内存页面，由于操作系统通常分配一个页面供系统使用，而大部分的分配都不需要这么多，通常申请一块内存区域，通过计数，供JVM申请内存，提升内存分配效率。<br><strong>Arena</strong>提供了两层的缓存结构，首先通过Chunk进行分配，然后Chunk的分配通过池化的手段提升分配<strong>Chunk</strong>的效率。根据程序局部性原理，县城内部分配资源的可能最大，所以提供了这种快速分配内存的方式。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/09/21/jvm-memory-allocate/" class="archive-article-date">
  	<time datetime="2016-09-21T05:36:41.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-09-21</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Java/">Java</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
  
    <a href="/2016/09/21/jvm-resouce-mark/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">JVM基础设施之ResourceMark</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>




<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
	    <a class="jiathis_button_twitter"></a>
	    <a class="jiathis_button_plus"></a> 
	    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="jvm-memory-allocate" data-title="JVM 基础设施之内存分配" data-url="http://yoursite.com/2016/09/21/jvm-memory-allocate/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>





      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Corner XX
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/"
	}
</script>

<script src="/./main.js"></script>





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Hadoop-Hdfs/" style="font-size: 10px;">Hadoop Hdfs</a> <a href="/tags/Hadoop-Yran/" style="font-size: 10px;">Hadoop Yran</a> <a href="/tags/Hbase/" style="font-size: 15px;">Hbase</a> <a href="/tags/JVM/" style="font-size: 20px;">JVM</a> <a href="/tags/Kernel/" style="font-size: 10px;">Kernel</a>
    			</div>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">记录点点滴滴</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>