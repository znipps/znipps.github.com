<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>JVM ClassLoader机制 | Corner XX daily log</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="介绍Java虚拟机ClassLoader的机制，实现以及各种应用场景，重点介绍了默认加载体系和tomcat的加载体系。osgi体系没有介绍。这里从虚拟机的实现角度描述，部分设计虚拟机的代码,C++语言描述.">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM ClassLoader机制">
<meta property="og:url" content="http://yoursite.com/2016/09/23/jvm/classloader/index.html">
<meta property="og:site_name" content="Corner XX daily log">
<meta property="og:description" content="介绍Java虚拟机ClassLoader的机制，实现以及各种应用场景，重点介绍了默认加载体系和tomcat的加载体系。osgi体系没有介绍。这里从虚拟机的实现角度描述，部分设计虚拟机的代码,C++语言描述.">
<meta property="og:updated_time" content="2017-05-13T09:40:57.445Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JVM ClassLoader机制">
<meta name="twitter:description" content="介绍Java虚拟机ClassLoader的机制，实现以及各种应用场景，重点介绍了默认加载体系和tomcat的加载体系。osgi体系没有介绍。这里从虚拟机的实现角度描述，部分设计虚拟机的代码,C++语言描述.">
  
    <link rel="alternative" href="/atom.xml" title="Corner XX daily log" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.png">
  
  <script src="/style.js"></script>
</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/img/suolong.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Corner XX</a></h1>
		</hgroup>

		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="#" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/cornerxx" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">Corner XX</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="/img/suolong.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Corner XX</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/cornerxx" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        <article id="post-jvm/classloader" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JVM ClassLoader机制
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>介绍Java虚拟机ClassLoader的机制，实现以及各种应用场景，重点介绍了默认加载体系和tomcat的加载体系。osgi体系没有介绍。这里从虚拟机的实现角度描述，部分设计虚拟机的代码,C++语言描述.<br><a id="more"></a></p>
<h2 id="ClassLoader概述"><a href="#ClassLoader概述" class="headerlink" title="ClassLoader概述"></a>ClassLoader概述</h2><p>Class的重要性不言而喻，怎么加载class文件到内存表达成虚拟机内部对象也是重点需要关注。JVM提供了通过以下几种形式显示触发classs文件的加载：</p>
<ol>
<li>new</li>
<li>ClassLoader.loadClass</li>
<li>Class.forName</li>
</ol>
<p>在类加载器中主要有三个角色，分别是Bootstrap类加载器，Ext类加载器，Sys类加载器。我们分别描述一下各个类加载器：</p>
<ul>
<li>Bootstrap类加载器<br>C++实现，虚拟机本身加载类所使用的类加载器，在虚拟机中classloader为null。这个加载器搜索类路径可以通过-Dsun.boot.class.path进行更改。默认在jre/lib中寻找类</li>
<li>Ext类加载器<br>java实现，表示为sun.misc.Launcher$ExtClassLoader类，这个加载器没有父加载器，查找路径通过-Djava.ext.dirs指定，默认在jre/lib/ext中寻找类</li>
<li>Sys类加载器<br>java实现，表示sun.misc.Launcher$AppClassLoader类，这个加载器默认父加载器为Ext加载器，查找路径通过-Djava.class.path指定，也就是我们通常说的classpath</li>
<li>ContextClassLoader<br>java实现，默认和Sys类加载器一样。用于特定场景。</li>
</ul>
<h2 id="main方法执行加载过程"><a href="#main方法执行加载过程" class="headerlink" title="main方法执行加载过程"></a>main方法执行加载过程</h2><p>虚拟机加载main方法所在类的时候并不是直接通过Bootstrap类加载器，而是通过Sys类加载器进行加载。我们先看一段代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EMPTY_TAB = <span class="string">""</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TAB = <span class="string">"    "</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TAB_TAB = TAB + TAB;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TABTABTAB = TAB + TAB + TAB;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String NEW_LINE = <span class="string">"\n"</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String SYSTEM_CLASSLOADER_NAME = <span class="string">"sysClassLoader"</span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">shiftLeft</span><span class="params">(String shiftString, <span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> EMPTY_TAB;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</div><div class="line">			<span class="keyword">return</span> TAB;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (size == <span class="number">2</span>) &#123;</div><div class="line">			<span class="keyword">return</span> TAB_TAB;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (size == <span class="number">3</span>) &#123;</div><div class="line">			<span class="keyword">return</span> TABTABTAB;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">			sb.append(shiftString);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> sb.toString();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClassLoader</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</div><div class="line">		ClassLoader loader = clazz.getClassLoader();</div><div class="line">		StringBuilder printMessage = <span class="keyword">new</span> StringBuilder();</div><div class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"></div><div class="line">		<span class="keyword">for</span> (; loader != <span class="keyword">null</span>; i++, loader = loader.getParent()) &#123;</div><div class="line">			printMessage.append(shiftLeft(TAB, i)).append(loader.getClass().getName()).append(NEW_LINE);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</div><div class="line">			printMessage.append(shiftLeft(TAB, i)).append(SYSTEM_CLASSLOADER_NAME).append(NEW_LINE);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		System.out.println(printMessage);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		</div><div class="line">		printClassLoader(ClassLoaderTest.class);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在来看这个程序执行的类加载过程，虚拟机启动调用的方法起始不是main方法，而是sun.launcher.LauncherHelper.checkAndLoadMain方法。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sun.launcher.LauncherHelper.checkAndLoadMain</div><div class="line">|-------sun.misc.Launcher$AppClassLoader.loadClass(ClassLoaderTest.class)</div></pre></td></tr></table></figure></p>
<p>在这里初始化Ext类加载器，Sys类加载器，将Sys类加载器赋予ContextClassLoader，并且通过Sys类加载器加载ClassLoaderTest.class。所以代码打印的如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sun.misc.Launcher$AppClassLoader</div><div class="line">    sun.misc.Launcher$ExtClassLoader</div><div class="line">        bootClassLoader</div></pre></td></tr></table></figure></p>
<p>从这里我们也可以看到这种委派关系。ClassLoaderTest类通过sun.misc.Launcher$AppClassLoader加载，而sun.misc.Launcher$AppClassLoader的父亲是sun.misc.Launcher$ExtClassLoader。而sun.misc.Launcher$AppClassLoader和sun.misc.Launcher$ExtClassLoader本身则是由bootClassLoader加载。这就是默认的双亲委派机制。从这里也能看出虚拟机不不是直接调用了我们的main方法。</p>
<h2 id="new加载过程"><a href="#new加载过程" class="headerlink" title="new加载过程"></a>new加载过程</h2><p>在虚拟机分配实例对象的时候，需要先找到对应Class在内存表示的对象，即<strong> Klass </strong>。需要注意的是我们平时看到的class关键字引用的Class对象，在虚拟机表示的是<strong> InstanceMirrorKlass </strong>，所以这个Klass不是Class在内存的表示，下面是虚拟机调用new指令执行的虚拟机内部代码：<br><figure class="highlight"><table><tr><td class="code"><pre><div class="line">hotspot\src\cpu\x86\vm\templateTable_x86_64.cpp:</div><div class="line"></div><div class="line">void TemplateTable::_new() &#123;</div><div class="line">  transition(vtos, atos);</div><div class="line">  __ get_unsigned_2_byte_index_at_bcp(rdx, 1);</div><div class="line">  Label slow_case;</div><div class="line">  Label done;</div><div class="line">  Label initialize_header;</div><div class="line">  Label initialize_object; // including clearing the fields</div><div class="line">  Label allocate_shared;</div><div class="line"></div><div class="line">  __ get_cpool_and_tags(rsi, rax);</div><div class="line">  // Make sure the class we're about to instantiate has been resolved.</div><div class="line">  // This is done before loading InstanceKlass to be consistent with the order</div><div class="line">  // how Constant Pool is updated (see ConstantPool::klass_at_put)</div><div class="line">  const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();</div><div class="line">  __ cmpb(Address(rax, rdx, Address::times_1, tags_offset),</div><div class="line">          JVM_CONSTANT_Class);</div><div class="line">  __ jcc(Assembler::notEqual, slow_case);</div><div class="line"></div><div class="line">  // get InstanceKlass</div><div class="line">  __ movptr(rsi, Address(rsi, rdx,</div><div class="line">            Address::times_8, sizeof(ConstantPool)));</div><div class="line"></div><div class="line">  // make sure klass is initialized &amp; doesn't have finalizer</div><div class="line">  // make sure klass is fully initialized</div><div class="line">  __ cmpb(Address(rsi,</div><div class="line">                  InstanceKlass::init_state_offset()),</div><div class="line">          InstanceKlass::fully_initialized);</div><div class="line">  __ jcc(Assembler::notEqual, slow_case);</div><div class="line"></div><div class="line">  // get instance_size in InstanceKlass (scaled to a count of bytes)</div><div class="line">  __ movl(rdx,</div><div class="line">          Address(rsi,</div><div class="line">                  Klass::layout_helper_offset()));</div><div class="line">  // test to see if it has a finalizer or is malformed in some way</div><div class="line">  __ testl(rdx, Klass::_lh_instance_slow_path_bit);</div><div class="line">  __ jcc(Assembler::notZero, slow_case);</div><div class="line"></div><div class="line">  // Allocate the instance</div><div class="line">  // 1) Try to allocate in the TLAB</div><div class="line">  // 2) if fail and the object is large allocate in the shared Eden</div><div class="line">  // 3) if the above fails (or is not applicable), go to a slow case</div><div class="line">  // (creates a new TLAB, etc.)</div><div class="line"></div><div class="line">  const bool allow_shared_alloc =</div><div class="line">    Universe::heap()-&gt;supports_inline_contig_alloc() &amp;&amp; !CMSIncrementalMode;</div><div class="line"></div><div class="line">  if (UseTLAB) &#123;</div><div class="line">    __ movptr(rax, Address(r15_thread, in_bytes(JavaThread::tlab_top_offset())));</div><div class="line">    __ lea(rbx, Address(rax, rdx, Address::times_1));</div><div class="line">    __ cmpptr(rbx, Address(r15_thread, in_bytes(JavaThread::tlab_end_offset())));</div><div class="line">    __ jcc(Assembler::above, allow_shared_alloc ? allocate_shared : slow_case);</div><div class="line">    __ movptr(Address(r15_thread, in_bytes(JavaThread::tlab_top_offset())), rbx);</div><div class="line">    if (ZeroTLAB) &#123;</div><div class="line">      // the fields have been already cleared</div><div class="line">      __ jmp(initialize_header);</div><div class="line">    &#125; else &#123;</div><div class="line">      // initialize both the header and fields</div><div class="line">      __ jmp(initialize_object);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // Allocation in the shared Eden, if allowed.</div><div class="line">  //</div><div class="line">  // rdx: instance size in bytes</div><div class="line">  if (allow_shared_alloc) &#123;</div><div class="line">    __ bind(allocate_shared);</div><div class="line"></div><div class="line">    ExternalAddress top((address)Universe::heap()-&gt;top_addr());</div><div class="line">    ExternalAddress end((address)Universe::heap()-&gt;end_addr());</div><div class="line"></div><div class="line">    const Register RtopAddr = rscratch1;</div><div class="line">    const Register RendAddr = rscratch2;</div><div class="line"></div><div class="line">    __ lea(RtopAddr, top);</div><div class="line">    __ lea(RendAddr, end);</div><div class="line">    __ movptr(rax, Address(RtopAddr, 0));</div><div class="line"></div><div class="line">    // For retries rax gets set by cmpxchgq</div><div class="line">    Label retry;</div><div class="line">    __ bind(retry);</div><div class="line">    __ lea(rbx, Address(rax, rdx, Address::times_1));</div><div class="line">    __ cmpptr(rbx, Address(RendAddr, 0));</div><div class="line">    __ jcc(Assembler::above, slow_case);</div><div class="line"></div><div class="line">    // Compare rax with the top addr, and if still equal, store the new</div><div class="line">    // top addr in rbx at the address of the top addr pointer. Sets ZF if was</div><div class="line">    // equal, and clears it otherwise. Use lock prefix for atomicity on MPs.</div><div class="line">    //</div><div class="line">    // rax: object begin</div><div class="line">    // rbx: object end</div><div class="line">    // rdx: instance size in bytes</div><div class="line">    if (os::is_MP()) &#123;</div><div class="line">      __ lock();</div><div class="line">    &#125;</div><div class="line">    __ cmpxchgptr(rbx, Address(RtopAddr, 0));</div><div class="line"></div><div class="line">    // if someone beat us on the allocation, try again, otherwise continue</div><div class="line">    __ jcc(Assembler::notEqual, retry);</div><div class="line"></div><div class="line">    __ incr_allocated_bytes(r15_thread, rdx, 0);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (UseTLAB || Universe::heap()-&gt;supports_inline_contig_alloc()) &#123;</div><div class="line">    // The object is initialized before the header.  If the object size is</div><div class="line">    // zero, go directly to the header initialization.</div><div class="line">    __ bind(initialize_object);</div><div class="line">    __ decrementl(rdx, sizeof(oopDesc));</div><div class="line">    __ jcc(Assembler::zero, initialize_header);</div><div class="line"></div><div class="line">    // Initialize object fields</div><div class="line">    __ xorl(rcx, rcx); // use zero reg to clear memory (shorter code)</div><div class="line">    __ shrl(rdx, LogBytesPerLong);  // divide by oopSize to simplify the loop</div><div class="line">    &#123;</div><div class="line">      Label loop;</div><div class="line">      __ bind(loop);</div><div class="line">      __ movq(Address(rax, rdx, Address::times_8,</div><div class="line">                      sizeof(oopDesc) - oopSize),</div><div class="line">              rcx);</div><div class="line">      __ decrementl(rdx);</div><div class="line">      __ jcc(Assembler::notZero, loop);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // initialize object header only.</div><div class="line">    __ bind(initialize_header);</div><div class="line">    if (UseBiasedLocking) &#123;</div><div class="line">      __ movptr(rscratch1, Address(rsi, Klass::prototype_header_offset()));</div><div class="line">      __ movptr(Address(rax, oopDesc::mark_offset_in_bytes()), rscratch1);</div><div class="line">    &#125; else &#123;</div><div class="line">      __ movptr(Address(rax, oopDesc::mark_offset_in_bytes()),</div><div class="line">               (intptr_t) markOopDesc::prototype()); // header (address 0x1)</div><div class="line">    &#125;</div><div class="line">    __ xorl(rcx, rcx); // use zero reg to clear memory (shorter code)</div><div class="line">    __ store_klass_gap(rax, rcx);  // zero klass gap for compressed oops</div><div class="line">    __ store_klass(rax, rsi);      // store klass last</div><div class="line"></div><div class="line">    &#123;</div><div class="line">      SkipIfEqual skip(_masm, &amp;DTraceAllocProbes, false);</div><div class="line">      // Trigger dtrace event for fastpath</div><div class="line">      __ push(atos); // save the return value</div><div class="line">      __ call_VM_leaf(</div><div class="line">           CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc), rax);</div><div class="line">      __ pop(atos); // restore the return value</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    __ jmp(done);</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  // slow case</div><div class="line">  __ bind(slow_case);</div><div class="line">  __ get_constant_pool(c_rarg1);</div><div class="line">  __ get_unsigned_2_byte_index_at_bcp(c_rarg2, 1);</div><div class="line">  call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), c_rarg1, c_rarg2);  //&lt;==重点看这里</div><div class="line">  __ verify_oop(rax);</div><div class="line"></div><div class="line">  // continue</div><div class="line">  __ bind(done);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>前面都是内存分配，这里我们先不关心，重点看标注的。<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::<span class="number">_</span><span class="keyword">new</span>), c_rarg1, c_rarg2);  <span class="comment">//&lt;==重点看这里</span></div></pre></td></tr></table></figure></p>
<p>这段代码的具体实现如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\interpreter\interpreterRuntime.cpp:</div><div class="line"></div><div class="line">IRT_ENTRY(<span class="keyword">void</span>, InterpreterRuntime::<span class="number">_</span><span class="keyword">new</span>(JavaThread* thread, ConstantPool* pool, <span class="keyword">int</span> index))</div><div class="line">  Klass* k_oop = pool-&gt;klass_at(index, CHECK); &lt;==重点在这里</div><div class="line">  instanceKlassHandle klass (THREAD, k_oop);</div><div class="line"></div><div class="line">  <span class="comment">// Make sure we are not instantiating an abstract klass</span></div><div class="line">  klass-&gt;check_valid_for_instantiation(<span class="literal">true</span>, CHECK);</div><div class="line"></div><div class="line">  <span class="comment">// Make sure klass is initialized</span></div><div class="line">  klass-&gt;initialize(CHECK);</div><div class="line"></div><div class="line">  <span class="comment">// At this point the class may not be fully initialized</span></div><div class="line">  <span class="comment">// because of recursive initialization. If it is fully</span></div><div class="line">  <span class="comment">// initialized &amp; has_finalized is not set, we rewrite</span></div><div class="line">  <span class="comment">// it into its fast version (Note: no locking is needed</span></div><div class="line">  <span class="comment">// here since this is an atomic byte write and can be</span></div><div class="line">  <span class="comment">// done more than once).</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// Note: In case of classes with has_finalized we don't</span></div><div class="line">  <span class="comment">//       rewrite since that saves us an extra check in</span></div><div class="line">  <span class="comment">//       the fast version which then would call the</span></div><div class="line">  <span class="comment">//       slow version anyway (and do a call back into</span></div><div class="line">  <span class="comment">//       Java).</span></div><div class="line">  <span class="comment">//       If we have a breakpoint, then we don't rewrite</span></div><div class="line">  <span class="comment">//       because the _breakpoint bytecode would be lost.</span></div><div class="line">  oop obj = klass-&gt;allocate_instance(CHECK);</div><div class="line">  thread-&gt;set_vm_result(obj);</div><div class="line">IRT_END</div></pre></td></tr></table></figure></p>
<p>我们重点看加载class过程其他先不看。<br><figure class="highlight"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\oops\constantPool.hpp:</div><div class="line"></div><div class="line">  Klass* klass_at(int which, TRAPS) &#123;</div><div class="line">    constantPoolHandle h_this(THREAD, this);</div><div class="line">    return klass_at_impl(h_this, which, CHECK_NULL);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">hotspot\src\share\vm\oops\constantPool.cpp:</div><div class="line">Klass* ConstantPool::klass_at_impl(constantPoolHandle this_oop, int which, TRAPS) &#123;</div><div class="line">  // A resolved constantPool entry will contain a Klass*, otherwise a Symbol*.</div><div class="line">  // It is not safe to rely on the tag bit's here, since we don't have a lock, and the entry and</div><div class="line">  // tag is not updated atomicly.</div><div class="line"></div><div class="line">  CPSlot entry = this_oop-&gt;slot_at(which);                         //先检查缓存是否包含对应的class对象</div><div class="line">  if (entry.is_resolved()) &#123;      //CPSlot在链接的时候初始化，class的加载有两个状态表示已经解析和没有解析</div><div class="line">    assert(entry.get_klass()-&gt;is_klass(), "must be");      //解析可以理解为有没有在指定的类加载器加载class</div><div class="line">    // Already resolved - return entry.</div><div class="line">    return entry.get_klass();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // Acquire lock on constant oop while doing update. After we get the lock, we check if another object</div><div class="line">  // already has updated the object</div><div class="line">  assert(THREAD-&gt;is_Java_thread(), "must be a Java thread");</div><div class="line">  bool do_resolve = false;</div><div class="line">  bool in_error = false;</div><div class="line"></div><div class="line">  // Create a handle for the mirror. This will preserve the resolved class</div><div class="line">  // until the loader_data is registered.</div><div class="line">  Handle mirror_handle;</div><div class="line"></div><div class="line">  Symbol* name = NULL;</div><div class="line">  Handle       loader;</div><div class="line">  &#123;  MonitorLockerEx ml(this_oop-&gt;lock());</div><div class="line"></div><div class="line">    if (this_oop-&gt;tag_at(which).is_unresolved_klass()) &#123;</div><div class="line">      if (this_oop-&gt;tag_at(which).is_unresolved_klass_in_error()) &#123;</div><div class="line">        in_error = true;</div><div class="line">      &#125; else &#123;</div><div class="line">        do_resolve = true;</div><div class="line">        name   = this_oop-&gt;unresolved_klass_at(which);</div><div class="line">        loader = Handle(THREAD, this_oop-&gt;pool_holder()-&gt;class_loader());   //从调用的对象获取加载器</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125; // unlocking constantPool</div><div class="line"></div><div class="line"></div><div class="line">  // The original attempt to resolve this constant pool entry failed so find the</div><div class="line">  // original error and throw it again (JVMS 5.4.3).</div><div class="line">  if (in_error) &#123;</div><div class="line">    Symbol* error = SystemDictionary::find_resolution_error(this_oop, which);</div><div class="line">    guarantee(error != (Symbol*)NULL, "tag mismatch with resolution error table");</div><div class="line">    ResourceMark rm;</div><div class="line">    // exception text will be the class name</div><div class="line">    const char* className = this_oop-&gt;unresolved_klass_at(which)-&gt;as_C_string();</div><div class="line">    THROW_MSG_0(error, className);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (do_resolve) &#123;</div><div class="line">    // this_oop must be unlocked during resolve_or_fail</div><div class="line">    oop protection_domain = this_oop-&gt;pool_holder()-&gt;protection_domain();</div><div class="line">    Handle h_prot (THREAD, protection_domain);</div><div class="line">    Klass* k_oop = SystemDictionary::resolve_or_fail(name, loader, h_prot, true, THREAD);  //这里就是真正加载class的地方，返回对应的Klass对象。需要重点注意的是loader</div><div class="line">    KlassHandle k;</div><div class="line">    if (!HAS_PENDING_EXCEPTION) &#123;</div><div class="line">      k = KlassHandle(THREAD, k_oop);</div><div class="line">      // preserve the resolved klass.</div><div class="line">      mirror_handle = Handle(THREAD, k_oop-&gt;java_mirror());</div><div class="line">      // Do access check for klasses</div><div class="line">      verify_constant_pool_resolve(this_oop, k, THREAD);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Failed to resolve class. We must record the errors so that subsequent attempts</div><div class="line">    // to resolve this constant pool entry fail with the same error (JVMS 5.4.3).</div><div class="line">    if (HAS_PENDING_EXCEPTION) &#123;</div><div class="line">      ResourceMark rm;</div><div class="line">      Symbol* error = PENDING_EXCEPTION-&gt;klass()-&gt;name();</div><div class="line"></div><div class="line">      bool throw_orig_error = false;</div><div class="line">      &#123;</div><div class="line">        MonitorLockerEx ml(this_oop-&gt;lock());</div><div class="line"></div><div class="line">        // some other thread has beaten us and has resolved the class.</div><div class="line">        if (this_oop-&gt;tag_at(which).is_klass()) &#123;</div><div class="line">          CLEAR_PENDING_EXCEPTION;</div><div class="line">          entry = this_oop-&gt;resolved_klass_at(which);</div><div class="line">          return entry.get_klass();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (!PENDING_EXCEPTION-&gt;</div><div class="line">              is_a(SystemDictionary::LinkageError_klass())) &#123;</div><div class="line">          // Just throw the exception and don't prevent these classes from</div><div class="line">          // being loaded due to virtual machine errors like StackOverflow</div><div class="line">          // and OutOfMemoryError, etc, or if the thread was hit by stop()</div><div class="line">          // Needs clarification to section 5.4.3 of the VM spec (see 6308271)</div><div class="line">        &#125;</div><div class="line">        else if (!this_oop-&gt;tag_at(which).is_unresolved_klass_in_error()) &#123;</div><div class="line">          SystemDictionary::add_resolution_error(this_oop, which, error);</div><div class="line">          this_oop-&gt;tag_at_put(which, JVM_CONSTANT_UnresolvedClassInError);</div><div class="line">        &#125; else &#123;</div><div class="line">          // some other thread has put the class in error state.</div><div class="line">          error = SystemDictionary::find_resolution_error(this_oop, which);</div><div class="line">          assert(error != NULL, "checking");</div><div class="line">          throw_orig_error = true;</div><div class="line">        &#125;</div><div class="line">      &#125; // unlocked</div><div class="line"></div><div class="line">      if (throw_orig_error) &#123;</div><div class="line">        CLEAR_PENDING_EXCEPTION;</div><div class="line">        ResourceMark rm;</div><div class="line">        const char* className = this_oop-&gt;unresolved_klass_at(which)-&gt;as_C_string();</div><div class="line">        THROW_MSG_0(error, className);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (TraceClassResolution &amp;&amp; !k()-&gt;oop_is_array()) &#123;</div><div class="line">      // skip resolving the constant pool so that this code get's</div><div class="line">      // called the next time some bytecodes refer to this class.</div><div class="line">      ResourceMark rm;</div><div class="line">      int line_number = -1;</div><div class="line">      const char * source_file = NULL;</div><div class="line">      if (JavaThread::current()-&gt;has_last_Java_frame()) &#123;</div><div class="line">        // try to identify the method which called this function.</div><div class="line">        vframeStream vfst(JavaThread::current());</div><div class="line">        if (!vfst.at_end()) &#123;</div><div class="line">          line_number = vfst.method()-&gt;line_number_from_bci(vfst.bci());</div><div class="line">          Symbol* s = vfst.method()-&gt;method_holder()-&gt;source_file_name();</div><div class="line">          if (s != NULL) &#123;</div><div class="line">            source_file = s-&gt;as_C_string();</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      if (k() != this_oop-&gt;pool_holder()) &#123;</div><div class="line">        // only print something if the classes are different</div><div class="line">        if (source_file != NULL) &#123;</div><div class="line">          tty-&gt;print("RESOLVE %s %s %s:%d\n",</div><div class="line">                     this_oop-&gt;pool_holder()-&gt;external_name(),</div><div class="line">                     InstanceKlass::cast(k())-&gt;external_name(), source_file, line_number);</div><div class="line">        &#125; else &#123;</div><div class="line">          tty-&gt;print("RESOLVE %s %s\n",</div><div class="line">                     this_oop-&gt;pool_holder()-&gt;external_name(),</div><div class="line">                     InstanceKlass::cast(k())-&gt;external_name());</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      return k();</div><div class="line">    &#125; else &#123;</div><div class="line">      MonitorLockerEx ml(this_oop-&gt;lock());</div><div class="line">      // Only updated constant pool - if it is resolved.</div><div class="line">      do_resolve = this_oop-&gt;tag_at(which).is_unresolved_klass();</div><div class="line">      if (do_resolve) &#123;</div><div class="line">        ClassLoaderData* this_key = this_oop-&gt;pool_holder()-&gt;class_loader_data();</div><div class="line">        this_key-&gt;record_dependency(k(), CHECK_NULL); // Can throw OOM</div><div class="line">        this_oop-&gt;klass_at_put(which, k());</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  entry = this_oop-&gt;resolved_klass_at(which);</div><div class="line">  assert(entry.is_resolved() &amp;&amp; entry.get_klass()-&gt;is_klass(), "must be resolved at this point");</div><div class="line">  return entry.get_klass();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上的代码很简单，需要重点注意的是loader的指定，我们这里可以看到loader的加载具有继承性，也就是说A加载的B，那么B的加载器就是A的加载器。<br>通过上面的代码，我们知道loader1加载了A类，那么A执行了B的加载，那么B的加载器为loader1。B的加载符合loader1的规范。</p>
<h2 id="ClassLoader-loadClass加载过程"><a href="#ClassLoader-loadClass加载过程" class="headerlink" title="ClassLoader.loadClass加载过程"></a>ClassLoader.loadClass加载过程</h2><p>下面我们看看通过ClassLoader.loadClass加载的过程，一般我们自定义加载器最终继承的都是ClassLoader类。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</div><div class="line">    <span class="keyword">throws</span> ClassNotFoundException</div><div class="line">&#123;</div><div class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</div><div class="line">        <span class="comment">// First, check if the class has already been loaded</span></div><div class="line">        Class&lt;?&gt; c = findLoadedClass(name);</div><div class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</div><div class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    c = findBootstrapClassOrNull(name);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></div><div class="line">                <span class="comment">// from the non-null parent class loader</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></div><div class="line">                <span class="comment">// to find the class.</span></div><div class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</div><div class="line">                c = findClass(name);</div><div class="line"></div><div class="line">                <span class="comment">// this is the defining class loader; record the stats</span></div><div class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</div><div class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</div><div class="line">                sun.misc.PerfCounter.getFindClasses().increment();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (resolve) &#123;</div><div class="line">            resolveClass(c);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> c;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们看看加载的步骤：</p>
<ol>
<li>为了线程安全先要把指定的类加锁</li>
<li>由于可能多个线程加载同一个类，加锁后先检查一下是否已经加载了，如果已经加载，就把这个对象作为后续处理</li>
<li>先检查parent是已经加载，如果parent已经加载，就把这个对象作为后续处理，否则继续</li>
<li>从Bootstrap类加载器检查是否已经加载指定的类，如果已经加载，就把这个对象作为后续处理，否则继续</li>
<li>如果还没有找到，那么调用findClass方法，这个也是我们自己编写类加载器需要覆盖的方法，做自己的业务处理</li>
</ol>
<p>下面我么拿sys类加载器举个例子</p>
<h3 id="sun-misc-Launcher-AppClassLoader-类加载过程"><a href="#sun-misc-Launcher-AppClassLoader-类加载过程" class="headerlink" title="sun.misc.Launcher$AppClassLoader 类加载过程"></a>sun.misc.Launcher$AppClassLoader 类加载过程</h3><p>sun.misc.Launcher$AppClassLoader 继承于java.net.URLClassLoader。 系统通过sys加载器明确通过loadClass加载ClassLoaderTest类后，看看他的loadClass实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * Override loadClass so we can checkPackageAccess.</div><div class="line">  */</div><div class="line"> <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</div><div class="line">     <span class="keyword">throws</span> ClassNotFoundException</div><div class="line"> &#123;</div><div class="line">     <span class="keyword">int</span> i = name.lastIndexOf(<span class="string">'.'</span>);</div><div class="line">     <span class="keyword">if</span> (i != -<span class="number">1</span>) &#123;</div><div class="line">         SecurityManager sm = System.getSecurityManager();</div><div class="line">         <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</div><div class="line">             sm.checkPackageAccess(name.substring(<span class="number">0</span>, i));</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (ucp.knownToNotExist(name)) &#123;</div><div class="line">         <span class="comment">// The class of the given name is not found in the parent</span></div><div class="line">         <span class="comment">// class loader as well as its local URLClassPath.</span></div><div class="line">         <span class="comment">// Check if this class has already been defined dynamically;</span></div><div class="line">         <span class="comment">// if so, return the loaded class; otherwise, skip the parent</span></div><div class="line">         <span class="comment">// delegation and findClass.</span></div><div class="line">         Class&lt;?&gt; c = findLoadedClass(name);</div><div class="line">         <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</div><div class="line">             <span class="keyword">if</span> (resolve) &#123;</div><div class="line">                 resolveClass(c);</div><div class="line">             &#125;</div><div class="line">             <span class="keyword">return</span> c;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">return</span> (<span class="keyword">super</span>.loadClass(name, resolve));</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>我们看看步骤：</p>
<ol>
<li>安全检查，这里不关心，继续</li>
<li>ucp.knownToNotExist(name)目前没有实现，继续往下</li>
<li><p>调用URLClassLoader.loadClass</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</div><div class="line">    <span class="keyword">throws</span> ClassNotFoundException</div><div class="line">&#123;</div><div class="line">    <span class="comment">// First check if we have permission to access the package. This</span></div><div class="line">    <span class="comment">// should go away once we've added support for exported packages.</span></div><div class="line">    SecurityManager sm = System.getSecurityManager();</div><div class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> i = name.lastIndexOf(<span class="string">'.'</span>);</div><div class="line">        <span class="keyword">if</span> (i != -<span class="number">1</span>) &#123;</div><div class="line">            sm.checkPackageAccess(name.substring(<span class="number">0</span>, i));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name, resolve);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>调用ClassLoader.loadClass，后续步骤和上一节一样</p>
</li>
<li>为了线程安全先要把指定的类加锁</li>
<li>由于可能多个线程加载同一个类，加锁后先检查一下是否已经加载了，如果已经加载，就把这个对象作为后续处理</li>
<li>先检查parent是已经加载，如果parent已经加载，就把这个对象作为后续处理，否则继续</li>
<li>从Bootstrap类加载器检查是否已经加载指定的类，如果已经加载，就把这个对象作为后续处理，否则继续</li>
<li><p>如果还没有找到，那么调用findClass方法，URLClassLoader类覆盖了这个方法，看实现，安全不关心，忽略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(<span class="keyword">final</span> String name)</div><div class="line">    <span class="keyword">throws</span> ClassNotFoundException</div><div class="line">&#123;</div><div class="line">    <span class="keyword">final</span> Class&lt;?&gt; result;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        result = AccessController.doPrivileged(</div><div class="line">            <span class="keyword">new</span> PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123;</div><div class="line">                <span class="keyword">public</span> Class&lt;?&gt; run() <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">                    String path = name.replace(<span class="string">'.'</span>, <span class="string">'/'</span>).concat(<span class="string">".class"</span>);</div><div class="line">                    Resource res = ucp.getResource(path, <span class="keyword">false</span>);</div><div class="line">                    <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            <span class="keyword">return</span> defineClass(name, res);</div><div class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name, e);</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;, acc);</div><div class="line">    &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</div><div class="line">        <span class="keyword">throw</span> (ClassNotFoundException) pae.getException();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>通过后续的代码追踪，调用最终java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass1(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len,</div><div class="line">                                     ProtectionDomain pd, String source);</div></pre></td></tr></table></figure>
</li>
<li><p>虚拟机根据传入的字节流，将其解释成虚拟机内部表示的InstanceMirrorKlass对象。也就是我们的class对象，需要注意的，虚拟机会检查包是否为java开头，如果是将处错误。也就是说java开头的类只允许Bootstrap加载。</p>
</li>
</ol>
<p>至此，一般的加载过程就结束了。sys加载器首先委派父加载器加载，如果父加载器没有加载到，那么从Bootstrap类加载器中查找，如果还是没有找到，那么就从自定义的类加载器中加载。指定加载的对象的加载器也就是我们自定义的加载器。</p>
<p>那么如果上层加载器如果想访问低级加载器的类，那么怎么办，如java提供的spi机制，spi标准类由Bootstrap加载，但spi却需要访问sys加载器加载的类，由于Bootstrap加载器无法加载具体的实现，只能交于sys加载器加载，这里引申出了contextClassLoader。这种加载器加载不再遵守双亲委派加载规范。</p>
<h2 id="Tomcat类加载机制"><a href="#Tomcat类加载机制" class="headerlink" title="Tomcat类加载机制"></a>Tomcat类加载机制</h2><p>这里不涉及.</p>
<h2 id="ContextClassLoader"><a href="#ContextClassLoader" class="headerlink" title="ContextClassLoader"></a>ContextClassLoader</h2><p>在标准加载体系中，上级加载器无法使用下级加载器的资源。对于一些上层加载器需要访问下层加载器而言，这是一个不可能的行为。Java为了解决这个问题，引申了ContextClassLoader，这个ContextClassLoader是和线程绑定在一起的，默认启动的main线程的ContextClassLoader就是sys加载器。父加载器通过访问Thread.getContextClassLoader()访问ContextClassLoader加载器。线程之间的ContextClassLoader具有传递性。</p>
<h2 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName"></a>Class.forName</h2><p>此类加载的方式通过指定加载器进行加载，有两个方法进行指定类的加载：</p>
<ol>
<li>默认通过调用者的类加载器进行加载(forName(String className))<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@CallerSensitive</span>                                           <span class="comment">//增加了这个新的注解，可以获取调用者的类</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</div><div class="line">            <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</div><div class="line">    <span class="keyword">return</span> forName0(className, <span class="keyword">true</span>, ClassLoader.getClassLoader(caller), caller);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>先看一个反射工具类，sun.reflect.Reflection可以帮忙获取调用者的类信息。重点关注getCallerClass方法<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@CallerSensitive</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; getCallerClass();</div></pre></td></tr></table></figure></p>
<p>这是一个本地方法，主要获取调用者的类信息，这个属于私有实现，虚拟机内部在解析类文件的时候只允许sys加载器，sys加载器和匿名加载器加载的类调用这个方法。<br>从forName的默认实现，我们可以看到加载器采用的调用类的加载器。比如我们在jdbc中通过forName加载驱动具体实现类，我们使用的就是sys加载器(或应用自定义的加载器)。在新的版本中，我们不需要使用这种实现，通过spi框架进行加载具体实现。</p>
<ol>
<li>通过指定加载器加载forName(String name, boolean initialize,ClassLoader loader)<br>这个加载方式指定了加载器进行加载，根据需要进行加载，而不是采用默认的双亲加载方式。</li>
</ol>
<h2 id="SPI框架加载体系"><a href="#SPI框架加载体系" class="headerlink" title="SPI框架加载体系"></a>SPI框架加载体系</h2><p>spi框架将服务和实现具体拆分开，定义借口不需要关心实现，jdk提供的服务接口通过Bootstrap进行加载，那么Bootstrap如果需要访问具体实现，那么虚拟机不能访问指定的类资源。jdk采用了ContextClassLoader加载机制。使得在当前线程通过访问ContextClassLoader来进行加载系统加载器进行加载指定的类，从而达到不同加载器的按需访问。我们看看jdbc4的mysql spi实现。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">DriverManager.getConnection(url)   <span class="comment">//直接使用即可，jdbc4通过spi加载</span></div></pre></td></tr></table></figure></p>
<h2 id="一种类加载机制介绍"><a href="#一种类加载机制介绍" class="headerlink" title="一种类加载机制介绍"></a>一种类加载机制介绍</h2><p>从上面我们知道了类加载在做组件隔离是一个很重的技术之一,它可以让虚拟机运行的组件像一个个的箱子一样独立的存在<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">               ----------------</div><div class="line">              |                |</div><div class="line">              | AppClassLoader |</div><div class="line">              |                |</div><div class="line">               ----------------</div><div class="line">                     /|\</div><div class="line">                      |</div><div class="line">       ---------------</div><div class="line">      |</div><div class="line">      |</div><div class="line"> ------------                  --------------</div><div class="line">|            |                |              |</div><div class="line">| Api loader | &lt;------------- | Stage loader |</div><div class="line">|            |                |              |</div><div class="line"> ------------                  --------------</div><div class="line">     /|\                             | </div><div class="line">      |                              |</div><div class="line"> ------------------                  |</div><div class="line">|                  |                 |</div><div class="line">| Container loader | -----------------</div><div class="line">|                  |</div><div class="line"> ------------------</div></pre></td></tr></table></figure></p>
<p>这是StreamSets实现的组件加载的类加载体系结构.StreamSets是一种dataflow产品,其将其平台抽象为Container和stage,以及api.<br>1.api是抽象的数据流的公共包,由Api loader加载,这个只有一个实例<br>2.container是streamsets datacollector的运行公共包,datacollector运行时的类由其加载.这个也只有一个实例<br>3.stage表明每一个抽象的数据源等的具体实现包,每一个数据源和一些组件都对应一个loader.这个loader可能由很多</p>
<p>这个体系的加载将公共约定,运行时,具体实现完美的分离了.他们的优先级为stage&gt;api&gt;app,container&gt;api&gt;app,之所以由两线的优先级是因为container和stage是委派关系.系统启动的时候会由虚拟机自带的加载器加载启动类,启动类建立三个组件的类加载体系,交由Container loader运行加载公共类,由每一个stage loader加载具体的实现.</p>
<p>从上面的图中,stage loader每一个组件都是隔离的,除了依赖api loader公共api.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.虚拟机自带的加载器优先级为Bootstrap类加载器&gt;Ext&gt;Sys.也就是说父加载器的优先级高,会优先加载,而在现实中这却不是我们所需要的,所以会设计出自己的类加载器.<br>2.谁加载谁负责,由一个类加载器加载的类后续加载的类都是由此加载器加载.<br>3.ContextClassLoader支持在线程间传递.<br>4.使用类加载器可以模块化我们的系统设计.<br>5.虚拟机的类加载是懒加载模式,遇到了才会解析加载,按需加载.<br>6.我们确认一个类是否相同需要注意,并不是按照名称匹配,而是要加上类加载器和安全类加载器相同,才会认为是相同的类,也就是说即使相同的类不同的加载器加载也是不一样的.</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/09/23/jvm/classloader/" class="archive-article-date">
  	<time datetime="2016-09-23T03:30:40.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-09-23</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/JAVA/">JAVA</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
    <a href="/2016/10/10/jvm/openjdk7-make-debug/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="icon-circle-left"></i>
      <div class="article-nav-title">
        
          OpenJDK 7 编译调试
        
      </div>
    </a>
  
  
    <a href="/2016/09/23/jvm/java-xx-command-NativeMemoryTracking/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Java 命令行---（NativeMemoryTracking）</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>




<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
	    <a class="jiathis_button_twitter"></a>
	    <a class="jiathis_button_plus"></a> 
	    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="jvm/classloader" data-title="JVM ClassLoader机制" data-url="http://yoursite.com/2016/09/23/jvm/classloader/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>





      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 Corner XX
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/"
	}
</script>

<script src="/./main.js"></script>





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/Hadoop-Eagle-Storm/" style="font-size: 10px;">Hadoop Eagle Storm</a> <a href="/tags/Hadoop-Hdfs/" style="font-size: 10px;">Hadoop Hdfs</a> <a href="/tags/Hadoop-Yran/" style="font-size: 10px;">Hadoop Yran</a> <a href="/tags/Hbase/" style="font-size: 16.67px;">Hbase</a> <a href="/tags/Hdfs/" style="font-size: 13.33px;">Hdfs</a> <a href="/tags/JVM/" style="font-size: 20px;">JVM</a> <a href="/tags/Kernel/" style="font-size: 13.33px;">Kernel</a> <a href="/tags/OpenJDK/" style="font-size: 13.33px;">OpenJDK</a> <a href="/tags/Phoenix/" style="font-size: 10px;">Phoenix</a> <a href="/tags/algorithm/" style="font-size: 16.67px;">algorithm</a> <a href="/tags/streamset/" style="font-size: 10px;">streamset</a>
    			</div>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">记录点点滴滴</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>