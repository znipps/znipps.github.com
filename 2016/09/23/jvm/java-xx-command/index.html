<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Java 命令行---XX详解 | Corner XX daily log</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="描述Java命令行的相关命令以及用法，说明等。
[Global flags]    ccstr AbortVMOnException                        =                                     &amp;#123;notproduct&amp;#125;Call fatal if this exception is thrown.  Example:">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 命令行---XX详解">
<meta property="og:url" content="http://yoursite.com/2016/09/23/jvm/java-xx-command/index.html">
<meta property="og:site_name" content="Corner XX daily log">
<meta property="og:description" content="描述Java命令行的相关命令以及用法，说明等。
[Global flags]    ccstr AbortVMOnException                        =                                     &amp;#123;notproduct&amp;#125;Call fatal if this exception is thrown.  Example:">
<meta property="og:updated_time" content="2016-10-30T01:31:30.922Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java 命令行---XX详解">
<meta name="twitter:description" content="描述Java命令行的相关命令以及用法，说明等。
[Global flags]    ccstr AbortVMOnException                        =                                     &amp;#123;notproduct&amp;#125;Call fatal if this exception is thrown.  Example:">
  
    <link rel="alternative" href="/atom.xml" title="Corner XX daily log" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.png">
  
  <script src="/style.js"></script>
</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/img/suolong.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Corner XX</a></h1>
		</hgroup>

		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="#" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/cornerxx" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">Corner XX</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="/img/suolong.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Corner XX</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/cornerxx" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        <article id="post-jvm/java-xx-command" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java 命令行---XX详解
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>描述Java命令行的相关命令以及用法，说明等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[Global flags]</div><div class="line">    ccstr AbortVMOnException                        =                                     &#123;notproduct&#125;Call fatal if this exception is thrown.  Example: java -XX:AbortVMOnException=java.lang.NullPointerException Foo</div><div class="line">    ccstr AbortVMOnExceptionMessage                 =                                     &#123;notproduct&#125;Call fatal if the exception pointed by AbortVMOnException has this message</div><div class="line">    uintx AdaptiveSizeDecrementScaleFactor          = 4                                   &#123;product&#125;Adaptive size scale down factor for shrinking</div><div class="line">    uintx AdaptiveSizeMajorGCDecayTimeScale         = 10                                  &#123;product&#125;Time scale over which major costs decay</div><div class="line">    uintx AdaptiveSizePausePolicy                   = 0                                   &#123;product&#125;Policy for changing generation size for pause goals</div><div class="line">    uintx AdaptiveSizePolicyCollectionCostMargin    = 50                                  &#123;product&#125;If collection costs are within margin, reduce both by full delta</div><div class="line">    uintx AdaptiveSizePolicyGCTimeLimitThreshold    = 5                                   &#123;develop&#125;Number of consecutive collections before gc time limit fires</div><div class="line">    uintx AdaptiveSizePolicyInitializingSteps       = 20                                  &#123;product&#125;Number of steps where heuristics is used before data is used</div><div class="line">    uintx AdaptiveSizePolicyOutputInterval          = 0                                   &#123;product&#125;Collection interval for printing information; zero means never</div><div class="line">    uintx AdaptiveSizePolicyReadyThreshold          = 5                                   &#123;develop&#125;Number of collections before the adaptive sizing is started</div><div class="line">    uintx AdaptiveSizePolicyWeight                  = 10                                  &#123;product&#125;Weight given to exponential resizing, between 0 and 100</div><div class="line">    uintx AdaptiveSizeThroughPutPolicy              = 0                                   &#123;product&#125;Policy for changing generation size for throughput goals</div><div class="line">    uintx AdaptiveTimeWeight                        = 25                                  &#123;product&#125;Weight given to time in adaptive policy, between 0 and 100</div><div class="line">     bool AdjustConcurrency                         = false                               &#123;product&#125;Call thr_setconcurrency at thread creation time to avoid LWP starvation on MP systems (for Solaris Only)</div><div class="line">     bool AggressiveOpts                            = false                               &#123;product&#125;Enable aggressive optimizations - see arguments.cpp</div><div class="line">     intx AliasLevel                                = 3                                   &#123;C2 product&#125;0 for no aliasing, 1 for oop/field/static/array split, 2 for class split, 3 for unique instances</div><div class="line">     bool AlignVector                               = true                                &#123;C2 product&#125;Perform vector store/load alignment in loop</div><div class="line">     intx AllocateInstancePrefetchLines             = 1                                   &#123;product&#125;Number of lines to prefetch ahead of instance allocation pointer</div><div class="line">     intx AllocatePrefetchDistance                  = -1                                  &#123;product&#125;Distance to prefetch ahead of allocation pointer</div><div class="line">     intx AllocatePrefetchInstr                     = 0                                   &#123;product&#125;Prefetch instruction to prefetch ahead of allocation pointer</div><div class="line">     intx AllocatePrefetchLines                     = 3                                   &#123;product&#125;Number of lines to prefetch ahead of array allocation pointer</div><div class="line">     intx AllocatePrefetchStepSize                  = 16                                  &#123;product&#125;Step size in bytes of sequential prefetch instructions</div><div class="line">     intx AllocatePrefetchStyle                     = 1                                   &#123;product&#125;0 = no prefetch, 1 = prefetch instructions for each allocation, 2 = use TLAB watermark to gate allocation prefetch, 3 = use BIS instruction on Sparc for allocation prefetch</div><div class="line">     bool AllowJNIEnvProxy                          = false                               &#123;product&#125;Allow JNIEnv proxies for jdbx</div><div class="line">     bool AllowNonVirtualCalls                      = false                               &#123;product&#125;Obey the ACC_SUPER flag and allow invokenonvirtual calls</div><div class="line">     bool AllowParallelDefineClass                  = false                               &#123;product&#125;Allow parallel defineClass requests for class loaders registering as parallel capable</div><div class="line">     bool AllowUserSignalHandlers                   = false                               &#123;product&#125;Do not complain if the application installs signal handlers (Solaris &amp; Linux only)</div><div class="line">     bool AlwaysActAsServerClassMachine             = false                               &#123;product&#125;Always act like a server-class machine</div><div class="line">     bool AlwaysCompileLoopMethods                  = false                               &#123;product&#125;When using recompilation, never interpret methods containing loops</div><div class="line">     bool AlwaysIncrementalInline                   = false                               &#123;C2 develop&#125;do all inlining incrementally</div><div class="line">     bool AlwaysLockClassLoader                     = false                               &#123;product&#125;Require the VM to acquire the class loader lock before calling loadClass() even for class loaders registering as parallel capable</div><div class="line">     bool AlwaysPreTouch                            = false                               &#123;product&#125;Force all freshly committed pages to be pre-touched</div><div class="line">     bool AlwaysRestoreFPU                          = false                               &#123;product&#125;Restore the FPU control word after every JNI call (expensive)</div><div class="line">     bool AlwaysTenure                              = false                               &#123;product&#125;Always tenure objects in eden (ParallelGC only)</div><div class="line">     bool AssertOnSuspendWaitFailure                = false                               &#123;product&#125;Assert/Guarantee on external suspend wait failure</div><div class="line">     bool AssertRangeCheckElimination               = false                               &#123;C1 develop&#125;Assert Range Check Elimination</div><div class="line">     intx AssertRepeat                              = 1                                   &#123;notproduct&#125;number of times to evaluate expression in assert (to estimate overhead); only works with -DUSE_REPEATED_ASSERTS</div><div class="line">     bool AssumeMP                                  = false                               &#123;product&#125;Instruct the VM to assume multiple processors are available</div><div class="line">     intx AutoBoxCacheMax                           = 128                                 &#123;C2 product&#125;Sets max value cached by the java.lang.Integer autobox cache</div><div class="line">    uintx AutoGCSelectPauseMillis                   = 5000                                &#123;product&#125;Automatic GC selection pause threshold in milliseconds</div><div class="line">     intx BCEATraceLevel                            = 0                                   &#123;product&#125;How much tracing to do of bytecode escape analysis estimates</div><div class="line">     intx BackEdgeThreshold                         = 100000                              &#123;pd product&#125;Interpreter Back edge threshold at which an OSR compilation is invoked</div><div class="line">     bool BackgroundCompilation                     = true                                &#123;pd product&#125;A thread requesting compilation is not blocked during compilation</div><div class="line">     bool BailoutAfterHIR                           = false                               &#123;C1 develop&#125;bailout of compilation after building of HIR</div><div class="line">     bool BailoutAfterLIR                           = false                               &#123;C1 develop&#125;bailout of compilation after building of LIR</div><div class="line">     bool BailoutOnExceptionHandlers                = false                               &#123;C1 develop&#125;bailout of compilation for methods with exception handlers</div><div class="line">     bool BailoutToInterpreterForThrows             = false                               &#123;C2 develop&#125;Compiled methods which throws/catches exceptions will be deopt and intp.</div><div class="line">    uintx BaseFootPrintEstimate                     = 268435456                           &#123;product&#125;Estimate of footprint other than Java Heap</div><div class="line">     intx BciProfileWidth                           = 2                                   &#123;develop&#125;Number of return bci&apos;s to record in ret profile</div><div class="line">     intx BiasedLockingBulkRebiasThreshold          = 20                                  &#123;product&#125;Threshold of number of revocations per type to try to rebias all objects in the heap of that type</div><div class="line">     intx BiasedLockingBulkRevokeThreshold          = 40                                  &#123;product&#125;Threshold of number of revocations per type to permanently revoke biases of all objects in the heap of that type</div><div class="line">     intx BiasedLockingDecayTime                    = 25000                               &#123;product&#125;Decay time (in milliseconds) to re-enable bulk rebiasing of a type after previous bulk rebias</div><div class="line">     intx BiasedLockingStartupDelay                 = 4000                                &#123;product&#125;Number of milliseconds to wait before enabling biased locking</div><div class="line">     intx BinarySwitchThreshold                     = 5                                   &#123;develop&#125;Minimal number of lookupswitch entries for rewriting to binary switch</div><div class="line">     bool BindCMSThreadToCPU                        = false                               &#123;diagnostic&#125;Bind CMS Thread to CPU if possible</div><div class="line">     bool BindGCTaskThreadsToCPUs                   = false                               &#123;product&#125;Bind GCTaskThreads to CPUs if possible</div><div class="line">     bool BlockLayoutByFrequency                    = true                                &#123;C2 product&#125;Use edge frequencies to drive block ordering</div><div class="line">     intx BlockLayoutMinDiamondPercentage           = 20                                  &#123;C2 product&#125;Miniumum %% of a successor (predecessor) for which block layout a will allow a fork (join) in a single chain</div><div class="line">     bool BlockLayoutRotateLoops                    = true                                &#123;C2 product&#125;Allow back branches to be fall throughs in the block layour</div><div class="line">     bool BlockOffsetArrayUseUnallocatedBlock       = false                               &#123;diagnostic&#125;Maintain _unallocated_block in BlockOffsetArray (currently applicable only to CMS collector)</div><div class="line">     bool BranchOnRegister                          = false                               &#123;C2 product&#125;Use Sparc V9 branch-on-register opcodes</div><div class="line">     intx BreakAtNode                               = 0                                   &#123;C2 notproduct&#125;Break at construction of this Node (either _idx or _debug_idx)</div><div class="line">     bool BreakAtWarning                            = false                               &#123;develop&#125;Execute breakpoint upon encountering VM warning</div><div class="line">     bool BytecodeVerificationLocal                 = false                               &#123;product&#125;Enable the Java bytecode verifier for local classes</div><div class="line">     bool BytecodeVerificationRemote                = true                                &#123;product&#125;Enable the Java bytecode verifier for remote classes</div><div class="line">     bool C1Breakpoint                              = false                               &#123;C1 develop&#125;Sets a breakpoint at entry of each compiled method</div><div class="line">     bool C1OptimizeVirtualCallProfiling            = true                                &#123;C1 product&#125;Use CHA and exact type results at call sites when updating MDOs</div><div class="line">     bool C1PatchInvokeDynamic                      = true                                &#123;C1 diagnostic&#125;Patch invokedynamic appendix not known at compile time</div><div class="line">     bool C1ProfileBranches                         = true                                &#123;C1 product&#125;Profile branches when generating code for updating MDOs</div><div class="line">     bool C1ProfileCalls                            = true                                &#123;C1 product&#125;Profile calls when generating code for updating MDOs</div><div class="line">     bool C1ProfileCheckcasts                       = true                                &#123;C1 product&#125;Profile checkcasts when generating code for updating MDOs</div><div class="line">     bool C1ProfileInlinedCalls                     = true                                &#123;C1 product&#125;Profile inlined calls when generating code for updating MDOs</div><div class="line">     bool C1ProfileVirtualCalls                     = true                                &#123;C1 product&#125;Profile virtual calls when generating code for updating MDOs</div><div class="line">     bool C1UpdateMethodData                        = true                                &#123;C1 product&#125;Update MethodData*s in Tier1-generated code</div><div class="line">     intx CIBreakAt                                 = -1                                  &#123;develop&#125;The id of compilation to break at</div><div class="line">     intx CIBreakAtOSR                              = -1                                  &#123;develop&#125;The id of osr compilation to break at</div><div class="line">     bool CICompileNatives                          = true                                &#123;develop&#125;compile native methods if supported by the compiler</div><div class="line">     bool CICompileOSR                              = true                                &#123;pd develop&#125;compile on stack replacement methods if supported by the compiler</div><div class="line">     intx CICompilerCount                           = 2                                   &#123;product&#125;Number of compiler threads to run</div><div class="line">     bool CICompilerCountPerCPU                     = false                               &#123;product&#125;1 compiler thread for log(N CPUs)</div><div class="line">     bool CICountOSR                                = false                               &#123;develop&#125;use a separate counter when assigning ids to osr compilations</div><div class="line">     intx CICrashAt                                 = -1                                  &#123;notproduct&#125;id of compilation to trigger assert in compiler thread for the purpose of testing, e.g. generation of replay data</div><div class="line">     intx CIFireOOMAt                               = -1                                  &#123;develop&#125;Fire OutOfMemoryErrors throughout CI for testing the compiler (non-negative value throws OOM after this many CI accesses in each compile)</div><div class="line">     bool CIObjectFactoryVerify                     = false                               &#123;notproduct&#125;enable potentially expensive verification in ciObjectFactory</div><div class="line">     bool CIPrintCompileQueue                       = false                               &#123;develop&#125;display the contents of the compile queue whenever a compilation is enqueued</div><div class="line">     bool CIPrintCompilerName                       = false                               &#123;develop&#125;when CIPrint is active, print the name of the active compiler</div><div class="line">     bool CIPrintMethodCodes                        = false                               &#123;develop&#125;print method bytecodes of the compiled code</div><div class="line">     bool CIPrintRequests                           = false                               &#123;develop&#125;display every request for compilation</div><div class="line">     bool CIPrintTypeFlow                           = false                               &#123;develop&#125;print the results of ciTypeFlow analysis</div><div class="line">     intx CIStart                                   = 0                                   &#123;develop&#125;The id of the first compilation to permit</div><div class="line">     intx CIStartOSR                                = 0                                   &#123;develop&#125;The id of the first osr compilation to permit (CICountOSR must be on)</div><div class="line">     intx CIStop                                    = 2147483647                          &#123;develop&#125;The id of the last compilation to permit</div><div class="line">     intx CIStopOSR                                 = 2147483647                          &#123;develop&#125;The id of the last osr compilation to permit (CICountOSR must be on)</div><div class="line">     bool CITime                                    = false                               &#123;product&#125;collect timing information for compilation</div><div class="line">     bool CITimeEach                                = false                               &#123;develop&#125;display timing information after each successful compilation</div><div class="line">     bool CITraceTypeFlow                           = false                               &#123;develop&#125;detailed per-bytecode tracing of ciTypeFlow analysis</div><div class="line">     bool CMSAbortSemantics                         = false                               &#123;product&#125;Whether abort-on-overflow semantics is implemented</div><div class="line">    uintx CMSAbortablePrecleanMinWorkPerIteration   = 100                                 &#123;product&#125;(Temporary, subject to experimentation) Nominal minimum work per abortable preclean iteration</div><div class="line">     intx CMSAbortablePrecleanWaitMillis            = 100                                 &#123;manageable&#125;(Temporary, subject to experimentation) Time that we sleep between iterations when not given enough work per iteration</div><div class="line">    uintx CMSBitMapYieldQuantum                     = 10485760                            &#123;product&#125;Bitmap operations should process at most this many bits between yields</div><div class="line">    uintx CMSBootstrapOccupancy                     = 50                                  &#123;product&#125;Percentage CMS generation occupancy at which to initiate CMS collection for bootstrapping collection stats</div><div class="line">    uintx CMSCheckInterval                          = 1000                                &#123;develop&#125;Interval in milliseconds that CMS thread checks if it should start a collection cycle</div><div class="line">     bool CMSClassUnloadingEnabled                  = true                                &#123;product&#125;Whether class unloading enabled when using CMS GC</div><div class="line">    uintx CMSClassUnloadingMaxInterval              = 0                                   &#123;product&#125;When CMS class unloading is enabled, the maximum CMS cycle count for which classes may not be unloaded</div><div class="line">     bool CMSCleanOnEnter                           = true                                &#123;product&#125;Clean-on-enter optimization for reducing number of dirty cards</div><div class="line">     bool CMSCompactWhenClearAllSoftRefs            = true                                &#123;product&#125;Compact when asked to collect CMS gen with clear_all_soft_refs()</div><div class="line">    uintx CMSConcMarkMultiple                       = 32                                  &#123;product&#125;Size (in cards) of CMS concurrent MT marking task</div><div class="line">     bool CMSConcurrentMTEnabled                    = true                                &#123;product&#125;Whether multi-threaded concurrent work enabled (effective only if ParNewGC)</div><div class="line">    uintx CMSCoordinatorYieldSleepCount             = 10                                  &#123;product&#125;Number of times the coordinator GC thread will sleep while yielding before giving up and resuming GC</div><div class="line">     intx CMSDictionaryChoice                       = 0                                   &#123;develop&#125;Use BinaryTreeDictionary as default in the CMS generation</div><div class="line">     bool CMSDumpAtPromotionFailure                 = false                               &#123;product&#125;Dump useful information about the state of the CMS old generation upon a promotion failure</div><div class="line">     bool CMSEdenChunksRecordAlways                 = true                                &#123;product&#125;Always record eden chunks used for the parallel initial mark or remark of eden</div><div class="line">    uintx CMSExpAvgFactor                           = 50                                  &#123;product&#125;Percentage (0-100) used to weigh the current sample when computing exponential averages for CMS statistics</div><div class="line">     bool CMSExtrapolateSweep                       = false                               &#123;product&#125;CMS: cushion for block demand during sweep</div><div class="line">    uintx CMSFullGCsBeforeCompaction                = 0                                   &#123;product&#125;Number of CMS full collection done before compaction if &gt; 0</div><div class="line">    uintx CMSIncrementalDutyCycle                   = 10                                  &#123;product&#125;Percentage (0-100) of CMS incremental mode duty cycle. If CMSIncrementalPacing is enabled, then this is just the initial value.</div><div class="line">    uintx CMSIncrementalDutyCycleMin                = 0                                   &#123;product&#125;Minimum percentage (0-100) of the CMS incremental duty cycle used when CMSIncrementalPacing is enabled</div><div class="line">     bool CMSIncrementalMode                        = false                               &#123;product&#125;Whether CMS GC should operate in &quot;incremental&quot; mode</div><div class="line">    uintx CMSIncrementalOffset                      = 0                                   &#123;product&#125;Percentage (0-100) by which the CMS incremental mode duty cycle is shifted to the right within the period between young GCs</div><div class="line">     bool CMSIncrementalPacing                      = true                                &#123;product&#125;Whether the CMS incremental mode duty cycle should be automatically adjusted</div><div class="line">    uintx CMSIncrementalSafetyFactor                = 10                                  &#123;product&#125;Percentage (0-100) used to add conservatism when computing the duty cycle</div><div class="line">    uintx CMSIndexedFreeListReplenish               = 4                                   &#123;product&#125;Replenish an indexed free list with this number of chunks</div><div class="line">     intx CMSInitiatingOccupancyFraction            = -1                                  &#123;product&#125;Percentage CMS generation occupancy to start a CMS collection cycle. A negative value means that CMSTriggerRatio is used</div><div class="line">    uintx CMSIsTooFullPercentage                    = 98                                  &#123;product&#125;An absolute ceiling above which CMS will always consider the unloading of classes when class unloading is enabled</div><div class="line">   double CMSLargeCoalSurplusPercent                = 0.950000                            &#123;product&#125;CMS: the factor by which to inflate estimated demand of large block sizes to prevent coalescing with an adjoining block</div><div class="line">   double CMSLargeSplitSurplusPercent               = 1.000000                            &#123;product&#125;CMS: the factor by which to inflate estimated demand of large block sizes to prevent splitting to supply demand for smaller blocks</div><div class="line">     bool CMSLoopWarn                               = false                               &#123;product&#125;Warn in case of excessive CMS looping</div><div class="line">     bool CMSMarkStackOverflowALot                  = false                               &#123;notproduct&#125;Simulate frequent marking stack / work queue overflow</div><div class="line">    uintx CMSMarkStackOverflowInterval              = 1000                                &#123;notproduct&#125;An &quot;interval&quot; counter that determines how frequently to simulate overflow; a smaller number increases frequency</div><div class="line">    uintx CMSMaxAbortablePrecleanLoops              = 0                                   &#123;product&#125;(Temporary, subject to experimentation) Maximum number of abortable preclean iterations, if &gt; 0</div><div class="line">     intx CMSMaxAbortablePrecleanTime               = 5000                                &#123;product&#125;(Temporary, subject to experimentation) Maximum time in abortable preclean (in milliseconds)</div><div class="line">    uintx CMSOldPLABMax                             = 1024                                &#123;product&#125;Maximum size of CMS gen promotion LAB caches per worker per block size</div><div class="line">    uintx CMSOldPLABMin                             = 16                                  &#123;product&#125;Minimum size of CMS gen promotion LAB caches per worker per block size</div><div class="line">    uintx CMSOldPLABNumRefills                      = 4                                   &#123;product&#125;Nominal number of refills of CMS gen promotion LAB cache per worker per block size</div><div class="line">    uintx CMSOldPLABReactivityFactor                = 2                                   &#123;product&#125;The gain in the feedback loop for on-the-fly PLAB resizing during a scavenge</div><div class="line">     bool CMSOldPLABResizeQuicker                   = false                               &#123;product&#125;React on-the-fly during a scavenge to a sudden change in block demand rate</div><div class="line">    uintx CMSOldPLABToleranceFactor                 = 4                                   &#123;product&#125;The tolerance of the phase-change detector for on-the-fly PLAB resizing during a scavenge</div><div class="line">     bool CMSOverflowEarlyRestoration               = false                               &#123;develop&#125;Restore preserved marks early</div><div class="line">     bool CMSPLABRecordAlways                       = true                                &#123;product&#125;Always record survivor space PLAB boundaries (effective only if CMSParallelSurvivorRemarkEnabled)</div><div class="line">    uintx CMSParPromoteBlocksToClaim                = 16                                  &#123;product&#125;Number of blocks to attempt to claim when refilling CMS LAB&apos;s for parallel GC</div><div class="line">     bool CMSParallelInitialMarkEnabled             = true                                &#123;product&#125;Use the parallel initial mark.</div><div class="line">     bool CMSParallelRemarkEnabled                  = true                                &#123;product&#125;Whether parallel remark enabled (only if ParNewGC)</div><div class="line">     bool CMSParallelSurvivorRemarkEnabled          = true                                &#123;product&#125;Whether parallel remark of survivor space enabled (effective only if CMSParallelRemarkEnabled)</div><div class="line">    uintx CMSPrecleanDenominator                    = 3                                   &#123;product&#125;CMSPrecleanNumerator:CMSPrecleanDenominator yields convergence ratio</div><div class="line">    uintx CMSPrecleanIter                           = 3                                   &#123;product&#125;Maximum number of precleaning iteration passes</div><div class="line">    uintx CMSPrecleanNumerator                      = 2                                   &#123;product&#125;CMSPrecleanNumerator:CMSPrecleanDenominator yields convergence ratio</div><div class="line">     bool CMSPrecleanRefLists1                      = true                                &#123;product&#125;Preclean ref lists during (initial) preclean phase</div><div class="line">     bool CMSPrecleanRefLists2                      = false                               &#123;product&#125;Preclean ref lists during abortable preclean phase</div><div class="line">     bool CMSPrecleanSurvivors1                     = false                               &#123;product&#125;Preclean survivors during (initial) preclean phase</div><div class="line">     bool CMSPrecleanSurvivors2                     = true                                &#123;product&#125;Preclean survivors during abortable preclean phase</div><div class="line">    uintx CMSPrecleanThreshold                      = 1000                                &#123;product&#125;Do not iterate again if number of dirty cards is less than this</div><div class="line">     bool CMSPrecleaningEnabled                     = true                                &#123;product&#125;Whether concurrent precleaning enabled</div><div class="line">     bool CMSPrintChunksInDump                      = false                               &#123;product&#125;In a dump enabled by CMSDumpAtPromotionFailure, include more detailed information about the free chunks</div><div class="line">     bool CMSPrintEdenSurvivorChunks                = false                               &#123;product&#125;Print the eden and the survivor chunks used for the parallel initial mark or remark of the eden/survivor spaces</div><div class="line">     bool CMSPrintObjectsInDump                     = false                               &#123;product&#125;In a dump enabled by CMSDumpAtPromotionFailure, include more detailed information about the allocated objects</div><div class="line">    uintx CMSRemarkVerifyVariant                    = 1                                   &#123;product&#125;Choose variant (1,2) of verification following remark</div><div class="line">     bool CMSReplenishIntermediate                  = true                                &#123;product&#125;Replenish all intermediate free-list caches</div><div class="line">    uintx CMSRescanMultiple                         = 32                                  &#123;product&#125;Size (in cards) of CMS parallel rescan task</div><div class="line">    uintx CMSSamplingGrain                          = 16384                               &#123;product&#125;The minimum distance between eden samples for CMS (see above)</div><div class="line">     bool CMSScavengeBeforeRemark                   = false                               &#123;product&#125;Attempt scavenge before the CMS remark step</div><div class="line">    uintx CMSScheduleRemarkEdenPenetration          = 50                                  &#123;product&#125;The Eden occupancy percentage (0-100) at which to try and schedule remark pause</div><div class="line">    uintx CMSScheduleRemarkEdenSizeThreshold        = 2097152                             &#123;product&#125;If Eden size is below this, do not try to schedule remark</div><div class="line">    uintx CMSScheduleRemarkSamplingRatio            = 5                                   &#123;product&#125;Start sampling eden top at least before young gen occupancy reaches 1/&lt;ratio&gt; of the size at which we plan to schedule remark</div><div class="line">   double CMSSmallCoalSurplusPercent                = 1.050000                            &#123;product&#125;CMS: the factor by which to inflate estimated demand of small block sizes to prevent coalescing with an adjoining block</div><div class="line">   double CMSSmallSplitSurplusPercent               = 1.100000                            &#123;product&#125;CMS: the factor by which to inflate estimated demand of small block sizes to prevent splitting to supply demand for smaller blocks</div><div class="line">     bool CMSSplitIndexedFreeListBlocks             = true                                &#123;product&#125;When satisfying batched demand, split blocks from the IndexedFreeList whose size is a multiple of requested size</div><div class="line">     bool CMSTestInFreeList                         = false                               &#123;develop&#125;Check if the coalesced range is already in the free lists as claimed</div><div class="line">     bool CMSTraceIncrementalMode                   = false                               &#123;develop&#125;Trace CMS incremental mode</div><div class="line">     bool CMSTraceIncrementalPacing                 = false                               &#123;develop&#125;Trace CMS incremental mode pacing computation</div><div class="line">     bool CMSTraceSweeper                           = false                               &#123;develop&#125;Trace some actions of the CMS sweeper</div><div class="line">     bool CMSTraceThreadState                       = false                               &#123;develop&#125;Trace the CMS thread state (enable the trace_state() method)</div><div class="line">     intx CMSTriggerInterval                        = -1                                  &#123;manageable&#125;Commence a CMS collection cycle (at least) every so many milliseconds (0 permanently, -1 disabled)</div><div class="line">    uintx CMSTriggerRatio                           = 80                                  &#123;product&#125;Percentage of MinHeapFreeRatio in CMS generation that is allocated before a CMS collection cycle commences</div><div class="line">     bool CMSVerifyReturnedBytes                    = false                               &#123;notproduct&#125;Check that all the garbage collected was returned to the free lists</div><div class="line">     intx CMSWaitDuration                           = 2000                                &#123;manageable&#125;Time in milliseconds that CMS thread waits for young GC</div><div class="line">    uintx CMSWorkQueueDrainThreshold                = 10                                  &#123;product&#125;Don&apos;t drain below this size per parallel worker/thief</div><div class="line">     bool CMSYield                                  = true                                &#123;product&#125;Yield between steps of CMS</div><div class="line">    uintx CMSYieldSleepCount                        = 0                                   &#123;product&#125;Number of times a GC thread (minus the coordinator) will sleep while yielding before giving up and resuming GC</div><div class="line">    uintx CMSYoungGenPerWorker                      = 67108864                            &#123;pd product&#125;The maximum size of young gen chosen by default per GC worker thread available</div><div class="line">    uintx CMS_FLSPadding                            = 1                                   &#123;product&#125;The multiple of deviation from mean to use for buffering against volatility in free list demand</div><div class="line">    uintx CMS_FLSWeight                             = 75                                  &#123;product&#125;Percentage (0-100) used to weigh the current sample when computing exponentially decaying averages for CMS FLS statistics</div><div class="line">    uintx CMS_SweepPadding                          = 1                                   &#123;product&#125;The multiple of deviation from mean to use for buffering against volatility in inter-sweep duration</div><div class="line">    uintx CMS_SweepTimerThresholdMillis             = 10                                  &#123;product&#125;Skip block flux-rate sampling for an epoch unless inter-sweep duration exceeds this threshold in milliseconds</div><div class="line">    uintx CMS_SweepWeight                           = 75                                  &#123;product&#125;Percentage (0-100) used to weight the current sample when computing exponentially decaying average for inter-sweep duration</div><div class="line">    uintx CPUForCMSThread                           = 0                                   &#123;diagnostic&#125;When BindCMSThreadToCPU is true, the CPU to bind CMS thread to</div><div class="line">     bool CSEArrayLength                            = false                               &#123;C1 pd develop&#125;Create separate nodes for length in array accesses</div><div class="line">     bool CanonicalizeNodes                         = true                                &#123;C1 develop&#125;Canonicalize graph nodes</div><div class="line">     bool CheckAssertionStatusDirectives            = false                               &#123;notproduct&#125;Temporary - see javaClasses.cpp</div><div class="line">     bool CheckCompressedOops                       = true                                &#123;notproduct&#125;Generate checks in encoding/decoding code in debug VM</div><div class="line">     bool CheckEndorsedAndExtDirs                   = false                               &#123;product&#125;Verify the endorsed and extension directories are not used</div><div class="line">     bool CheckJNICalls                             = false                               &#123;product&#125;Verify all arguments to JNI calls</div><div class="line">     bool CheckMemoryInitialization                 = false                               &#123;notproduct&#125;Check memory initialization</div><div class="line">     bool CheckOopishValues                         = false                               &#123;notproduct&#125;Warn if value contains oop (requires ZapDeadLocals)</div><div class="line">     bool CheckUnhandledOops                        = false                               &#123;develop&#125;Check for unhandled oops in VM code</div><div class="line">     bool CheckZapUnusedHeapArea                    = false                               &#123;develop&#125;Check zapping of unused heap space</div><div class="line">     bool ClassUnloading                            = true                                &#123;product&#125;Do unloading of classes</div><div class="line">     bool ClassUnloadingWithConcurrentMark          = true                                &#123;product&#125;Do unloading of classes with a concurrent marking cycle</div><div class="line">     bool CleanChunkPoolAsync                       = true                                &#123;develop&#125;Clean the chunk pool asynchronously</div><div class="line">     intx ClearFPUAtPark                            = 0                                   &#123;product&#125;(Unsafe, Unstable)</div><div class="line">     bool ClearInterpreterLocals                    = false                               &#123;develop&#125;Always clear local variables of interpreter activations upon entry</div><div class="line">     bool ClipInlining                              = true                                &#123;product&#125;Clip inlining if aggregate method exceeds DesiredMethodLimit</div><div class="line">    uintx CodeCacheExpansionSize                    = 65536                               &#123;pd product&#125;Code cache expansion size (in bytes)</div><div class="line">    uintx CodeCacheMinBlockLength                   = 4                                   &#123;pd develop&#125;Minimum number of segments in a code cache block</div><div class="line">    uintx CodeCacheMinimumFreeSpace                 = 512000                              &#123;product&#125;When less than X space left, we stop compiling</div><div class="line">    uintx CodeCacheMinimumUseSpace                  = 409600                              &#123;pd develop&#125;Minimum code cache size (in bytes) required to start VM.</div><div class="line">    uintx CodeCacheSegmentSize                      = 64                                  &#123;develop&#125;Code cache segment size (in bytes) - smallest unit of allocation</div><div class="line">     intx CodeEntryAlignment                        = 32                                  &#123;pd develop&#125;Code entry alignment for generated code (in bytes)</div><div class="line">     bool CollectGen0First                          = false                               &#123;product&#125;Collect youngest generation before each full GC</div><div class="line">     bool CollectIndexSetStatistics                 = false                               &#123;notproduct&#125;Collect information about IndexSets</div><div class="line">     bool CommentedAssembly                         = true                                &#123;C1 develop&#125;Show extra info in PrintNMethods output</div><div class="line">     bool CompactFields                             = true                                &#123;product&#125;Allocate nonstatic fields in gaps between previous fields</div><div class="line">     intx CompilationPolicyChoice                   = 0                                   &#123;product&#125;which compilation policy (0/1)</div><div class="line">ccstrlist CompileCommand                            =                                     &#123;product&#125;Prepend to .hotspot_compiler; e.g. log,java/lang/String.&lt;init&gt;</div><div class="line">    ccstr CompileCommandFile                        =                                     &#123;product&#125;Read compiler commands from this file [.hotspot_compiler]</div><div class="line">ccstrlist CompileOnly                               =                                     &#123;product&#125;List of methods (pkg/class.name) to restrict compilation to</div><div class="line">     bool CompileTheWorld                           = false                               &#123;develop&#125;Compile all methods in all classes in bootstrap class path (stress test)</div><div class="line">     bool CompileTheWorldPreloadClasses             = true                                &#123;develop&#125;Preload all classes used by a class before start loading</div><div class="line">     intx CompileTheWorldSafepointInterval          = 100                                 &#123;notproduct&#125;Force a safepoint every n compiles so sweeper can keep up</div><div class="line">     intx CompileTheWorldStartAt                    = 1                                   &#123;notproduct&#125;First class to consider when using +CompileTheWorld</div><div class="line">     intx CompileTheWorldStopAt                     = 2147483647                          &#123;notproduct&#125;Last class to consider when using +CompileTheWorld</div><div class="line">     intx CompileThreshold                          = 10000                               &#123;pd product&#125;number of interpreted method invocations before (re-)compiling</div><div class="line">     intx CompileZapFirst                           = 0                                   &#123;C2 notproduct&#125;If +ZapDeadCompiledLocals, skip this many before compiling in zap calls</div><div class="line">     intx CompileZapLast                            = -1                                  &#123;C2 notproduct&#125;If +ZapDeadCompiledLocals, compile this many after skipping (incl. skip count, -1 = all)</div><div class="line">     bool CompilerThreadHintNoPreempt               = true                                &#123;product&#125;(Solaris only) Give compiler threads an extra quanta</div><div class="line">     intx CompilerThreadPriority                    = -1                                  &#123;product&#125;The native priority at which compiler threads should run (-1 means no change)</div><div class="line">     intx CompilerThreadStackSize                   = 0                                   &#123;pd product&#125;Compiler Thread Stack Size (in Kbytes)</div><div class="line">    uintx CompressedClassSpaceSize                  = 1073741824                          &#123;product&#125;Maximum size of class area in Metaspace when compressed class pointers are used</div><div class="line">     bool ComputeExactFPURegisterUsage              = true                                &#123;C1 develop&#125;Compute additional live set for fpu registers to simplify fpu stack merge (Intel only)</div><div class="line">    uintx ConcGCThreads                             = 0                                   &#123;product&#125;Number of threads concurrent gc will use</div><div class="line">     intx ConcGCYieldTimeout                        = 0                                   &#123;develop&#125;If non-zero, assert that GC threads yield within this number of milliseconds</div><div class="line">     intx ConditionalMoveLimit                      = 3                                   &#123;C2 pd product&#125;Limit of ops to make speculative when using CMOVE</div><div class="line">     intx ContendedPaddingWidth                     = 128                                 &#123;product&#125;How many bytes to pad the fields/classes marked @Contended with</div><div class="line">     bool ConvertCmpD2CmpF                          = true                                &#123;C2 develop&#125;Convert cmpD to cmpF when one input is constant in float range</div><div class="line">     bool ConvertFloat2IntClipping                  = true                                &#123;C2 develop&#125;Convert float2int clipping idiom to integer clipping</div><div class="line">     bool ConvertSleepToYield                       = true                                &#123;pd product&#125;Convert sleep(0) to thread yield (may be off for Solaris to improve GUI)</div><div class="line">     bool ConvertYieldToSleep                       = false                               &#123;product&#125;Convert yield to a sleep of MinSleepInterval to simulate Win32 behavior (Solaris only)</div><div class="line">     bool CountBytecodes                            = false                               &#123;develop&#125;Count number of bytecodes executed</div><div class="line">     bool CountCompiledCalls                        = false                               &#123;develop&#125;Count method invocations</div><div class="line">     bool CountJNICalls                             = false                               &#123;develop&#125;Count jni method invocations</div><div class="line">     bool CountJVMCalls                             = false                               &#123;notproduct&#125;Count jvm method invocations</div><div class="line">     bool CountLinearScan                           = false                               &#123;C1 develop&#125;collect statistic counters during LinearScan</div><div class="line">     bool CountRemovableExceptions                  = false                               &#123;notproduct&#125;Count exceptions that could be replaced by branches due to inlining</div><div class="line">     bool CountRuntimeCalls                         = false                               &#123;notproduct&#125;Count VM runtime calls</div><div class="line">     intx CounterDecayMinIntervalLength             = 500                                 &#123;develop&#125;The minimum interval (in milliseconds) between invocation of CounterDecay</div><div class="line">     intx CounterHalfLifeTime                       = 30                                  &#123;develop&#125;Half-life time of invocation counters (in seconds)</div><div class="line">     bool CrashGCForDumpingJavaThread               = false                               &#123;notproduct&#125;Manually make GC thread crash then dump java stack trace;  Test only</div><div class="line">     bool CrashOnOutOfMemoryError                   = false                               &#123;product&#125;JVM aborts, producing an error log and core/mini dump, on the first occurrence of an out-of-memory error</div><div class="line">     bool CreateMinidumpOnCrash                     = false                               &#123;product&#125;Create minidump on VM fatal error</div><div class="line">     bool CriticalJNINatives                        = true                                &#123;product&#125;Check for critical JNI entry points</div><div class="line">     bool DTraceAllocProbes                         = false                               &#123;product&#125;Enable dtrace probes for object allocation</div><div class="line">     bool DTraceMethodProbes                        = false                               &#123;product&#125;Enable dtrace probes for method-entry and method-exit</div><div class="line">     bool DTraceMonitorProbes                       = false                               &#123;product&#125;Enable dtrace probes for monitor events</div><div class="line">     bool DebugDeoptimization                       = false                               &#123;develop&#125;Tracing various information while debugging deoptimization</div><div class="line">     bool DebugInlinedCalls                         = true                                &#123;C2 diagnostic&#125;If false, restricts profiled locations to the root method only</div><div class="line">     bool DebugNonSafepoints                        = true                                &#123;diagnostic&#125;Generate extra debugging information for non-safepoints in nmethods</div><div class="line">     bool DebugVtables                              = false                               &#123;develop&#125;add debugging code to vtable dispatch</div><div class="line">     bool Debugging                                 = false                               &#123;product&#125;Set when executing debug methods in debug.cpp (to prevent triggering assertions)</div><div class="line">    uintx DefaultMaxRAMFraction                     = 4                                   &#123;product&#125;Maximum fraction (1/n) of real memory used for maximum heap size; deprecated: to be renamed to MaxRAMFraction</div><div class="line">     intx DefaultThreadPriority                     = -1                                  &#123;product&#125;The native priority at which threads run if not elsewhere specified (-1 means no change)</div><div class="line">     bool DeferInitialCardMark                      = false                               &#123;diagnostic&#125;When +ReduceInitialCardMarks, explicitly defer any that may arise from new_pre_store_barrier</div><div class="line">     intx DeferPollingPageLoopCount                 = -1                                  &#123;product&#125;(Unsafe,Unstable) Number of iterations in safepoint loop before changing safepoint polling page to RO </div><div class="line">     intx DeferThrSuspendLoopCount                  = 4000                                &#123;product&#125;(Unstable) Number of times to iterate in safepoint loop before blocking VM threads </div><div class="line">     bool DelayCompilationDuringStartup             = true                                &#123;develop&#125;Delay invoking the compiler until main application class is loaded</div><div class="line">     bool DeoptC1                                   = true                                &#123;C1 develop&#125;Use deoptimization in C1</div><div class="line">     bool DeoptimizeALot                            = false                               &#123;develop&#125;Deoptimize at every exit from the runtime system</div><div class="line">     intx DeoptimizeALotInterval                    = 5                                   &#123;notproduct&#125;Number of exits until DeoptimizeALot kicks in</div><div class="line">ccstrlist DeoptimizeOnlyAt                          =                                     &#123;notproduct&#125;A comma separated list of bcis to deoptimize at</div><div class="line">     bool DeoptimizeRandom                          = false                               &#123;product&#125;Deoptimize random frames on random exit from the runtime system</div><div class="line">     intx DesiredMethodLimit                        = 8000                                &#123;develop&#125;The desired maximum method size (in bytecodes) after inlining</div><div class="line">     bool DieOnSafepointTimeout                     = false                               &#123;develop&#125;Die upon failure to reach safepoint (see SafepointTimeout)</div><div class="line">     bool DisableAttachMechanism                    = false                               &#123;product&#125;Disable mechanism that allows tools to attach to this VM</div><div class="line">     bool DisableExplicitGC                         = false                               &#123;product&#125;Ignore calls to System.gc()</div><div class="line">ccstrlist DisableIntrinsic                          =                                     &#123;C2 diagnostic&#125;do not expand intrinsics whose (internal) names appear here</div><div class="line">     bool DisableStartThread                        = false                               &#123;develop&#125;Disable starting of additional Java threads (for debugging only)</div><div class="line">     bool DisplayVMOutput                           = true                                &#123;diagnostic&#125;Display all VM output on the tty, independently of LogVMOutput</div><div class="line">     bool DisplayVMOutputToStderr                   = false                               &#123;product&#125;If DisplayVMOutput is true, display all VM output to stderr</div><div class="line">     bool DisplayVMOutputToStdout                   = false                               &#123;product&#125;If DisplayVMOutput is true, display all VM output to stdout</div><div class="line">     bool DoCEE                                     = true                                &#123;C1 develop&#125;Do Conditional Expression Elimination to simplify CFG</div><div class="line">     bool DoEscapeAnalysis                          = true                                &#123;C2 product&#125;Perform escape analysis</div><div class="line">     intx DominatorSearchLimit                      = 1000                                &#123;C2 diagnostic&#125;Iterations limit in Node::dominates</div><div class="line">     bool DontCompileHugeMethods                    = true                                &#123;product&#125;Do not compile methods &gt; HugeMethodLimit</div><div class="line">     bool DontYieldALot                             = false                               &#123;pd product&#125;Throw away obvious excess yield calls (for Solaris only)</div><div class="line">     intx DontYieldALotInterval                     = 10                                  &#123;develop&#125;Interval between which yields will be dropped (milliseconds)</div><div class="line">    ccstr DumpLoadedClassList                       =                                     &#123;product&#125;Dump the names all loaded classes, that could be stored into the CDS archive, in the specified file</div><div class="line">     bool DumpReplayDataOnError                     = true                                &#123;product&#125;Record replay data for crashing compiler threads</div><div class="line">     bool DumpSharedSpaces                          = false                               &#123;product&#125;Special mode: JVM reads a class list, loads classes, builds shared spaces, and dumps the shared spaces to a file to be used in future JVM runs</div><div class="line">     bool EagerInitialization                       = false                               &#123;develop&#125;Eagerly initialize classes if possible</div><div class="line">     bool EagerXrunInit                             = false                               &#123;product&#125;Eagerly initialize -Xrun libraries; allows startup profiling, but not all -Xrun libraries may support the state of the VM at this time</div><div class="line">     intx EliminateAllocationArraySizeLimit         = 64                                  &#123;C2 product&#125;Array size (number of elements) limit for scalar replacement</div><div class="line">     bool EliminateAllocations                      = true                                &#123;C2 product&#125;Use escape analysis to eliminate allocations</div><div class="line">     bool EliminateAutoBox                          = true                                &#123;C2 product&#125;Control optimizations for autobox elimination</div><div class="line">     bool EliminateBlocks                           = true                                &#123;C1 develop&#125;Eliminate unneccessary basic blocks</div><div class="line">     bool EliminateFieldAccess                      = true                                &#123;C1 develop&#125;Optimize field loads and stores</div><div class="line">     bool EliminateLocks                            = true                                &#123;C2 product&#125;Coarsen locks when possible</div><div class="line">     bool EliminateNestedLocks                      = true                                &#123;C2 product&#125;Eliminate nested locks of the same object when possible</div><div class="line">     bool EliminateNullChecks                       = true                                &#123;C1 develop&#125;Eliminate unneccessary null checks</div><div class="line">     intx EmitSync                                  = 0                                   &#123;product&#125;(Unsafe, Unstable) Control emission of inline sync fast-path code</div><div class="line">     bool EnableContended                           = true                                &#123;product&#125;Enable @Contended annotation support</div><div class="line">     bool EnableInvokeDynamic                       = true                                &#123;diagnostic&#125;support JSR 292 (method handles, invokedynamic, anonymous classes</div><div class="line">     bool EnableTracing                             = false                               &#123;product&#125;Enable event-based tracing</div><div class="line">    uintx ErgoHeapSizeLimit                         = 0                                   &#123;product&#125;Maximum ergonomically set heap size (in bytes); zero means use MaxRAM / MaxRAMFraction</div><div class="line">    ccstr ErrorFile                                 =                                     &#123;product&#125;If an error occurs, save the error data to this file [default: ./hs_err_pid%p.log] (%p replaced with pid)</div><div class="line">    uintx ErrorHandlerTest                          = 0                                   &#123;notproduct&#125;If &gt; 0, provokes an error after VM initialization; the value determines which error to provoke. See test_error_handler() in debug.cpp.</div><div class="line">    ccstr ErrorReportServer                         =                                     &#123;product&#125;Override built-in error report server address</div><div class="line">   double EscapeAnalysisTimeout                     = 60.000000                           &#123;C2 product&#125;Abort EA when it reaches time limit (in sec)</div><div class="line">     bool EstimateArgEscape                         = true                                &#123;product&#125;Analyze bytecodes to estimate escape state of arguments</div><div class="line">     bool ExecuteInternalVMTests                    = false                               &#123;notproduct&#125;Enable execution of internal VM tests</div><div class="line">     bool ExitEscapeAnalysisOnTimeout               = true                                &#123;C2 develop&#125;Exit or throw assert in EA when it reaches time limit</div><div class="line">     bool ExitOnFullCodeCache                       = false                               &#123;notproduct&#125;Exit the VM if we fill the code cache</div><div class="line">     bool ExitOnOutOfMemoryError                    = false                               &#123;product&#125;JVM exits on the first occurrence of an out-of-memory error</div><div class="line">     bool ExitVMOnVerifyError                       = false                               &#123;notproduct&#125;standard exit from VM if bytecode verify error (only in debug mode)</div><div class="line">     bool ExplicitGCInvokesConcurrent               = false                               &#123;product&#125;A System.gc() request invokes a concurrent collection; (effective only when UseConcMarkSweepGC)</div><div class="line">     bool ExplicitGCInvokesConcurrentAndUnloadsClasses  = false                               &#123;product&#125;A System.gc() request invokes a concurrent collection and also unloads classes during such a concurrent gc cycle (effective only when UseConcMarkSweepGC)</div><div class="line">     bool ExtendedDTraceProbes                      = false                               &#123;product&#125;Enable performance-impacting dtrace probes</div><div class="line">    ccstr ExtraSharedClassListFile                  =                                     &#123;product&#125;Extra classlist for building the CDS archive file</div><div class="line">     intx FLOATPRESSURE                             = 6                                   &#123;C2 pd develop&#125;Number of float LRG&apos;s that constitute high register pressure</div><div class="line">     bool FLSAlwaysCoalesceLarge                    = false                               &#123;product&#125;CMS: larger free blocks are always available for coalescing</div><div class="line">    uintx FLSCoalescePolicy                         = 2                                   &#123;product&#125;CMS: aggressiveness level for coalescing, increasing from 0 to 4</div><div class="line">   double FLSLargestBlockCoalesceProximity          = 0.990000                            &#123;product&#125;CMS: the smaller the percentage the greater the coalescing force</div><div class="line">     bool FLSVerifyAllHeapReferences                = false                               &#123;diagnostic&#125;Verify that all references across the FLS boundary are to valid objects</div><div class="line">     bool FLSVerifyDictionary                       = false                               &#123;develop&#125;Do lots of (expensive) FLS dictionary verification</div><div class="line">     bool FLSVerifyIndexTable                       = false                               &#123;diagnostic&#125;Do lots of (expensive) FLS index table verification</div><div class="line">     bool FLSVerifyLists                            = false                               &#123;diagnostic&#125;Do lots of (expensive) FreeListSpace verification</div><div class="line">     bool FailOverToOldVerifier                     = true                                &#123;product&#125;Fail over to old verifier when split verifier fails</div><div class="line">     intx FastAllocateSizeLimit                     = 131072                              &#123;develop&#125;Inline allocations larger than this in doublewords must go slow</div><div class="line">     intx FastSuperclassLimit                       = 8                                   &#123;develop&#125;Depth of hardwired instanceof accelerator array</div><div class="line">     bool FastTLABRefill                            = true                                &#123;product&#125;Use fast TLAB refill code</div><div class="line">     intx FenceInstruction                          = 0                                   &#123;ARCH product&#125;(Unsafe,Unstable) Experimental</div><div class="line">     intx FieldsAllocationStyle                     = 1                                   &#123;product&#125;0 - type based with oops first, 1 - with oops last, 2 - oops in super and sub classes are together</div><div class="line">     bool FillDelaySlots                            = true                                &#123;develop&#125;Fill delay slots (on SPARC only)</div><div class="line">     bool FilterSpuriousWakeups                     = true                                &#123;product&#125;Prevent spurious or premature wakeups from object.wait (Solaris only)</div><div class="line">     bool FoldStableValues                          = true                                &#123;diagnostic&#125;Optimize loads from stable fields (marked w/ @Stable)</div><div class="line">     bool ForceDynamicNumberOfGCThreads             = false                               &#123;diagnostic&#125;Force dynamic selection of the number of parallel threads parallel gc will use to aid debugging</div><div class="line">     bool ForceFloatExceptions                      = true                                &#123;develop&#125;Force exceptions on FP stack under/overflow</div><div class="line">     bool ForceNUMA                                 = false                               &#123;product&#125;Force NUMA optimizations on single-node/UMA systems</div><div class="line">     bool ForceTimeHighResolution                   = false                               &#123;product&#125;Using high time resolution (for Win32 only)</div><div class="line">     bool ForceUnreachable                          = false                               &#123;diagnostic&#125;Make all non code cache addresses to be unreachable by forcing use of 64bit literal fixups</div><div class="line">     intx FreqCountInvocations                      = 1                                   &#123;C2 develop&#125;Scaling factor for branch frequencies (deprecated)</div><div class="line">     intx FreqInlineSize                            = 325                                 &#123;pd product&#125;The maximum bytecode size of a frequent method to be inlined</div><div class="line">     bool FullGCALot                                = false                               &#123;develop&#125;Force full gc at every Nth exit from the runtime system (N=FullGCALotInterval)</div><div class="line">     intx FullGCALotDummies                         = 32768                               &#123;notproduct&#125;Dummy object allocated with +FullGCALot, forcing all objects to move</div><div class="line">     intx FullGCALotInterval                        = 1                                   &#123;notproduct&#125;Interval between which full gc will occur with +FullGCALot</div><div class="line">     intx FullGCALotStart                           = 0                                   &#123;notproduct&#125;For which invocation to start FullGCAlot</div><div class="line">    uintx G1ConcMarkForceOverflow                   = 0                                   &#123;develop&#125;The number of times we&apos;ll force an overflow during concurrent marking</div><div class="line">   double G1ConcMarkStepDurationMillis              = 10.000000                           &#123;product&#125;Target duration of individual concurrent marking steps in milliseconds.</div><div class="line">    uintx G1ConcRSHotCardLimit                      = 4                                   &#123;product&#125;The threshold that defines (&gt;=) a hot card.</div><div class="line">    uintx G1ConcRSLogCacheSize                      = 10                                  &#123;product&#125;Log base 2 of the length of conc RS hot-card cache.</div><div class="line">     intx G1ConcRefinementGreenZone                 = 0                                   &#123;product&#125;The number of update buffers that are left in the queue by the concurrent processing threads. Will be selected ergonomically by default.</div><div class="line">     intx G1ConcRefinementRedZone                   = 0                                   &#123;product&#125;Maximum number of enqueued update buffers before mutator threads start processing new ones instead of enqueueing them. Will be selected ergonomically by default. Zero will disable concurrent processing.</div><div class="line">     intx G1ConcRefinementServiceIntervalMillis     = 300                                 &#123;product&#125;The last concurrent refinement thread wakes up every specified number of milliseconds to do miscellaneous work.</div><div class="line">    uintx G1ConcRefinementThreads                   = 0                                   &#123;product&#125;If non-0 is the number of parallel rem set update threads, otherwise the value is determined ergonomically.</div><div class="line">     intx G1ConcRefinementThresholdStep             = 0                                   &#123;product&#125;Each time the rset update queue increases by this amount activate the next refinement thread if available. Will be selected ergonomically by default.</div><div class="line">     intx G1ConcRefinementYellowZone                = 0                                   &#123;product&#125;Number of enqueued update buffers that will trigger concurrent processing. Will be selected ergonomically by default.</div><div class="line">     bool G1ConcRegionFreeingVerbose                = false                               &#123;develop&#125;Enables verboseness during concurrent region freeing</div><div class="line">    uintx G1ConfidencePercent                       = 50                                  &#123;product&#125;Confidence level for MMU/pause predictions</div><div class="line">    uintx G1DummyRegionsPerGC                       = 0                                   &#123;develop&#125;The number of dummy regions G1 will allocate at the end of each evacuation pause in order to artificially fill up the heap and stress the marking implementation.</div><div class="line">     bool G1EvacuationFailureALot                   = false                               &#123;notproduct&#125;Force use of evacuation failure handling during certain evacuation pauses</div><div class="line">    uintx G1EvacuationFailureALotCount              = 1000                                &#123;develop&#125;Number of successful evacuations between evacuation failures occurring at object copying</div><div class="line">     bool G1EvacuationFailureALotDuringConcMark     = true                                &#123;develop&#125;Force use of evacuation failure handling during evacuation pauses when marking is in progress</div><div class="line">     bool G1EvacuationFailureALotDuringInitialMark  = true                                &#123;develop&#125;Force use of evacuation failure handling during initial mark evacuation pauses</div><div class="line">     bool G1EvacuationFailureALotDuringMixedGC      = true                                &#123;develop&#125;Force use of evacuation failure handling during mixed evacuation pauses</div><div class="line">     bool G1EvacuationFailureALotDuringYoungGC      = true                                &#123;develop&#125;Force use of evacuation failure handling during young evacuation pauses</div><div class="line">    uintx G1EvacuationFailureALotInterval           = 5                                   &#123;develop&#125;Total collections between forced triggering of evacuation failures</div><div class="line">     bool G1ExitOnExpansionFailure                  = false                               &#123;develop&#125;Raise a fatal VM exit out of memory failure in the event  that heap expansion fails due to running out of swap.</div><div class="line">     bool G1FailOnFPError                           = false                               &#123;develop&#125;When set, G1 will fail when it encounters an FP &apos;error&apos;, so as to allow debugging</div><div class="line">     bool G1HRRSFlushLogBuffersOnVerify             = false                               &#123;develop&#125;Forces flushing of log buffers before verification.</div><div class="line">     bool G1HRRSUseSparseTable                      = true                                &#123;develop&#125;When true, use sparse table to save space.</div><div class="line">    uintx G1HeapRegionSize                          = 0                                   &#123;product&#125;Size of the G1 regions.</div><div class="line">    uintx G1HeapWastePercent                        = 5                                   &#123;product&#125;Amount of space, expressed as a percentage of the heap size, that G1 is willing not to collect to avoid expensive GCs.</div><div class="line">     intx G1MarkingOverheadPercent                  = 0                                   &#123;develop&#125;Overhead of concurrent marking</div><div class="line">     intx G1MarkingVerboseLevel                     = 0                                   &#123;develop&#125;Level (0-4) of verboseness of the marking code</div><div class="line">     intx G1MaxVerifyFailures                       = -1                                  &#123;develop&#125;The maximum number of verification failrues to print.  -1 means print all.</div><div class="line">    uintx G1MixedGCCountTarget                      = 8                                   &#123;product&#125;The target number of mixed GCs after a marking cycle.</div><div class="line">     bool G1PrintHeapRegions                        = false                               &#123;diagnostic&#125;If set G1 will print information on which regions are being allocated and which are reclaimed.</div><div class="line">     bool G1PrintReachableAtInitialMark             = false                               &#123;develop&#125;Reachable object dump at the initial mark pause</div><div class="line">    ccstr G1PrintReachableBaseFile                  =                                     &#123;develop&#125;The base file name for the reachable object dumps</div><div class="line">     bool G1PrintRegionLivenessInfo                 = false                               &#123;diagnostic&#125;Prints the liveness information for all regions in the heap at the end of a marking cycle.</div><div class="line">     bool G1RSBarrierRegionFilter                   = true                                &#123;develop&#125;If true, generate region filtering code in RS barrier</div><div class="line">     bool G1RSLogCheckCardTable                     = false                               &#123;develop&#125;If true, verify that no dirty cards remain after RS log processing.</div><div class="line">     bool G1RSScrubVerbose                          = false                               &#123;develop&#125;When true, do RS scrubbing with verbose output.</div><div class="line">     intx G1RSetRegionEntries                       = 0                                   &#123;product&#125;Max number of regions for which we keep bitmaps.Will be set ergonomically by default</div><div class="line">     intx G1RSetRegionEntriesBase                   = 256                                 &#123;develop&#125;Max number of regions in a fine-grain table per MB.</div><div class="line">    uintx G1RSetScanBlockSize                       = 64                                  &#123;product&#125;Size of a work unit of cards claimed by a worker threadduring RSet scanning.</div><div class="line">     intx G1RSetSparseRegionEntries                 = 0                                   &#123;product&#125;Max number of entries per region in a sparse table.Will be set ergonomically by default.</div><div class="line">     intx G1RSetSparseRegionEntriesBase             = 4                                   &#123;develop&#125;Max number of entries per region in a sparse table per MB.</div><div class="line">     intx G1RSetUpdatingPauseTimePercent            = 10                                  &#123;product&#125;A target percentage of time that is allowed to be spend on process RS update buffers during the collection pause.</div><div class="line">     bool G1RecordHRRSEvents                        = false                               &#123;develop&#125;When true, record recent calls to rem set operations.</div><div class="line">     bool G1RecordHRRSOops                          = false                               &#123;develop&#125;When true, record recent calls to rem set operations.</div><div class="line">     intx G1RefProcDrainInterval                    = 10                                  &#123;product&#125;The number of discovered reference objects to process before draining concurrent marking work queues.</div><div class="line">    uintx G1ReservePercent                          = 10                                  &#123;product&#125;It determines the minimum reserve we should have in the heap to minimize the probability of promotion failure.</div><div class="line">    uintx G1SATBBufferEnqueueingThresholdPercent    = 60                                  &#123;product&#125;Before enqueueing them, each mutator thread tries to do some filtering on the SATB buffers it generates. If post-filtering the percentage of retained entries is over this threshold the buffer will be enqueued for processing. A value of 0 specifies that mutator threads should not do such filtering.</div><div class="line">     intx G1SATBBufferSize                          = 1024                                &#123;product&#125;Number of entries in an SATB log buffer.</div><div class="line">     bool G1SATBPrintStubs                          = false                               &#123;develop&#125;If true, print generated stubs for the SATB barrier</div><div class="line">     intx G1SATBProcessCompletedThreshold           = 20                                  &#123;develop&#125;Number of completed buffers that triggers log processing.</div><div class="line">     bool G1ScrubRemSets                            = true                                &#123;develop&#125;When true, do RS scrubbing after cleanup.</div><div class="line">    uintx G1SecondaryFreeListAppendLength           = 5                                   &#123;develop&#125;The number of regions we will add to the secondary free list at every append operation</div><div class="line">     bool G1StressConcRegionFreeing                 = false                               &#123;develop&#125;It stresses the concurrent region freeing operation</div><div class="line">    uintx G1StressConcRegionFreeingDelayMillis      = 0                                   &#123;develop&#125;Artificial delay during concurrent region freeing</div><div class="line">     bool G1SummarizeConcMark                       = false                               &#123;diagnostic&#125;Summarize concurrent mark info</div><div class="line">     bool G1SummarizeRSetStats                      = false                               &#123;diagnostic&#125;Summarize remembered set processing info</div><div class="line">     intx G1SummarizeRSetStatsPeriod                = 0                                   &#123;diagnostic&#125;The period (in number of GCs) at which we will generate update buffer processing info (0 means do not periodically generate this info); it also requires -XX:+G1SummarizeRSetStats</div><div class="line">     bool G1TraceConcRefinement                     = false                               &#123;diagnostic&#125;Trace G1 concurrent refinement</div><div class="line">     bool G1TraceHeapRegionRememberedSet            = false                               &#123;develop&#125;Enables heap region remembered set debug logs</div><div class="line">     bool G1TraceMarkStackOverflow                  = false                               &#123;develop&#125;If true, extra debugging code for CM restart for ovflw.</div><div class="line">     intx G1UpdateBufferSize                        = 256                                 &#123;product&#125;Size of an update buffer</div><div class="line">     bool G1UseAdaptiveConcRefinement               = true                                &#123;product&#125;Select green, yellow and red zones adaptively to meet the the pause requirements.</div><div class="line">     bool G1VerifyBitmaps                           = false                               &#123;develop&#125;Verifies the consistency of the marking bitmaps</div><div class="line">     bool G1VerifyCTCleanup                         = false                               &#123;develop&#125;Verify card table cleanup.</div><div class="line">     bool G1VerifyDuringGCPrintReachable            = false                               &#123;develop&#125;If conc mark verification fails, dump reachable objects</div><div class="line">     bool G1VerifyHeapRegionCodeRoots               = false                               &#123;diagnostic&#125;Verify the code root lists attached to each heap region.</div><div class="line">     bool G1VerifyRSetsDuringFullGC                 = false                               &#123;diagnostic&#125;If true, perform verification of each heap region&apos;s remembered set when verifying the heap during a full GC.</div><div class="line">     intx G1YoungSurvRateNumRegionsSummary          = 0                                   &#123;develop&#125;the number of regions for which we&apos;ll print a surv rate summary.</div><div class="line">     bool G1YoungSurvRateVerbose                    = false                               &#123;develop&#125;print out the survival rate of young regions according to age.</div><div class="line">     bool GCALotAtAllSafepoints                     = false                               &#123;notproduct&#125;Enforce ScavengeALot/GCALot at all potential safepoints</div><div class="line">    uintx GCDrainStackTargetSize                    = 64                                  &#123;product&#125;Number of entries we will try to leave on the stack during parallel gc</div><div class="line">    uintx GCExpandToAllocateDelayMillis             = 0                                   &#123;develop&#125;Delay between expansion and allocation (in milliseconds)</div><div class="line">    uintx GCHeapFreeLimit                           = 2                                   &#123;product&#125;Minimum percentage of free space after a full GC before an OutOfMemoryError is thrown (used with GCTimeLimit)</div><div class="line">    uintx GCLockerEdenExpansionPercent              = 5                                   &#123;product&#125;How much the GC can expand the eden by while the GC locker is active (as a percentage)</div><div class="line">     bool GCLockerInvokesConcurrent                 = false                               &#123;product&#125;The exit of a JNI critical section necessitating a scavenge, also kicks off a background concurrent collection</div><div class="line">    uintx GCLockerRetryAllocationCount              = 2                                   &#123;diagnostic&#125;Number of times to retry allocations when blocked by the GC locker</div><div class="line">    uintx GCLogFileSize                             = 8192                                &#123;product&#125;GC log file size, requires UseGCLogFileRotation. Set to 0 to only trigger rotation via jcmd</div><div class="line">     bool GCParallelVerificationEnabled             = true                                &#123;diagnostic&#125;Enable parallel memory system verification</div><div class="line">    uintx GCPauseIntervalMillis                     = 0                                   &#123;product&#125;Time slice for MMU specification</div><div class="line">    uintx GCTaskTimeStampEntries                    = 200                                 &#123;product&#125;Number of time stamp entries per gc worker thread</div><div class="line">    uintx GCTimeLimit                               = 98                                  &#123;product&#125;Limit of the proportion of time spent in GC before an OutOfMemoryError is thrown (used with GCHeapFreeLimit)</div><div class="line">    uintx GCTimeRatio                               = 99                                  &#123;product&#125;Adaptive size policy application time to GC time ratio</div><div class="line">    uintx GCWorkerDelayMillis                       = 0                                   &#123;develop&#125;Delay in scheduling GC workers (in milliseconds)</div><div class="line">     bool GenerateArrayStoreCheck                   = true                                &#123;C1 develop&#125;Generates code for array store checks</div><div class="line">     bool GenerateCompilerNullChecks                = true                                &#123;develop&#125;Generate explicit null checks for loads/stores/calls</div><div class="line">     bool GenerateRangeChecks                       = true                                &#123;develop&#125;Generate range checks for array accesses</div><div class="line">     bool GenerateSynchronizationCode               = true                                &#123;develop&#125;generate locking/unlocking code for synchronized methods and monitors</div><div class="line">     intx GuaranteedSafepointInterval               = 1000                                &#123;diagnostic&#125;Guarantee a safepoint (at least) every so many milliseconds (0 means none)</div><div class="line">    uintx HandleAllocationLimit                     = 1024                                &#123;notproduct&#125;Threshold for HandleMark allocation when +TraceHandleAllocation is used</div><div class="line">    uintx HeapBaseMinAddress                        = 2147483648                          &#123;pd product&#125;OS specific low limit for heap base address</div><div class="line">     bool HeapDumpAfterFullGC                       = false                               &#123;manageable&#125;Dump heap to file after any major stop-the-world GC</div><div class="line">     bool HeapDumpBeforeFullGC                      = false                               &#123;manageable&#125;Dump heap to file before any major stop-the-world GC</div><div class="line">     bool HeapDumpOnOutOfMemoryError                = false                               &#123;manageable&#125;Dump heap to file when java.lang.OutOfMemoryError is thrown</div><div class="line">    ccstr HeapDumpPath                              =                                     &#123;manageable&#125;When HeapDumpOnOutOfMemoryError is on, the path (filename or directory) of the dump file (defaults to java_pid&lt;pid&gt;.hprof in the working directory)</div><div class="line">    uintx HeapDumpSegmentSize                       = 1073741824                          &#123;develop&#125;Approximate segment size when generating a segmented heap dump</div><div class="line">    uintx HeapFirstMaximumCompactionCount           = 3                                   &#123;product&#125;The collection count for the first maximum compaction</div><div class="line">    uintx HeapMaximumCompactionInterval             = 20                                  &#123;product&#125;How often should we maximally compact the heap (not allowing any dead space)</div><div class="line">    uintx HeapSizePerGCThread                       = 87241520                            &#123;product&#125;Size of heap (bytes) per GC thread used in calculating the number of GC threads</div><div class="line">     intx HotCallCountThreshold                     = 999999                              &#123;C2 develop&#125;large numbers of calls (per method invocation) force hotness</div><div class="line">     intx HotCallProfitThreshold                    = 999999                              &#123;C2 develop&#125;highly profitable inlining opportunities force hotness</div><div class="line">     intx HotCallTrivialSize                        = -1                                  &#123;C2 develop&#125;trivial methods (no larger than this) force calls to be hot</div><div class="line">     intx HotCallTrivialWork                        = -1                                  &#123;C2 develop&#125;trivial execution time (no larger than this) forces hotness</div><div class="line">     intx HugeMethodLimit                           = 8000                                &#123;develop&#125;Don&apos;t compile methods larger than this if +DontCompileHugeMethods</div><div class="line">     bool ICMissHistogram                           = false                               &#123;notproduct&#125;Produce histogram of IC misses</div><div class="line">     bool IEEEPrecision                             = true                                &#123;ARCH develop&#125;Enables IEEE precision (for INTEL only)</div><div class="line">     intx INTPRESSURE                               = 13                                  &#123;C2 pd develop&#125;Number of integer LRG&apos;s that constitute high register pressure</div><div class="line">     bool IdealizedNumerics                         = false                               &#123;C2 develop&#125;Check performance difference allowing FP associativity and commutativity...</div><div class="line">     bool IgnoreEmptyClassPaths                     = false                               &#123;product&#125;Ignore empty path elements in -classpath</div><div class="line">     bool IgnoreLibthreadGPFault                    = false                               &#123;develop&#125;Suppress workaround for libthread GP fault</div><div class="line">     bool IgnoreLockingAssertions                   = false                               &#123;notproduct&#125;disable locking assertions (for speed)</div><div class="line">     bool IgnoreRewrites                            = false                               &#123;develop&#125;Suppress rewrites of bytecodes in the oopmap generator. This is unsafe!</div><div class="line">     bool IgnoreUnrecognizedVMOptions               = false                               &#123;product&#125;Ignore unrecognized VM options</div><div class="line">     bool IgnoreUnverifiableClassesDuringDump       = false                               &#123;diagnostic&#125;Do not quit -Xshare:dump even if we encounter unverifiable classes. Just exclude them from the shared dictionary.</div><div class="line">     bool ImplicitDiv0Checks                        = true                                &#123;C1 develop&#125;Use implicit division by zero checks</div><div class="line">     intx ImplicitNullCheckThreshold                = 3                                   &#123;C2 develop&#125;Don&apos;t do implicit null checks if NPE&apos;s in a method exceeds limit</div><div class="line">     bool ImplicitNullChecks                        = true                                &#123;pd develop&#125;Generate code for implicit null checks</div><div class="line">    uintx IncreaseFirstTierCompileThresholdAt       = 50                                  &#123;product&#125;Increase the compile threshold for C1 compilation if the code cache is filled by the specified percentage</div><div class="line">     bool IncrementalInline                         = true                                &#123;C2 product&#125;do post parse inlining</div><div class="line">     intx IndexSetWatch                             = 0                                   &#123;C2 notproduct&#125;Trace all operations on this IndexSet (-1 means all, 0 none)</div><div class="line">    uintx InitialBootClassLoaderMetaspaceSize       = 4194304                             &#123;product&#125;Initial size of the boot class loader data metaspace</div><div class="line">    uintx InitialCodeCacheSize                      = 2555904                             &#123;pd product&#125;Initial code cache size (in bytes)</div><div class="line">    uintx InitialHeapSize                           = 0                                   &#123;product&#125;Initial heap size (in bytes); zero means use ergonomics</div><div class="line">    uintx InitialRAMFraction                        = 64                                  &#123;product&#125;Fraction (1/n) of real memory used for initial heap size</div><div class="line">    uintx InitialSurvivorRatio                      = 8                                   &#123;product&#125;Initial ratio of young generation/survivor space size</div><div class="line">    uintx InitialTenuringThreshold                  = 7                                   &#123;product&#125;Initial value for tenuring threshold</div><div class="line">    uintx InitiatingHeapOccupancyPercent            = 45                                  &#123;product&#125;Percentage of the (entire) heap occupancy to start a concurrent GC cycle. It is used by GCs that trigger a concurrent GC cycle based on the occupancy of the entire heap, not just one of the generations (e.g., G1). A value of 0 denotes &apos;do constant GC cycles&apos;.</div><div class="line">     bool Inline                                    = true                                &#123;product&#125;Enable inlining</div><div class="line">     bool InlineAccessors                           = true                                &#123;C2 develop&#125;inline accessor methods (get/set)</div><div class="line">     bool InlineArrayCopy                           = true                                &#123;develop&#125;Inline arraycopy native that is known to be part of base library DLL</div><div class="line">     bool InlineClassNatives                        = true                                &#123;develop&#125;Inline Class.isInstance, etc</div><div class="line">    ccstr InlineDataFile                            =                                     &#123;product&#125;File containing inlining replay information[default: ./inline_pid%p.log] (%p replaced with pid)</div><div class="line">     intx InlineFrequencyCount                      = 100                                 &#123;pd develop&#125;Count of call site execution necessary to trigger frequent inlining</div><div class="line">     intx InlineFrequencyRatio                      = 20                                  &#123;develop&#125;Ratio of call site execution to caller method invocation</div><div class="line">     bool InlineIntrinsics                          = true                                &#123;pd develop&#125;Inline intrinsics that can be statically resolved</div><div class="line">     bool InlineMathNatives                         = true                                &#123;develop&#125;Inline SinD, CosD, etc.</div><div class="line">     bool InlineMethodsWithExceptionHandlers        = true                                &#123;C1 develop&#125;Inline methods containing exception handlers (NOTE: does not work with current backend)</div><div class="line">     bool InlineNIOCheckIndex                       = true                                &#123;C1 develop&#125;Intrinsify java.nio.Buffer.checkIndex</div><div class="line">     bool InlineNatives                             = true                                &#123;develop&#125;Inline natives that are known to be part of base library DLL</div><div class="line">     bool InlineObjectCopy                          = true                                &#123;C2 develop&#125;inline Object.clone and Arrays.copyOf[Range] intrinsics</div><div class="line">     bool InlineObjectHash                          = true                                &#123;develop&#125;Inline Object::hashCode() native that is known to be part of base library DLL</div><div class="line">     bool InlineReflectionGetCallerClass            = true                                &#123;C2 develop&#125;inline sun.reflect.Reflection.getCallerClass(), known to be part of base library DLL</div><div class="line">     intx InlineSmallCode                           = 1000                                &#123;pd product&#125;Only inline already compiled methods if their code size is less than this</div><div class="line">     bool InlineSynchronizedMethods                 = true                                &#123;C1 product&#125;Inline synchronized methods</div><div class="line">     bool InlineThreadNatives                       = true                                &#123;develop&#125;Inline Thread.currentThread, etc</div><div class="line">     intx InlineThrowCount                          = 50                                  &#123;develop&#125;Force inlining of interpreted methods that throw this often</div><div class="line">     intx InlineThrowMaxSize                        = 200                                 &#123;develop&#125;Force inlining of throwing methods smaller than this</div><div class="line">     bool InlineUnsafeOps                           = true                                &#123;develop&#125;Inline memory ops (native methods) from sun.misc.Unsafe</div><div class="line">     bool InlineWarmCalls                           = false                               &#123;C2 develop&#125;Use a heat-based priority queue to govern inlining</div><div class="line">     bool InsertMemBarAfterArraycopy                = true                                &#123;C2 product&#125;Insert memory barrier after arraycopy call</div><div class="line">     bool InstallMethods                            = true                                &#123;C1 develop&#125;Install methods at the end of successful compilations</div><div class="line">     intx InstructionCountCutoff                    = 37000                               &#123;C1 develop&#125;If GraphBuilder adds this many instructions, bails out</div><div class="line">     bool InterceptOSException                      = false                               &#123;develop&#125;Start debugger when an implicit OS (e.g. NULL) exception happens</div><div class="line">     intx InteriorEntryAlignment                    = 16                                  &#123;C2 pd product&#125;Code alignment for interior entry points in generated code (in bytes)</div><div class="line">     intx InterpreterProfilePercentage              = 33                                  &#123;product&#125;NON_TIERED number of method invocations/branches (expressed as % of CompileThreshold) before profiling in the interpreter</div><div class="line">     bool JNIDetachReleasesMonitors                 = true                                &#123;product&#125;JNI DetachCurrentThread releases monitors owned by thread</div><div class="line">    uintx JVMInvokeMethodSlack                      = 8192                                &#123;pd develop&#125;Stack space (bytes) required for JVM_InvokeMethod to complete</div><div class="line">     bool JavaMonitorsInStackTrace                  = true                                &#123;product&#125;Print information about Java monitor locks when the stacks aredumped</div><div class="line">     intx JavaPriority10_To_OSPriority              = -1                                  &#123;product&#125;Map Java priorities to OS priorities</div><div class="line">     intx JavaPriority1_To_OSPriority               = -1                                  &#123;product&#125;Map Java priorities to OS priorities</div><div class="line">     intx JavaPriority2_To_OSPriority               = -1                                  &#123;product&#125;Map Java priorities to OS priorities</div><div class="line">     intx JavaPriority3_To_OSPriority               = -1                                  &#123;product&#125;Map Java priorities to OS priorities</div><div class="line">     intx JavaPriority4_To_OSPriority               = -1                                  &#123;product&#125;Map Java priorities to OS priorities</div><div class="line">     intx JavaPriority5_To_OSPriority               = -1                                  &#123;product&#125;Map Java priorities to OS priorities</div><div class="line">     intx JavaPriority6_To_OSPriority               = -1                                  &#123;product&#125;Map Java priorities to OS priorities</div><div class="line">     intx JavaPriority7_To_OSPriority               = -1                                  &#123;product&#125;Map Java priorities to OS priorities</div><div class="line">     intx JavaPriority8_To_OSPriority               = -1                                  &#123;product&#125;Map Java priorities to OS priorities</div><div class="line">     intx JavaPriority9_To_OSPriority               = -1                                  &#123;product&#125;Map Java priorities to OS priorities</div><div class="line">     bool LIRFillDelaySlots                         = false                               &#123;C1 pd product&#125;fill delays on on SPARC with LIR</div><div class="line">     bool LIRTraceExecution                         = false                               &#123;C1 develop&#125;add LIR code which logs the execution of blocks</div><div class="line">     bool LIRTracePeephole                          = false                               &#123;C1 develop&#125;Trace peephole optimizer</div><div class="line">    uintx LargePageHeapSizeThreshold                = 134217728                           &#123;product&#125;Use large pages if maximum heap is at least this big</div><div class="line">    uintx LargePageSizeInBytes                      = 0                                   &#123;product&#125;Large page size (0 to let VM choose the page size)</div><div class="line">     bool LargePagesIndividualAllocationInjectError  = false                               &#123;develop&#125;Fail large pages individual allocation</div><div class="line">     bool LazyBootClassLoader                       = true                                &#123;product&#125;Enable/disable lazy opening of boot class path entries</div><div class="line">     intx LiveNodeCountInliningCutoff               = 40000                               &#123;C2 product&#125;max number of live nodes in a method</div><div class="line">     bool LoadExecStackDllInVMThread                = true                                &#123;product&#125;Load DLLs with executable-stack attribute in the VM Thread</div><div class="line">     bool LoadLineNumberTables                      = true                                &#123;develop&#125;Tell whether the class file parser loads line number tables</div><div class="line">     bool LoadLocalVariableTables                   = true                                &#123;develop&#125;Tell whether the class file parser loads local variable tables</div><div class="line">     bool LoadLocalVariableTypeTables               = true                                &#123;develop&#125;Tell whether the class file parser loads local variable typetables</div><div class="line">     bool LogCompilation                            = false                               &#123;diagnostic&#125;Log compilation activity in detail to LogFile</div><div class="line">     bool LogEvents                                 = true                                &#123;diagnostic&#125;Enable the various ring buffer event logs</div><div class="line">    uintx LogEventsBufferEntries                    = 10                                  &#123;diagnostic&#125;Number of ring buffer event logs</div><div class="line">    ccstr LogFile                                   =                                     &#123;diagnostic&#125;If LogVMOutput or LogCompilation is on, save VM output to this file [default: ./hotspot_pid%p.log] (%p replaced with pid)</div><div class="line">     bool LogSweeper                                = false                               &#123;notproduct&#125;Keep a ring buffer of sweeper activity</div><div class="line">     bool LogVMOutput                               = false                               &#123;diagnostic&#125;Save VM output to LogFile</div><div class="line">     intx LongCompileThreshold                      = 50                                  &#123;develop&#125;Used with +TraceLongCompiles</div><div class="line">     bool LoopLimitCheck                            = true                                &#123;C2 diagnostic&#125;Generate a loop limits check for overflow</div><div class="line">     intx LoopMaxUnroll                             = 16                                  &#123;C2 product&#125;Maximum number of unrolls for main loop</div><div class="line">     intx LoopOptsCount                             = 43                                  &#123;C2 product&#125;Set level of loop optimization for tier 1 compiles</div><div class="line">     intx LoopUnrollLimit                           = 60                                  &#123;C2 pd product&#125;Unroll loop bodies with node count less than this</div><div class="line">     intx LoopUnrollMin                             = 4                                   &#123;C2 product&#125;Minimum number of unroll loop bodies before checking progressof rounds of unroll,optimize,..</div><div class="line">     bool LoopUnswitching                           = true                                &#123;C2 product&#125;Enable loop unswitching (a form of invariant test hoisting)</div><div class="line">     intx MallocCatchPtr                            = -1                                  &#123;develop&#125;Hit breakpoint when mallocing/freeing this pointer</div><div class="line">    uintx MallocMaxTestWords                        = 0                                   &#123;diagnostic&#125;If non-zero, maximum number of words that malloc/realloc can allocate (for testing only)</div><div class="line">     intx MallocVerifyInterval                      = 0                                   &#123;diagnostic&#125;If non-zero, verify C heap after every N calls to malloc/realloc/free</div><div class="line">     intx MallocVerifyStart                         = 0                                   &#123;diagnostic&#125;If non-zero, start verifying C heap after Nth call to malloc/realloc/free</div><div class="line">     bool ManagementServer                          = false                               &#123;product&#125;Create JMX Management Server</div><div class="line">    uintx MarkStackSize                             = 4194304                             &#123;product&#125;Size of marking stack</div><div class="line">    uintx MarkStackSizeMax                          = 536870912                           &#123;product&#125;Maximum size of marking stack</div><div class="line">    uintx MarkSweepAlwaysCompactCount               = 4                                   &#123;product&#125;How often should we fully compact the heap (ignoring the dead space parameters)</div><div class="line">    uintx MarkSweepDeadRatio                        = 5                                   &#123;product&#125;Percentage (0-100) of the old gen allowed as dead wood. Serial mark sweep treats this as both the minimum and maximum value. CMS uses this value only if it falls back to mark sweep. Par compact uses a variable scale based on the density of the generation and treats this as the maximum value when the heap is either completely full or completely empty.  Par compact also has a smaller default value; see arguments.cpp.</div><div class="line">     intx MaxBCEAEstimateLevel                      = 5                                   &#123;product&#125;Maximum number of nested calls that are analyzed by BC EA</div><div class="line">     intx MaxBCEAEstimateSize                       = 150                                 &#123;product&#125;Maximum bytecode size of a method to be analyzed by BC EA</div><div class="line">    uintx MaxDirectMemorySize                       = 0                                   &#123;product&#125;Maximum total size of NIO direct-buffer allocations</div><div class="line">     intx MaxElementPrintSize                       = 256                                 &#123;notproduct&#125;maximum number of elements to print</div><div class="line">     bool MaxFDLimit                                = true                                &#123;product&#125;Bump the number of file descriptors to maximum in Solaris</div><div class="line">     intx MaxForceInlineLevel                       = 100                                 &#123;develop&#125;maximum number of nested calls that are forced for inlining (using CompilerOracle or marked w/ @ForceInline)</div><div class="line">    uintx MaxGCMinorPauseMillis                     = 18446744073709551615                    &#123;product&#125;Adaptive size policy maximum GC minor pause time goal in millisecond</div><div class="line">    uintx MaxGCPauseMillis                          = 18446744073709551615                    &#123;product&#125;Adaptive size policy maximum GC pause time goal in millisecond, or (G1 Only) the maximum GC time per MMU time slice</div><div class="line">    uintx MaxHeapFreeRatio                          = 70                                  &#123;manageable&#125;The maximum percentage of heap free after GC to avoid shrinking. For most GCs this applies to the old generation. In G1 and ParallelGC it applies to the whole heap.</div><div class="line">    uintx MaxHeapSize                               = 130862280                           &#123;product&#125;Maximum heap size (in bytes)</div><div class="line">     intx MaxInlineLevel                            = 9                                   &#123;product&#125;maximum number of nested calls that are inlined</div><div class="line">     intx MaxInlineSize                             = 35                                  &#123;product&#125;The maximum bytecode size of a method to be inlined</div><div class="line">     intx MaxInterpretedSearchLength                = 3                                   &#123;develop&#125;The maximum number of interpreted frames to skip when searching for recompilee</div><div class="line">     intx MaxJNILocalCapacity                       = 65536                               &#123;product&#125;Maximum allowable local JNI handle capacity to EnsureLocalCapacity() and PushLocalFrame(), where &lt;= 0 is unlimited, default: 65536</div><div class="line">     intx MaxJavaStackTraceDepth                    = 1024                                &#123;product&#125;The maximum number of lines in the stack trace for Java exceptions (0 means all)</div><div class="line">     intx MaxJumpTableSize                          = 65000                               &#123;C2 product&#125;Maximum number of targets in a generated jump table</div><div class="line">     intx MaxJumpTableSparseness                    = 5                                   &#123;C2 product&#125;Maximum sparseness for jumptables</div><div class="line">     intx MaxLabelRootDepth                         = 1100                                &#123;C2 product&#125;Maximum times call Label_Root to prevent stack overflow</div><div class="line">     intx MaxLoopPad                                = 15                                  &#123;C2 product&#125;Align a loop if padding size in bytes is less or equal to this value</div><div class="line">    uintx MaxMetaspaceExpansion                     = 5452592                             &#123;product&#125;The maximum expansion of Metaspace without full GC (in bytes)</div><div class="line">    uintx MaxMetaspaceFreeRatio                     = 70                                  &#123;product&#125;The maximum percentage of Metaspace free after GC to avoid shrinking</div><div class="line">    uintx MaxMetaspaceSize                          = 18446744073709551615                    &#123;product&#125;Maximum size of Metaspaces (in bytes)</div><div class="line">    uintx MaxNewSize                                = 18446744073709551615                    &#123;product&#125;Maximum new generation size (in bytes), max_uintx means set ergonomically</div><div class="line">     intx MaxNodeLimit                              = 80000                               &#123;C2 product&#125;Maximum number of nodes</div><div class="line"> uint64_t MaxRAM                                    = 137438953472                        &#123;pd product&#125;Real memory size (in bytes) used to set maximum heap size</div><div class="line">    uintx MaxRAMFraction                            = 4                                   &#123;product&#125;Maximum fraction (1/n) of real memory used for maximum heap size</div><div class="line">     intx MaxRecompilationSearchLength              = 10                                  &#123;develop&#125;The maximum number of frames to inspect when searching for recompilee</div><div class="line">     intx MaxRecursiveInlineLevel                   = 1                                   &#123;product&#125;maximum number of nested recursive calls that are inlined</div><div class="line">     intx MaxSubklassPrintSize                      = 4                                   &#123;notproduct&#125;maximum number of subklasses to print when printing klass</div><div class="line">    uintx MaxTenuringThreshold                      = 15                                  &#123;product&#125;Maximum value for tenuring threshold</div><div class="line">     intx MaxTrivialSize                            = 6                                   &#123;product&#125;The maximum bytecode size of a trivial method to be inlined</div><div class="line">     intx MaxVectorSize                             = 32                                  &#123;C2 product&#125;Max vector size in bytes, actual size could be less depending on elements type</div><div class="line">    uintx MaxVirtMemFraction                        = 2                                   &#123;develop&#125;Maximum fraction (1/n) of virtual memory used for ergonomically determining maximum heap size</div><div class="line">     bool MemProfiling                              = false                               &#123;develop&#125;Write memory usage profiling to log file</div><div class="line">     intx MemProfilingInterval                      = 500                                 &#123;notproduct&#125;Time between each invocation of the MemProfiler</div><div class="line">     bool MetadataAllocationFailALot                = false                               &#123;develop&#125;Fail metadata allocations at intervals controlled by MetadataAllocationFailALotInterval</div><div class="line">    uintx MetadataAllocationFailALotInterval        = 1000                                &#123;develop&#125;Metadata allocation failure a lot interval</div><div class="line">    uintx MetaspaceSize                             = 21810376                            &#123;pd product&#125;Initial size of Metaspaces (in bytes)</div><div class="line">     bool MethodFlushing                            = true                                &#123;product&#125;Reclamation of zombie and not-entrant methods</div><div class="line">     intx MethodHistogramCutoff                     = 100                                 &#123;develop&#125;The cutoff value for method invocation histogram (+CountCalls)</div><div class="line">    uintx MinHeapDeltaBytes                         = 170392                              &#123;product&#125;The minimum change in heap space due to GC (in bytes)</div><div class="line">    uintx MinHeapFreeRatio                          = 40                                  &#123;manageable&#125;The minimum percentage of heap free after GC to avoid expansion. For most GCs this applies to the old generation. In G1 and ParallelGC it applies to the whole heap.</div><div class="line">     intx MinInliningThreshold                      = 250                                 &#123;product&#125;The minimum invocation count a method needs to have to be inlined</div><div class="line">     intx MinJumpTableSize                          = 10                                  &#123;C2 pd product&#125;Minimum number of targets in a generated jump table</div><div class="line">    uintx MinMetaspaceExpansion                     = 340784                              &#123;product&#125;The minimum expansion of Metaspace (in bytes)</div><div class="line">    uintx MinMetaspaceFreeRatio                     = 40                                  &#123;product&#125;The minimum percentage of Metaspace free after GC to avoid expansion</div><div class="line">     intx MinOopMapAllocation                       = 8                                   &#123;develop&#125;Minimum number of OopMap entries in an OopMapSet</div><div class="line">    uintx MinRAMFraction                            = 2                                   &#123;product&#125;Minimum fraction (1/n) of real memory used for maxmimum heap size on systems with small physical memory size</div><div class="line">     intx MinSleepInterval                          = 1                                   &#123;develop&#125;Minimum sleep() interval (milliseconds) when ConvertSleepToYield is off (used for Solaris)</div><div class="line">    uintx MinSurvivorRatio                          = 3                                   &#123;product&#125;Minimum ratio of young generation/survivor space size</div><div class="line">    uintx MinTLABSize                               = 2048                                &#123;product&#125;Minimum allowed TLAB size (in bytes)</div><div class="line">     intx MonitorBound                              = 0                                   &#123;product&#125;Bound Monitor population</div><div class="line">     bool MonitorInUseLists                         = false                               &#123;product&#125;Track Monitors for Deflation</div><div class="line">     bool MonomorphicArrayCheck                     = true                                &#123;C2 develop&#125;Uncommon-trap array store checks that require full type check</div><div class="line">     intx MultiArrayExpandLimit                     = 6                                   &#123;C2 product&#125;Maximum number of individual allocations in an inline-expanded multianewarray instruction</div><div class="line">     bool MustCallLoadClassInternal                 = false                               &#123;product&#125;Call loadClassInternal() rather than loadClass()</div><div class="line">     intx NMethodSizeLimit                          = 524288                              &#123;C1 develop&#125;Maximum size of a compiled method.</div><div class="line">    uintx NUMAChunkResizeWeight                     = 20                                  &#123;product&#125;Percentage (0-100) used to weigh the current sample when computing exponentially decaying average for AdaptiveNUMAChunkSizing</div><div class="line">    uintx NUMAInterleaveGranularity                 = 2097152                             &#123;product&#125;Granularity to use for NUMA interleaving on Windows OS</div><div class="line">    uintx NUMAPageScanRate                          = 256                                 &#123;product&#125;Maximum number of pages to include in the page scan procedure</div><div class="line">    uintx NUMASpaceResizeRate                       = 1073741824                          &#123;product&#125;Do not reallocate more than this amount per collection</div><div class="line">     bool NUMAStats                                 = false                               &#123;product&#125;Print NUMA stats in detailed heap information</div><div class="line">    ccstr NativeMemoryTracking                      = off                                 &#123;product&#125;Native memory tracking options</div><div class="line">     bool NeedsDeoptSuspend                         = false                               &#123;pd product&#125;True for register window machines (sparc/ia64)</div><div class="line">     intx NestedInliningSizeRatio                   = 90                                  &#123;C1 develop&#125;Percentage of prev. allowed inline size in recursive inlining</div><div class="line">     bool NeverActAsServerClassMachine              = false                               &#123;pd product&#125;Never act like a server-class machine</div><div class="line">     bool NeverTenure                               = false                               &#123;product&#125;Never tenure objects in eden, may tenure on overflow (ParallelGC only)</div><div class="line">     intx NewCodeParameter                          = 0                                   &#123;develop&#125;Testing Only: Create a dedicated integer parameter before putback</div><div class="line">    uintx NewRatio                                  = 2                                   &#123;product&#125;Ratio of old/new generation sizes</div><div class="line">    uintx NewSize                                   = 1363144                             &#123;product&#125;Initial new generation size (in bytes)</div><div class="line">    uintx NewSizeThreadIncrease                     = 5320                                &#123;pd product&#125;Additional size added to desired new generation size per non-daemon thread (in bytes)</div><div class="line">     intx NmethodSweepActivity                      = 10                                  &#123;product&#125;Removes cold nmethods from code cache if &gt; 0. Higher values result in more aggressive sweeping</div><div class="line">     intx NmethodSweepCheckInterval                 = 5                                   &#123;product&#125;Compilers wake up every n seconds to possibly sweep nmethods</div><div class="line">     intx NmethodSweepFraction                      = 16                                  &#123;product&#125;Number of invocations of sweeper to cover all nmethods</div><div class="line">     bool NoYieldsInMicrolock                       = false                               &#123;develop&#125;Disable yields in microlock</div><div class="line">     intx NodeCountInliningCutoff                   = 18000                               &#123;C2 develop&#125;If parser node generation exceeds limit stop inlining</div><div class="line">     intx NodeCountInliningStep                     = 1000                                &#123;C2 develop&#125;Target size of warm calls inlined between optimization passes</div><div class="line">     intx NodeLimitFudgeFactor                      = 2000                                &#123;C2 product&#125;Fudge Factor for certain optimizations</div><div class="line">    uintx NumberOfGCLogFiles                        = 0                                   &#123;product&#125;Number of gclog files in rotation (default: 0, no rotation)</div><div class="line">     intx NumberOfLoopInstrToAlign                  = 4                                   &#123;C2 product&#125;Number of first instructions in a loop to align</div><div class="line">     intx OSROnlyBCI                                = -1                                  &#123;develop&#125;OSR only at this bci.  Negative values mean exclude that bci</div><div class="line">    uintx ObjArrayMarkingStride                     = 512                                 &#123;develop&#125;Number of object array elements to push onto the marking stack before pushing a continuation entry</div><div class="line">     intx ObjectAlignmentInBytes                    = 8                                   &#123;lp64_product&#125;Default object alignment in bytes, 8 is minimum</div><div class="line">    uintx OldPLABSize                               = 1024                                &#123;product&#125;Size of old gen promotion LAB&apos;s (in HeapWords)</div><div class="line">    uintx OldPLABWeight                             = 50                                  &#123;product&#125;Percentage (0-100) used to weight the current sample when computing exponentially decaying average for resizing CMSParPromoteBlocksToClaim</div><div class="line">    uintx OldSize                                   = 5452592                             &#123;product&#125;Initial tenured generation size (in bytes)</div><div class="line">     bool OmitStackTraceInFastThrow                 = true                                &#123;product&#125;Omit backtraces for some &apos;hot&apos; exceptions in optimized code</div><div class="line">ccstrlist OnError                                   =                                     &#123;product&#125;Run user-defined commands on fatal error; see VMError.cpp for examples</div><div class="line">ccstrlist OnOutOfMemoryError                        =                                     &#123;product&#125;Run user-defined commands on first java.lang.OutOfMemoryError</div><div class="line">     intx OnStackReplacePercentage                  = 140                                 &#123;pd product&#125;NON_TIERED number of method invocations/branches (expressed as % of CompileThreshold) before (re-)compiling OSR code</div><div class="line">     bool OptimizeExpensiveOps                      = true                                &#123;C2 diagnostic&#125;Find best control for expensive operations</div><div class="line">     bool OptimizeFill                              = true                                &#123;C2 product&#125;convert fill/copy loops into intrinsic</div><div class="line">     bool OptimizeIfOps                             = true                                &#123;C1 develop&#125;Optimize multiple IfOps</div><div class="line">     bool OptimizePtrCompare                        = true                                &#123;C2 product&#125;Use escape analysis to optimize pointers compare</div><div class="line">     bool OptimizeStringConcat                      = true                                &#123;C2 product&#125;Optimize the construction of Strings by StringBuilder</div><div class="line">     bool OptimizeUnsafes                           = true                                &#123;C1 develop&#125;Optimize raw unsafe ops</div><div class="line">     intx OptoBlockListSize                         = 8                                   &#123;C2 develop&#125;Starting allocation size of Block_List data structures</div><div class="line">     bool OptoBreakpoint                            = false                               &#123;C2 develop&#125;insert breakpoint at method entry</div><div class="line">     bool OptoBreakpointC2R                         = false                               &#123;C2 notproduct&#125;insert breakpoint at runtime stub entry</div><div class="line">     bool OptoBreakpointOSR                         = false                               &#123;C2 notproduct&#125;insert breakpoint at osr method entry</div><div class="line">     bool OptoBundling                              = false                               &#123;C2 pd product&#125;Generate nops to fill i-cache lines</div><div class="line">     bool OptoCoalesce                              = true                                &#123;C2 develop&#125;Use Conservative Copy Coalescing in the Register Allocator</div><div class="line">     intx OptoLoopAlignment                         = 16                                  &#123;pd product&#125;Align inner loops to zero relative to this modulus</div><div class="line">     bool OptoNoExecute                             = false                               &#123;C2 notproduct&#125;Attempt to parse and compile but do not execute generated code</div><div class="line">     intx OptoNodeListSize                          = 4                                   &#123;C2 develop&#125;Starting allocation size of Node_List data structures</div><div class="line">     bool OptoPeephole                              = true                                &#123;C2 pd develop&#125;Apply peephole optimizations after register allocation</div><div class="line">     intx OptoPeepholeAt                            = -1                                  &#123;C2 develop&#125;Apply peephole optimizations to this peephole rule</div><div class="line">     intx OptoPrologueNops                          = 0                                   &#123;C2 develop&#125;Insert this many extra nop instructions in the prologue of every nmethod</div><div class="line">     bool OptoRemoveUseless                         = true                                &#123;C2 develop&#125;Remove useless nodes after parsing</div><div class="line">     bool OptoScheduling                            = false                               &#123;C2 pd product&#125;Instruction Scheduling after register allocation</div><div class="line">    uintx PLABWeight                                = 75                                  &#123;product&#125;Percentage (0-100) used to weigh the current sample when computing exponentially decaying average for ResizePLAB</div><div class="line">     intx PSAdaptiveSizePolicyResizeVirtualSpaceAlot  = -1                                  &#123;develop&#125;Resize the virtual spaces of the young or old generations</div><div class="line">     bool PSAdjustTenuredGenForMinorPause           = false                               &#123;develop&#125;Adjust tenured generation to achieve a minor pause goal</div><div class="line">     bool PSAdjustYoungGenForMajorPause             = false                               &#123;develop&#125;Adjust young generation to achieve a major pause goal</div><div class="line">     bool PSChunkLargeArrays                        = true                                &#123;product&#125;Process large arrays in chunks</div><div class="line">     intx ParGCArrayScanChunk                       = 50                                  &#123;product&#125;Scan a subset of object array and push remainder, if array is bigger than this</div><div class="line">     intx ParGCCardsPerStrideChunk                  = 256                                 &#123;diagnostic&#125;The number of cards in each chunk of the parallel chunks used during card table scanning</div><div class="line">    uintx ParGCDesiredObjsFromOverflowList          = 20                                  &#123;product&#125;The desired number of objects to claim from the overflow list</div><div class="line">    uintx ParGCStridesPerThread                     = 2                                   &#123;diagnostic&#125;The number of strides per worker thread that we divide up the card table scanning work into</div><div class="line">     bool ParGCTrimOverflow                         = true                                &#123;product&#125;Eagerly trim the local overflow lists (when ParGCUseLocalOverflow)</div><div class="line">     bool ParGCUseLocalOverflow                     = false                               &#123;product&#125;Instead of a global overflow list, use local overflow stacks</div><div class="line">     bool ParGCWorkQueueOverflowALot                = false                               &#123;notproduct&#125;Simulate work queue overflow in ParNew</div><div class="line">    uintx ParGCWorkQueueOverflowInterval            = 1000                                &#123;notproduct&#125;An `interval&apos; counter that determines how frequently we simulate overflow; a smaller number increases frequency</div><div class="line">    uintx ParallelGCBufferWastePct                  = 10                                  &#123;product&#125;Wasted fraction of parallel allocation buffer</div><div class="line">     bool ParallelGCRetainPLAB                      = false                               &#123;diagnostic&#125;Retain parallel allocation buffers across scavenges; it is disabled because this currently conflicts with parallel card scanning under certain conditions.</div><div class="line">    uintx ParallelGCThreads                         = 0                                   &#123;product&#125;Number of parallel threads parallel gc will use</div><div class="line">     bool ParallelGCVerbose                         = false                               &#123;product&#125;Verbose output for parallel gc</div><div class="line">    uintx ParallelOldDeadWoodLimiterMean            = 50                                  &#123;product&#125;The mean used by the parallel compact dead wood limiter (a number between 0-100)</div><div class="line">    uintx ParallelOldDeadWoodLimiterStdDev          = 80                                  &#123;product&#125;The standard deviation used by the parallel compact dead wood limiter (a number between 0-100)</div><div class="line">     bool ParallelOldGCSplitALot                    = false                               &#123;develop&#125;Provoke splitting (copying data from a young gen space to multiple destination spaces)</div><div class="line">    uintx ParallelOldGCSplitInterval                = 3                                   &#123;develop&#125;How often to provoke splitting a young gen space</div><div class="line">     bool ParallelRefProcBalancingEnabled           = true                                &#123;product&#125;Enable balancing of reference processing queues</div><div class="line">     bool ParallelRefProcEnabled                    = false                               &#123;product&#125;Enable parallel reference processing whenever possible</div><div class="line">     bool PartialPeelAtUnsignedTests                = true                                &#123;C2 product&#125;Partial peel at unsigned tests if no signed test exists</div><div class="line">     bool PartialPeelLoop                           = true                                &#123;C2 product&#125;Partial peel (rotate) loops</div><div class="line">     intx PartialPeelNewPhiDelta                    = 0                                   &#123;C2 product&#125;Additional phis that can be created by partial peeling</div><div class="line">     bool PatchALot                                 = false                               &#123;C1 develop&#125;Marks all fields as having unloaded classes</div><div class="line">     bool PauseAtExit                               = false                               &#123;diagnostic&#125;Pause and wait for keypress on exit if a debugger is attached</div><div class="line">     bool PauseAtStartup                            = false                               &#123;diagnostic&#125;Causes the VM to pause at startup time and wait for the pause file to be removed (default: ./vm.paused.&lt;pid&gt;)</div><div class="line">    ccstr PauseAtStartupFile                        =                                     &#123;diagnostic&#125;The file to create and for whose removal to await when pausing at startup. (default: ./vm.paused.&lt;pid&gt;)</div><div class="line">    uintx PausePadding                              = 1                                   &#123;product&#125;How much buffer to keep for pause time</div><div class="line">     intx PerBytecodeRecompilationCutoff            = 200                                 &#123;product&#125;Per-BCI limit on repeated recompilation (-1=&gt;&apos;Inf&apos;)</div><div class="line">     intx PerBytecodeTrapLimit                      = 4                                   &#123;product&#125;Limit on traps (of one kind) at a particular BCI</div><div class="line">     intx PerMethodRecompilationCutoff              = 400                                 &#123;product&#125;After recompiling N times, stay in the interpreter (-1=&gt;&apos;Inf&apos;)</div><div class="line">     intx PerMethodTrapLimit                        = 100                                 &#123;product&#125;Limit on traps (of one kind) in a method (includes inlines)</div><div class="line">     bool PerfAllowAtExitRegistration               = false                               &#123;product&#125;Allow registration of atexit() methods</div><div class="line">     bool PerfBypassFileSystemCheck                 = false                               &#123;product&#125;Bypass Win32 file system criteria checks (Windows Only)</div><div class="line">     intx PerfDataMemorySize                        = 32768                               &#123;product&#125;Size of performance data memory region. Will be rounded up to a multiple of the native os page size.</div><div class="line">     intx PerfDataSamplingInterval                  = 50                                  &#123;product&#125;Data sampling interval (in milliseconds)</div><div class="line">    ccstr PerfDataSaveFile                          =                                     &#123;product&#125;Save PerfData memory to the specified absolute pathname. The string %p in the file name (if present) will be replaced by pid</div><div class="line">     bool PerfDataSaveToFile                        = false                               &#123;product&#125;Save PerfData memory to hsperfdata_&lt;pid&gt; file on exit</div><div class="line">     bool PerfDisableSharedMem                      = false                               &#123;product&#125;Store performance data in standard memory</div><div class="line">     intx PerfMaxStringConstLength                  = 1024                                &#123;product&#125;Maximum PerfStringConstant string length before truncation</div><div class="line">     bool PerfTraceDataCreation                     = false                               &#123;develop&#125;Trace creation of Performance Data Entries</div><div class="line">     bool PerfTraceMemOps                           = false                               &#123;develop&#125;Trace PerfMemory create/attach/detach calls</div><div class="line">     bool PinAllInstructions                        = false                               &#123;C1 develop&#125;All instructions are pinned</div><div class="line">     bool PoisonOSREntry                            = true                                &#123;C2 develop&#125;Detect abnormal calls to OSR code</div><div class="line">     intx PreInflateSpin                            = 10                                  &#123;pd product&#125;Number of times to spin wait before inflation</div><div class="line">    uintx PreallocatedOutOfMemoryErrorCount         = 4                                   &#123;develop&#125;Number of OutOfMemoryErrors preallocated with backtrace</div><div class="line">     bool PreferInterpreterNativeStubs              = false                               &#123;pd product&#125;Use always interpreter stubs for native methods invoked via interpreter</div><div class="line">     intx PrefetchCopyIntervalInBytes               = -1                                  &#123;product&#125;How far ahead to prefetch destination area (&lt;= 0 means off)</div><div class="line">     intx PrefetchFieldsAhead                       = -1                                  &#123;product&#125;How many fields ahead to prefetch in oop scan (&lt;= 0 means off)</div><div class="line">     intx PrefetchScanIntervalInBytes               = -1                                  &#123;product&#125;How far ahead to prefetch scan area (&lt;= 0 means off)</div><div class="line">     bool PreserveAllAnnotations                    = false                               &#123;product&#125;Preserve RuntimeInvisibleAnnotations as well as RuntimeVisibleAnnotations</div><div class="line">     bool PreserveFramePointer                      = false                               &#123;pd product&#125;Use the FP register for holding the frame pointer and not as a general purpose register.</div><div class="line">    uintx PretenureSizeThreshold                    = 0                                   &#123;product&#125;Maximum size in bytes of objects allocated in DefNew generation; zero means no maximum</div><div class="line">     bool PrintAdapterHandlers                      = false                               &#123;diagnostic&#125;Print code generated for i2c/c2i adapters</div><div class="line">     bool PrintAdaptiveSizePolicy                   = false                               &#123;product&#125;Print information about AdaptiveSizePolicy</div><div class="line">     bool PrintAssembly                             = false                               &#123;diagnostic&#125;Print assembly code (using external disassembler.so)</div><div class="line">    ccstr PrintAssemblyOptions                      =                                     &#123;diagnostic&#125;Print options string passed to disassembler.so</div><div class="line">     bool PrintBailouts                             = false                               &#123;C1 develop&#125;Print bailout and its reason</div><div class="line">     bool PrintBiasedLockingStatistics              = false                               &#123;diagnostic&#125;Print statistics of biased locking in JVM</div><div class="line">     bool PrintBlockElimination                     = false                               &#123;C1 develop&#125;Print basic block elimination</div><div class="line">     bool PrintBytecodeHistogram                    = false                               &#123;develop&#125;Print histogram of the executed bytecodes</div><div class="line">     bool PrintBytecodePairHistogram                = false                               &#123;develop&#125;Print histogram of the executed bytecode pairs</div><div class="line">     bool PrintC1Statistics                         = false                               &#123;C1 notproduct&#125;Print Compiler1 statistics</div><div class="line">     bool PrintCEE                                  = false                               &#123;C1 develop&#125;Print Conditional Expression Elimination</div><div class="line">     bool PrintCFG                                  = false                               &#123;C1 notproduct&#125;Print control flow graph after each change</div><div class="line">     bool PrintCFG0                                 = false                               &#123;C1 notproduct&#125;Print control flow graph after construction</div><div class="line">     bool PrintCFG1                                 = false                               &#123;C1 notproduct&#125;Print control flow graph after optimizations</div><div class="line">     bool PrintCFG2                                 = false                               &#123;C1 notproduct&#125;Print control flow graph before code generation</div><div class="line">     bool PrintCFGBlockFreq                         = false                               &#123;C2 develop&#125;Print CFG block freqencies</div><div class="line">     bool PrintCFGToFile                            = false                               &#123;C1 develop&#125;print control flow graph to a separate file during compilation</div><div class="line">     bool PrintCMSInitiationStatistics              = false                               &#123;product&#125;Statistics for initiating a CMS collection</div><div class="line">     intx PrintCMSStatistics                        = 0                                   &#123;product&#125;Statistics for CMS</div><div class="line">     bool PrintCanonicalization                     = false                               &#123;C1 develop&#125;Print graph node canonicalization</div><div class="line">     bool PrintClassHistogram                       = false                               &#123;manageable&#125;Print a histogram of class instances</div><div class="line">     bool PrintClassHistogramAfterFullGC            = false                               &#123;manageable&#125;Print a class histogram after any major stop-world GC</div><div class="line">     bool PrintClassHistogramBeforeFullGC           = false                               &#123;manageable&#125;Print a class histogram before any major stop-world GC</div><div class="line">     bool PrintClassStatistics                      = false                               &#123;notproduct&#125;Print class statistics at end of run</div><div class="line">     bool PrintCodeCache                            = false                               &#123;product&#125;Print the code cache memory usage when exiting</div><div class="line">     bool PrintCodeCache2                           = false                               &#123;develop&#125;Print detailed usage information on the code cache when exiting</div><div class="line">     bool PrintCodeCacheExtension                   = false                               &#123;develop&#125;Print extension of code cache</div><div class="line">     bool PrintCodeCacheOnCompilation               = false                               &#123;product&#125;Print the code cache memory usage each time a method is compiled</div><div class="line">     bool PrintCommandLineFlags                     = false                               &#123;product&#125;Print flags specified on command line or set by ergonomics</div><div class="line">     bool PrintCompilation                          = false                               &#123;product&#125;Print compilations</div><div class="line">     bool PrintCompilation2                         = false                               &#123;diagnostic&#125;Print additional statistics per compilation</div><div class="line">     bool PrintCompressedOopsMode                   = false                               &#123;diagnostic&#125;Print compressed oops base address and encoding mode</div><div class="line">     bool PrintConcurrentLocks                      = false                               &#123;manageable&#125;Print java.util.concurrent locks in thread dump</div><div class="line">     bool PrintDTraceDOF                            = false                               &#123;diagnostic&#125;Print the DTrace DOF passed to the system for JSDT probes</div><div class="line">     bool PrintDebugInfo                            = false                               &#123;develop&#125;Print debug information for all nmethods when generated</div><div class="line">     bool PrintDependencies                         = false                               &#123;develop&#125;Print dependency information for all nmethods when generated</div><div class="line">     bool PrintDominators                           = false                               &#123;C2 develop&#125;Print out dominator trees for GVN</div><div class="line">     bool PrintEliminateAllocations                 = false                               &#123;C2 notproduct&#125;Print out when allocations are eliminated</div><div class="line">     bool PrintEliminateLocks                       = false                               &#123;C2 notproduct&#125;Print out when locks are eliminated</div><div class="line">     bool PrintEscapeAnalysis                       = false                               &#123;C2 notproduct&#125;Print the results of escape analysis</div><div class="line">     bool PrintExceptionHandlers                    = false                               &#123;develop&#125;Print exception handler tables for all nmethods when generated</div><div class="line">     intx PrintFLSCensus                            = 0                                   &#123;product&#125;Census for CMS&apos; FreeListSpace</div><div class="line">     intx PrintFLSStatistics                        = 0                                   &#123;product&#125;Statistics for CMS&apos; FreeListSpace</div><div class="line">     bool PrintFieldLayout                          = false                               &#123;notproduct&#125;Print field layout for each class</div><div class="line">     bool PrintFlagsFinal                           = false                               &#123;product&#125;Print all VM flags after argument and ergonomic processing</div><div class="line">     bool PrintFlagsInitial                         = false                               &#123;product&#125;Print all VM flags before argument processing and exit VM</div><div class="line">     bool PrintFlagsWithComments                    = false                               &#123;notproduct&#125;Print all VM flags with default values and descriptions and exit</div><div class="line">     bool PrintFrameConverterAssembly               = false                               &#123;C2 notproduct&#125;Print New compiler assembly output for frame converters</div><div class="line">     bool PrintGC                                   = false                               &#123;manageable&#125;Print message at garbage collection</div><div class="line">     bool PrintGCApplicationConcurrentTime          = false                               &#123;product&#125;Print the time the application has been running</div><div class="line">     bool PrintGCApplicationStoppedTime             = false                               &#123;product&#125;Print the time the application has been stopped</div><div class="line">     bool PrintGCCause                              = true                                &#123;product&#125;Include GC cause in GC logging</div><div class="line">     bool PrintGCDateStamps                         = false                               &#123;manageable&#125;Print date stamps at garbage collection</div><div class="line">     bool PrintGCDetails                            = false                               &#123;manageable&#125;Print more details at garbage collection</div><div class="line">     bool PrintGCID                                 = false                               &#123;manageable&#125;Print an identifier for each garbage collection</div><div class="line">     bool PrintGCTaskTimeStamps                     = false                               &#123;product&#125;Print timestamps for individual gc worker thread tasks</div><div class="line">     bool PrintGCTimeStamps                         = false                               &#123;manageable&#125;Print timestamps at garbage collection</div><div class="line">     bool PrintHeapAtGC                             = false                               &#123;product rw&#125;Print heap layout before and after each GC</div><div class="line">     bool PrintHeapAtGCExtended                     = false                               &#123;product rw&#125;Print extended information about the layout of the heap when -XX:+PrintHeapAtGC is set</div><div class="line">     bool PrintHeapAtSIGBREAK                       = true                                &#123;product&#125;Print heap layout in response to SIGBREAK</div><div class="line">     bool PrintIR                                   = false                               &#123;C1 notproduct&#125;Print full intermediate representation after each change</div><div class="line">     bool PrintIR0                                  = false                               &#123;C1 notproduct&#125;Print full intermediate representation after construction</div><div class="line">     bool PrintIR1                                  = false                               &#123;C1 notproduct&#125;Print full intermediate representation after optimizations</div><div class="line">     bool PrintIR2                                  = false                               &#123;C1 notproduct&#125;Print full intermediate representation before code generation</div><div class="line">     bool PrintIRDuringConstruction                 = false                               &#123;C1 notproduct&#125;Print IR as it&apos;s being constructed (helpful for debugging frontend)</div><div class="line">     bool PrintIRWithLIR                            = false                               &#123;C1 notproduct&#125;Print IR instructions with generated LIR</div><div class="line">     bool PrintIdeal                                = false                               &#123;C2 notproduct&#125;Print ideal graph before code generation</div><div class="line">    ccstr PrintIdealGraphAddress                    = 127.0.0.1                           &#123;C2 notproduct&#125;IP address to connect to visualizer</div><div class="line">    ccstr PrintIdealGraphFile                       =                                     &#123;C2 notproduct&#125;File to dump ideal graph to.  If set overrides the use of the network</div><div class="line">     intx PrintIdealGraphLevel                      = 0                                   &#123;C2 develop&#125;Print ideal graph to XML file / network interface. By default attempts to connect to the visualizer on a socket.</div><div class="line">     intx PrintIdealGraphPort                       = 4444                                &#123;C2 develop&#125;Ideal graph printer to network port</div><div class="line">     bool PrintIdealNodeCount                       = false                               &#123;C2 notproduct&#125;Print liveness counts of ideal nodes</div><div class="line">     bool PrintInitialBlockList                     = false                               &#123;C1 notproduct&#125;Print block list of BlockListBuilder</div><div class="line">     bool PrintInlining                             = false                               &#123;diagnostic&#125;Print inlining optimizations</div><div class="line">     bool PrintInterpreter                          = false                               &#123;diagnostic&#125;Print the generated interpreter code</div><div class="line">     bool PrintIntrinsics                           = false                               &#123;C2 diagnostic&#125;prints attempted and successful inlining of intrinsics</div><div class="line">     bool PrintJNIGCStalls                          = false                               &#123;product&#125;Print diagnostic message when GC is stalled by JNI critical section</div><div class="line">     bool PrintJNIResolving                         = false                               &#123;product&#125;Used to implement -v:jni</div><div class="line">     bool PrintJVMWarnings                          = false                               &#123;develop&#125;Print warnings for unimplemented JVM functions</div><div class="line">     bool PrintLIR                                  = false                               &#123;C1 develop&#125;print low-level IR</div><div class="line">     bool PrintLIRWithAssembly                      = false                               &#123;C1 notproduct&#125;Show LIR instruction with generated assembly</div><div class="line">     bool PrintLockStatistics                       = false                               &#123;C2 notproduct&#125;Print precise statistics on the dynamic lock usage</div><div class="line">     bool PrintMalloc                               = false                               &#123;develop&#125;Print all malloc/free calls</div><div class="line">     bool PrintMallocFree                           = false                               &#123;notproduct&#125;Trace calls to C heap malloc/free allocation</div><div class="line">     bool PrintMallocStatistics                     = false                               &#123;develop&#125;Print malloc/free statistics</div><div class="line">     bool PrintMethodData                           = false                               &#123;develop&#125;Print the results of +ProfileInterpreter at end of run</div><div class="line">     bool PrintMethodFlushing                       = false                               &#123;develop&#125;Print the nmethods being flushed</div><div class="line">     bool PrintMethodFlushingStatistics             = false                               &#123;diagnostic&#125;print statistics about method flushing</div><div class="line">     bool PrintMethodHandleStubs                    = false                               &#123;diagnostic&#125;Print generated stub code for method handles</div><div class="line">     bool PrintMethodStatistics                     = false                               &#123;notproduct&#125;Print method statistics at end of run</div><div class="line">     bool PrintMiscellaneous                        = false                               &#123;develop&#125;Print uncategorized debugging information (requires +Verbose)</div><div class="line">     bool PrintNMTStatistics                        = false                               &#123;diagnostic&#125;Print native memory tracking summary data if it is on</div><div class="line">     bool PrintNMethods                             = false                               &#123;diagnostic&#125;Print assembly code for nmethods when generated</div><div class="line">     bool PrintNativeNMethods                       = false                               &#123;diagnostic&#125;Print assembly code for native nmethods when generated</div><div class="line">     bool PrintNotLoaded                            = false                               &#123;C1 develop&#125;Prints where classes are not loaded during code generation</div><div class="line">     bool PrintNullCheckElimination                 = false                               &#123;C1 develop&#125;Print null check elimination</div><div class="line">     bool PrintOldPLAB                              = false                               &#123;product&#125;Print (old gen) promotion LAB&apos;s sizing decisions</div><div class="line">     bool PrintOopAddress                           = false                               &#123;product&#125;Always print the location of the oop</div><div class="line">     bool PrintOptimizePtrCompare                   = false                               &#123;C2 notproduct&#125;Print information about optimized pointers compare</div><div class="line">     bool PrintOptimizeStringConcat                 = false                               &#123;C2 notproduct&#125;Print information about transformations performed on Strings</div><div class="line">     bool PrintOpto                                 = false                               &#123;C2 notproduct&#125;Print compiler2 attempts</div><div class="line">     bool PrintOptoAssembly                         = false                               &#123;C2 notproduct&#125;Print New compiler assembly output</div><div class="line">     bool PrintOptoInlining                         = false                               &#123;C2 notproduct&#125;Print compiler2 inlining decisions</div><div class="line">     bool PrintOptoPeephole                         = false                               &#123;C2 notproduct&#125;Print New compiler peephole replacements</div><div class="line">     bool PrintOptoStatistics                       = false                               &#123;C2 notproduct&#125;Print New compiler statistics</div><div class="line">     bool PrintPLAB                                 = false                               &#123;product&#125;Print (survivor space) promotion LAB&apos;s sizing decisions</div><div class="line">     bool PrintParallelOldGCPhaseTimes              = false                               &#123;product&#125;Print the time taken by each phase in ParallelOldGC (PrintGCDetails must also be enabled)</div><div class="line">     bool PrintParseStatistics                      = false                               &#123;C2 notproduct&#125;Print nodes, transforms and new values made per bytecode parsed</div><div class="line">     bool PrintPhiFunctions                         = false                               &#123;C1 notproduct&#125;Print phi functions when they are created and simplified</div><div class="line">     bool PrintPreciseBiasedLockingStatistics       = false                               &#123;C2 diagnostic&#125;Print per-lock-site statistics of biased locking in JVM</div><div class="line">     bool PrintPreciseRTMLockingStatistics          = false                               &#123;C2 diagnostic&#125;Print per-lock-site statistics of rtm locking in JVM</div><div class="line">     bool PrintPromotionFailure                     = false                               &#123;product&#125;Print additional diagnostic information following promotion failure</div><div class="line">     bool PrintReferenceGC                          = false                               &#123;product&#125;Print times spent handling reference objects during GC (enabled only when PrintGCDetails)</div><div class="line">     bool PrintRelocations                          = false                               &#123;develop&#125;Print relocation information for all nmethods when generated</div><div class="line">     bool PrintRewrites                             = false                               &#123;notproduct&#125;Print methods that are being rewritten</div><div class="line">     bool PrintSafepointStatistics                  = false                               &#123;product&#125;Print statistics about safepoint synchronization</div><div class="line">     intx PrintSafepointStatisticsCount             = 300                                 &#123;product&#125;Total number of safepoint statistics collected before printing them out</div><div class="line">     intx PrintSafepointStatisticsTimeout           = -1                                  &#123;product&#125;Print safepoint statistics only when safepoint takes more than PrintSafepointSatisticsTimeout in millis</div><div class="line">     bool PrintSharedArchiveAndExit                 = false                               &#123;product&#125;Print shared archive file contents</div><div class="line">     bool PrintSharedDictionary                     = false                               &#123;product&#125;If PrintSharedArchiveAndExit is true, also print the shared dictionary</div><div class="line">     bool PrintSharedSpaces                         = false                               &#123;product&#125;Print usage of shared spaces</div><div class="line">     bool PrintSignatureHandlers                    = false                               &#123;diagnostic&#125;Print code generated for native method signature handlers</div><div class="line">     bool PrintSimpleStubs                          = false                               &#123;C1 notproduct&#125;Print SimpleStubs</div><div class="line">     bool PrintStringDeduplicationStatistics        = false                               &#123;product&#125;Print string deduplication statistics</div><div class="line">     bool PrintStringTableStatistics                = false                               &#123;product&#125;print statistics about the StringTable and SymbolTable</div><div class="line">     bool PrintStubCode                             = false                               &#123;diagnostic&#125;Print generated stub code</div><div class="line">     bool PrintSymbolTableSizeHistogram             = false                               &#123;notproduct&#125;print histogram of the symbol table</div><div class="line">     bool PrintSystemDictionaryAtExit               = false                               &#123;notproduct&#125;Print the system dictionary at exit</div><div class="line">     bool PrintTLAB                                 = false                               &#123;product&#125;Print various TLAB related information</div><div class="line">     bool PrintTenuringDistribution                 = false                               &#123;product&#125;Print tenuring age information</div><div class="line">     bool PrintTieredEvents                         = false                               &#123;product&#125;Print tiered events notifications</div><div class="line">     bool PrintUnsafeOptimization                   = false                               &#123;C1 develop&#125;Print optimization of raw unsafe ops</div><div class="line">     bool PrintVMMessages                           = true                                &#123;develop&#125;Print VM messages on console</div><div class="line">     bool PrintVMOptions                            = false                               &#123;product&#125;Print flags that appeared on the command line</div><div class="line">     bool PrintVMQWaitTime                          = false                               &#123;product&#125;Print out the waiting time in VM operation queue</div><div class="line">     bool PrintValueNumbering                       = false                               &#123;C1 develop&#125;Print Value Numbering</div><div class="line">     bool PrintVtableStats                          = false                               &#123;notproduct&#125;print vtables stats at end of run</div><div class="line">     bool PrintVtables                              = false                               &#123;develop&#125;print vtables when printing klass</div><div class="line">     bool PrintWarnings                             = true                                &#123;product&#125;Print JVM warnings to output stream</div><div class="line">    uintx ProcessDistributionStride                 = 4                                   &#123;product&#125;Stride through processors when distributing processes</div><div class="line">     bool ProfileDynamicTypes                       = true                                &#123;C2 diagnostic&#125;do extra type profiling and use it more aggressively</div><div class="line">     bool ProfileInterpreter                        = true                                &#123;pd product&#125;Profile at the bytecode level during interpretation</div><div class="line">     bool ProfileIntervals                          = false                               &#123;product&#125;Print profiles for each interval (see ProfileIntervalsTicks)</div><div class="line">     intx ProfileIntervalsTicks                     = 100                                 &#123;product&#125;Number of ticks between printing of interval profile (+ProfileIntervals)</div><div class="line">     intx ProfileMaturityPercentage                 = 20                                  &#123;product&#125;number of method invocations/branches (expressed as % of CompileThreshold) before using the method&apos;s profile</div><div class="line">     bool ProfileTraps                              = true                                &#123;pd develop&#125;Profile deoptimization traps at the bytecode level</div><div class="line">     bool ProfileVM                                 = false                               &#123;product&#125;Profile ticks that fall within VM (either in the VM Thread or VM code called through stubs)</div><div class="line">     bool ProfilerCheckIntervals                    = false                               &#123;notproduct&#125;Collect and print information on spacing of profiler ticks</div><div class="line">     intx ProfilerNodeSize                          = 1024                                &#123;develop&#125;Size in K to allocate for the Profile Nodes of each thread</div><div class="line">     intx ProfilerNumberOfCompiledMethods           = 25                                  &#123;develop&#125;Number of compiled methods to show in profile</div><div class="line">     intx ProfilerNumberOfInterpretedMethods        = 25                                  &#123;develop&#125;Number of interpreted methods to show in profile</div><div class="line">     intx ProfilerNumberOfRuntimeStubNodes          = 25                                  &#123;develop&#125;Number of runtime stub nodes to show in profile</div><div class="line">     intx ProfilerNumberOfStubMethods               = 25                                  &#123;develop&#125;Number of stub methods to show in profile</div><div class="line">     intx ProfilerPCTickThreshold                   = 15                                  &#123;develop&#125;Number of ticks in a PC buckets to be a hotspot</div><div class="line">     bool ProfilerPrintByteCodeStatistics           = false                               &#123;product&#125;Print bytecode statistics when dumping profiler output</div><div class="line">     bool ProfilerRecordPC                          = false                               &#123;product&#125;Collect ticks for each 16 byte interval of compiled code</div><div class="line">    uintx PromotedPadding                           = 3                                   &#123;product&#125;How much buffer to keep for promotion failure</div><div class="line">     bool PromotionFailureALot                      = false                               &#123;notproduct&#125;Use promotion failure handling on every youngest generation collection</div><div class="line">    uintx PromotionFailureALotCount                 = 1000                                &#123;develop&#125;Number of promotion failures occurring at ParGCAllocBuffer refill attempts (ParNew) or promotion attempts (other young collectors)</div><div class="line">    uintx PromotionFailureALotInterval              = 5                                   &#123;develop&#125;Total collections between promotion failures alot</div><div class="line">     bool ProtectionDomainVerification              = true                                &#123;develop&#125;Verify protection domain before resolution in system dictionary</div><div class="line">    uintx QueuedAllocationWarningCount              = 0                                   &#123;product&#125;Number of times an allocation that queues behind a GC will retry before printing a warning</div><div class="line">    uintx RTMRetryCount                             = 5                                   &#123;ARCH product&#125;Number of RTM retries on lock abort or busy</div><div class="line">     bool RangeCheckElimination                     = true                                &#123;product&#125;Eliminate range checks</div><div class="line">     bool RangeLimitCheck                           = true                                &#123;C2 diagnostic&#125;Additional overflow checks during range check elimination</div><div class="line">     intx ReadPrefetchInstr                         = 0                                   &#123;ARCH product&#125;Prefetch instruction to prefetch ahead</div><div class="line">     bool ReassociateInvariants                     = true                                &#123;C2 product&#125;Enable reassociation of expressions with loop invariants.</div><div class="line">     bool ReduceBulkZeroing                         = true                                &#123;C2 product&#125;When bulk-initializing, try to avoid needless zeroing</div><div class="line">     bool ReduceFieldZeroing                        = true                                &#123;C2 product&#125;When initializing fields, try to avoid needless zeroing</div><div class="line">     bool ReduceInitialCardMarks                    = true                                &#123;C2 product&#125;When initializing fields, try to avoid needless card marks</div><div class="line">     bool ReduceSignalUsage                         = false                               &#123;product&#125;Reduce the use of OS signals in Java and/or the VM</div><div class="line">     intx RefDiscoveryPolicy                        = 0                                   &#123;product&#125;Select type of reference discovery policy: reference-based(0) or referent-based(1)</div><div class="line">     bool ReflectionWrapResolutionErrors            = true                                &#123;product&#125;Temporary flag for transition to AbstractMethodError wrapped in InvocationTargetException. See 6531596</div><div class="line">     intx RegisterCostAreaRatio                     = 16000                               &#123;C2 pd develop&#125;Spill selection in reg allocator: scale area by (X/64K) before adding cost</div><div class="line">     bool RegisterFinalizersAtInit                  = true                                &#123;product&#125;Register finalizable objects at end of Object.&lt;init&gt; or after allocation</div><div class="line">     bool RegisterReferences                        = true                                &#123;develop&#125;Tell whether the VM should register soft/weak/final/phantom references</div><div class="line">     bool RelaxAccessControlCheck                   = false                               &#123;product&#125;Relax the access control checks in the verifier</div><div class="line">     bool RenumberLiveNodes                         = true                                &#123;C2 develop&#125;Renumber live nodes</div><div class="line">     bool ReplayCompiles                            = false                               &#123;develop&#125;Enable replay of compilations from ReplayDataFile</div><div class="line">    ccstr ReplayDataFile                            =                                     &#123;product&#125;File containing compilation replay information[default: ./replay_pid%p.log] (%p replaced with pid)</div><div class="line">     bool ReplayIgnoreInitErrors                    = false                               &#123;develop&#125;Ignore exceptions thrown during initialization for replay</div><div class="line">     intx ReplaySuppressInitializers                = 2                                   &#123;develop&#125;Control handling of class initialization during replay: 0 - don&apos;t do anything special; 1 - treat all class initializers as empty; 2 - treat class initializers for application classes as empty; 3 - allow all class initializers to run during bootstrap but     pretend they are empty after starting replay</div><div class="line">     bool RequireSharedSpaces                       = false                               &#123;product&#125;Require shared spaces for metadata</div><div class="line">    uintx ReservedCodeCacheSize                     = 50331648                            &#123;pd product&#125;Reserved code cache size (in bytes) - maximum code cache size</div><div class="line">     bool ResizeOldPLAB                             = true                                &#123;product&#125;Dynamically resize (old gen) promotion LAB&apos;s</div><div class="line">     bool ResizePLAB                                = true                                &#123;product&#125;Dynamically resize (survivor space) promotion LAB&apos;s</div><div class="line">     bool ResizeTLAB                                = true                                &#123;pd product&#125;Dynamically resize TLAB size for threads</div><div class="line">     bool RestoreMXCSROnJNICalls                    = false                               &#123;product&#125;Restore MXCSR when returning from JNI calls</div><div class="line">     bool RestrictContended                         = true                                &#123;product&#125;Restrict @Contended to trusted classes</div><div class="line">     bool RewriteBytecodes                          = true                                &#123;pd product&#125;Allow rewriting of bytecodes (bytecodes are not immutable)</div><div class="line">     bool RewriteFrequentPairs                      = true                                &#123;pd product&#125;Rewrite frequently used bytecode pairs into a single bytecode</div><div class="line">     bool RotateCMSCollectionTypes                  = false                               &#123;develop&#125;Rotate the CMS collections among concurrent and STW</div><div class="line">     bool RoundFPResults                            = true                                &#123;C1 pd develop&#125;Indicates whether rounding is needed for floating point results</div><div class="line">     bool SafepointALot                             = false                               &#123;develop&#125;Generate a lot of safepoints. This works with GuaranteedSafepointInterval</div><div class="line">     intx SafepointPollOffset                       = 256                                 &#123;C1 pd product&#125;Offset added to polling address (Intel only)</div><div class="line">     intx SafepointSpinBeforeYield                  = 2000                                &#123;product&#125;(Unstable)</div><div class="line">     bool SafepointTimeout                          = false                               &#123;product&#125;Time out and warn or fail after SafepointTimeoutDelay milliseconds if failed to reach safepoint</div><div class="line">     intx SafepointTimeoutDelay                     = 10000                               &#123;product&#125;Delay in milliseconds for option SafepointTimeout</div><div class="line">     bool ScavengeALot                              = false                               &#123;notproduct&#125;Force scavenge at every Nth exit from the runtime system (N=ScavengeALotInterval)</div><div class="line">     intx ScavengeALotInterval                      = 1                                   &#123;notproduct&#125;Interval between which scavenge will occur with +ScavengeALot</div><div class="line">     bool ScavengeBeforeFullGC                      = true                                &#123;product&#125;Scavenge youngest generation before each full GC, used with UseParallelGC</div><div class="line">     intx ScavengeRootsInCode                       = 2                                   &#123;diagnostic&#125;0: do not allow scavengable oops in the code cache; 1: allow scavenging from the code cache; 2: emit as many constants as the compiler can see</div><div class="line">     bool ScavengeWithObjectsInToSpace              = false                               &#123;develop&#125;Allow scavenges to occur when to-space contains objects</div><div class="line">    uintx SegmentedHeapDumpThreshold                = 2147483648                          &#123;develop&#125;Generate a segmented heap dump (JAVA PROFILE 1.0.2 format) when the heap usage is larger than this</div><div class="line">     bool SelectivePhiFunctions                     = true                                &#123;C1 develop&#125;create phi functions at loop headers only when necessary</div><div class="line">     intx SelfDestructTimer                         = 0                                   &#123;product&#125;Will cause VM to terminate after a given time (in minutes) (0 means off)</div><div class="line">     bool SerializeVMOutput                         = true                                &#123;diagnostic&#125;Use a mutex to serialize output to tty and LogFile</div><div class="line">     bool ShareVtableStubs                          = true                                &#123;pd develop&#125;Share vtable stubs (smaller code but worse branch prediction</div><div class="line">    ccstr SharedArchiveFile                         =                                     &#123;diagnostic&#125;Override the default location of the CDS archive file</div><div class="line">    uintx SharedBaseAddress                         = 34359738368                         &#123;product&#125;Address to allocate shared memory region for class data</div><div class="line">    ccstr SharedClassListFile                       =                                     &#123;product&#125;Override the default CDS class list</div><div class="line">    uintx SharedMiscCodeSize                        = 122880                              &#123;product&#125;Size of the shared miscellaneous code area (in bytes)</div><div class="line">    uintx SharedMiscDataSize                        = 4194304                             &#123;product&#125;Size of the shared miscellaneous data area (in bytes)</div><div class="line">    uintx SharedReadOnlySize                        = 16777216                            &#123;product&#125;Size of read-only space for metadata (in bytes)</div><div class="line">    uintx SharedReadWriteSize                       = 16777216                            &#123;product&#125;Size of read-write space for metadata (in bytes)</div><div class="line">     bool ShowHiddenFrames                          = false                               &#123;diagnostic&#125;show method handle implementation frames (usually hidden)</div><div class="line">     bool ShowMessageBoxOnError                     = false                               &#123;product&#125;Keep process alive on VM fatal error</div><div class="line">     bool ShowSafepointMsgs                         = false                               &#123;develop&#125;Show message about safepoint synchronization</div><div class="line">     bool SoftMatchFailure                          = false                               &#123;C2 develop&#125;If the DFA fails to match a node, print a message and bail out</div><div class="line">     intx SoftRefLRUPolicyMSPerMB                   = 1000                                &#123;product&#125;Number of milliseconds per MB of free space in the heap</div><div class="line">     bool SparcV9RegsHiBitsZero                     = true                                &#123;C2 develop&#125;Assume Sparc V9 I&amp;L registers on V8+ systems are zero-extended</div><div class="line">     bool SpecialArraysEquals                       = true                                &#123;C2 develop&#125;special version of Arrays.equals(char[],char[])</div><div class="line">     bool SpecialEncodeISOArray                     = true                                &#123;C2 product&#125;special version of ISO_8859_1$Encoder.encodeISOArray</div><div class="line">     bool SpecialStringCompareTo                    = true                                &#123;C2 develop&#125;special version of string compareTo</div><div class="line">     bool SpecialStringEquals                       = true                                &#123;C2 develop&#125;special version of string equals</div><div class="line">     bool SpecialStringIndexOf                      = true                                &#123;C2 develop&#125;special version of string indexOf</div><div class="line">     bool SplitIfBlocks                             = true                                &#123;C2 product&#125;Clone compares and control flow through merge points to fold some branches</div><div class="line">     intx StackPrintLimit                           = 100                                 &#123;develop&#125;number of stack frames to print in VM-level stack dump</div><div class="line">     intx StackRedPages                             = 1                                   &#123;pd product&#125;Number of red zone (unrecoverable overflows) pages</div><div class="line">     intx StackShadowPages                          = 22                                  &#123;pd product&#125;Number of shadow zone (for overflow checking) pages this should exceed the depth of the VM and native call stack</div><div class="line">     bool StackTraceInThrowable                     = true                                &#123;product&#125;Collect backtrace in throwable when exception happens</div><div class="line">     intx StackYellowPages                          = 2                                   &#123;pd product&#125;Number of yellow zone (recoverable overflows) pages</div><div class="line">     bool StartAttachListener                       = false                               &#123;product&#125;Always start Attach Listener at VM startup</div><div class="line">     intx StarvationMonitorInterval                 = 200                                 &#123;product&#125;Pause between each check (in milliseconds)</div><div class="line">     intx StopInterpreterAt                         = 0                                   &#123;develop&#125;Stop interpreter execution at specified bytecode number</div><div class="line">     bool StressCodeBuffers                         = false                               &#123;develop&#125;Exercise code buffer expansion and other rare state changes</div><div class="line">     bool StressCompiledExceptionHandlers           = false                               &#123;develop&#125;Exercise compiled exception handlers</div><div class="line">     bool StressCriticalJNINatives                  = false                               &#123;notproduct&#125;Exercise register saving code in critical natives</div><div class="line">     bool StressDerivedPointers                     = false                               &#123;notproduct&#125;Force scavenge when a derived pointer is detected on stack after rtm call</div><div class="line">     bool StressGCM                                 = false                               &#123;C2 develop&#125;Randomize instruction scheduling in GCM</div><div class="line">     bool StressLCM                                 = false                               &#123;C2 develop&#125;Randomize instruction scheduling in LCM</div><div class="line">     bool StressLdcRewrite                          = false                               &#123;product&#125;Force ldc -&gt; ldc_w rewrite during RedefineClasses</div><div class="line">     bool StressLinearScan                          = false                               &#123;C1 develop&#125;scramble block order used by LinearScan (stress test)</div><div class="line">     bool StressLoopInvariantCodeMotion             = false                               &#123;C1 develop&#125;stress loop invariant code motion</div><div class="line">     bool StressMethodComparator                    = false                               &#123;develop&#125;Run the MethodComparator on all loaded methods</div><div class="line">     bool StressRangeCheckElimination               = false                               &#123;C1 develop&#125;stress Range Check Elimination</div><div class="line">     bool StressRecompilation                       = false                               &#123;C2 develop&#125;Recompile each compiled method without subsuming loads or escape analysis.</div><div class="line">     bool StressReflectiveCode                      = false                               &#123;C2 develop&#125;Use inexact types at allocations, etc., to test reflection</div><div class="line">     bool StressRewriter                            = false                               &#123;develop&#125;Stress linktime bytecode rewriting</div><div class="line">     bool StrictSafepointChecks                     = true                                &#123;notproduct&#125;Enable strict checks that safepoints cannot happen for threads that use No_Safepoint_Verifier</div><div class="line">    uintx StringDeduplicationAgeThreshold           = 3                                   &#123;product&#125;A string must reach this age (or be promoted to an old region) to be considered for deduplication</div><div class="line">     bool StringDeduplicationRehashALot             = false                               &#123;diagnostic&#125;Force table rehash every time the table is scanned</div><div class="line">     bool StringDeduplicationResizeALot             = false                               &#123;diagnostic&#125;Force table resize every time the table is scanned</div><div class="line">    uintx StringTableSize                           = 60013                               &#123;product&#125;Number of buckets in the interned String table</div><div class="line">     bool SubsumeLoads                              = true                                &#123;C2 develop&#125;Attempt to compile while subsuming loads into machine instructions.</div><div class="line">     bool SuperWordRTDepCheck                       = false                               &#123;C2 develop&#125;Enable runtime dependency checks.</div><div class="line">ccstrlist SuppressErrorAt                           =                                     &#123;notproduct&#125;List of assertions (file:line) to muzzle</div><div class="line">     bool SuppressFatalErrorMessage                 = false                               &#123;product&#125;Report NO fatal error message (avoid deadlock)</div><div class="line">    uintx SurvivorPadding                           = 3                                   &#123;product&#125;How much buffer to keep for survivor overflow</div><div class="line">    uintx SurvivorRatio                             = 8                                   &#123;product&#125;Ratio of eden/survivor space size</div><div class="line">     intx SuspendRetryCount                         = 50                                  &#123;product&#125;Maximum retry count for an external suspend request</div><div class="line">     intx SuspendRetryDelay                         = 5                                   &#123;product&#125;Milliseconds to delay per retry (* current_retry_count)</div><div class="line">     intx SweeperLogEntries                         = 1024                                &#123;notproduct&#125;Number of records in the ring buffer of sweeper activity</div><div class="line">     intx SyncFlags                                 = 0                                   &#123;product&#125;(Unsafe, Unstable) Experimental Sync flags</div><div class="line">    ccstr SyncKnobs                                 =                                     &#123;product&#125;(Unstable) Various monitor synchronization tunables</div><div class="line">     intx SyncVerbose                               = 0                                   &#123;product&#125;(Unstable)</div><div class="line">    uintx TLABAllocationWeight                      = 35                                  &#123;product&#125;Allocation averaging weight</div><div class="line">    uintx TLABRefillWasteFraction                   = 64                                  &#123;product&#125;Maximum TLAB waste at a refill (internal fragmentation)</div><div class="line">    uintx TLABSize                                  = 0                                   &#123;product&#125;Starting TLAB size (in bytes); zero means set ergonomically</div><div class="line">     bool TLABStats                                 = true                                &#123;product&#125;Provide more detailed and expensive TLAB statistics (with PrintTLAB)</div><div class="line">    uintx TLABWasteIncrement                        = 4                                   &#123;product&#125;Increment allowed waste at slow allocation</div><div class="line">    uintx TLABWasteTargetPercent                    = 1                                   &#123;product&#125;Percentage of Eden that can be wasted</div><div class="line">    uintx TargetPLABWastePct                        = 10                                  &#123;product&#125;Target wasted space in last buffer as percent of overall allocation</div><div class="line">    uintx TargetSurvivorRatio                       = 50                                  &#123;product&#125;Desired percentage of survivor space used after scavenge</div><div class="line">    uintx TenuredGenerationSizeIncrement            = 20                                  &#123;product&#125;Adaptive size percentage change in tenured generation</div><div class="line">    uintx TenuredGenerationSizeSupplement           = 80                                  &#123;product&#125;Supplement to TenuredGenerationSizeIncrement used at startup</div><div class="line">    uintx TenuredGenerationSizeSupplementDecay      = 2                                   &#123;product&#125;Decay factor to TenuredGenerationSizeIncrement</div><div class="line">     intx ThreadPriorityPolicy                      = 0                                   &#123;product&#125;0 : Normal.                                                         VM chooses priorities that are appropriate for normal           applications. On Solaris NORM_PRIORITY and above are mapped     to normal native priority. Java priorities below     NORM_PRIORITY map to lower native priority values. On           Windows applications are allowed to use higher native           priorities. However, with ThreadPriorityPolicy=0, VM will       not use the highest possible native priority,                   THREAD_PRIORITY_TIME_CRITICAL, as it may interfere with         system threads. On Linux thread priorities are ignored          because the OS does not support static priority in              SCHED_OTHER scheduling class which is the only choice for       non-root, non-realtime applications.                        1 : Aggressive.                                                     Java thread priorities map over to the entire range of          native thread priorities. Higher Java thread priorities map     to higher native thread priorities. This policy should be       used with care, as sometimes it can cause performance           degradation in the application and/or the entire system. On     Linux this policy requires root privilege.</div><div class="line">     bool ThreadPriorityVerbose                     = false                               &#123;product&#125;Print priority changes</div><div class="line">    uintx ThreadSafetyMargin                        = 52428800                            &#123;product&#125;Thread safety margin is used on fixed-stack LinuxThreads (on Linux/x86 only) to prevent heap-stack collision. Set to 0 to disable this feature</div><div class="line">     intx ThreadStackSize                           = 1024                                &#123;pd product&#125;Thread Stack Size (in Kbytes)</div><div class="line">    uintx ThresholdTolerance                        = 10                                  &#123;product&#125;Allowed collection cost difference between generations</div><div class="line">     intx Tier0BackedgeNotifyFreqLog                = 10                                  &#123;product&#125;Interpreter (tier 0) invocation notification frequency</div><div class="line">     intx Tier0InvokeNotifyFreqLog                  = 7                                   &#123;product&#125;Interpreter (tier 0) invocation notification frequency</div><div class="line">     intx Tier0ProfilingStartPercentage             = 200                                 &#123;product&#125;Start profiling in interpreter if the counters exceed tier 3 thresholds by the specified percentage</div><div class="line">     intx Tier23InlineeNotifyFreqLog                = 20                                  &#123;product&#125;Inlinee invocation (tiers 2 and 3) notification frequency</div><div class="line">     intx Tier2BackEdgeThreshold                    = 0                                   &#123;product&#125;Back edge threshold at which tier 2 compilation is invoked</div><div class="line">     intx Tier2BackedgeNotifyFreqLog                = 14                                  &#123;product&#125;C1 without MDO (tier 2) invocation notification frequency</div><div class="line">     intx Tier2CompileThreshold                     = 0                                   &#123;product&#125;threshold at which tier 2 compilation is invoked</div><div class="line">     intx Tier2InvokeNotifyFreqLog                  = 11                                  &#123;product&#125;C1 without MDO (tier 2) invocation notification frequency</div><div class="line">     intx Tier3BackEdgeThreshold                    = 60000                               &#123;product&#125;Back edge threshold at which tier 3 OSR compilation is invoked</div><div class="line">     intx Tier3BackedgeNotifyFreqLog                = 13                                  &#123;product&#125;C1 with MDO profiling (tier 3) invocation notification frequency</div><div class="line">     intx Tier3CompileThreshold                     = 2000                                &#123;product&#125;Threshold at which tier 3 compilation is invoked (invocation minimum must be satisfied</div><div class="line">     intx Tier3DelayOff                             = 2                                   &#123;product&#125;If C2 queue size is less than this amount per compiler thread allow methods compiled at tier 2 transition to tier 3</div><div class="line">     intx Tier3DelayOn                              = 5                                   &#123;product&#125;If C2 queue size grows over this amount per compiler thread stop compiling at tier 3 and start compiling at tier 2</div><div class="line">     intx Tier3InvocationThreshold                  = 200                                 &#123;product&#125;Compile if number of method invocations crosses this threshold</div><div class="line">     intx Tier3InvokeNotifyFreqLog                  = 10                                  &#123;product&#125;C1 with MDO profiling (tier 3) invocation notification frequency</div><div class="line">     intx Tier3LoadFeedback                         = 5                                   &#123;product&#125;Tier 3 thresholds will increase twofold when C1 queue size reaches this amount per compiler thread</div><div class="line">     intx Tier3MinInvocationThreshold               = 100                                 &#123;product&#125;Minimum invocation to compile at tier 3</div><div class="line">     intx Tier4BackEdgeThreshold                    = 40000                               &#123;product&#125;Back edge threshold at which tier 4 OSR compilation is invoked</div><div class="line">     intx Tier4CompileThreshold                     = 15000                               &#123;product&#125;Threshold at which tier 4 compilation is invoked (invocation minimum must be satisfied</div><div class="line">     intx Tier4InvocationThreshold                  = 5000                                &#123;product&#125;Compile if number of method invocations crosses this threshold</div><div class="line">     intx Tier4LoadFeedback                         = 3                                   &#123;product&#125;Tier 4 thresholds will increase twofold when C2 queue size reaches this amount per compiler thread</div><div class="line">     intx Tier4MinInvocationThreshold               = 600                                 &#123;product&#125;Minimum invocation to compile at tier 4</div><div class="line">     bool TieredCompilation                         = true                                &#123;pd product&#125;Enable tiered compilation</div><div class="line">     intx TieredCompileTaskTimeout                  = 50                                  &#123;product&#125;Kill compile task if method was not used within given timeout in milliseconds</div><div class="line">     intx TieredRateUpdateMaxTime                   = 25                                  &#123;product&#125;Maximum rate sampling interval (in milliseconds)</div><div class="line">     intx TieredRateUpdateMinTime                   = 1                                   &#123;product&#125;Minimum rate sampling interval (in milliseconds)</div><div class="line">     intx TieredStopAtLevel                         = 4                                   &#123;product&#125;Stop at given compilation level</div><div class="line">     bool TimeCompilationPolicy                     = false                               &#123;develop&#125;Time the compilation policy</div><div class="line">     bool TimeCompiler                              = false                               &#123;notproduct&#125;Time the compiler</div><div class="line">     bool TimeCompiler2                             = false                               &#123;C2 notproduct&#125;detailed time the compiler (requires +TimeCompiler)</div><div class="line">     bool TimeEachLinearScan                        = false                               &#123;C1 develop&#125;print detailed timing of each LinearScan run</div><div class="line">     bool TimeLinearScan                            = false                               &#123;C1 product&#125;detailed timing of LinearScan phases</div><div class="line">     bool TimeLivenessAnalysis                      = false                               &#123;develop&#125;Time computation of bytecode liveness analysis</div><div class="line">     bool TimeOopMap                                = false                               &#123;develop&#125;Time calls to GenerateOopMap::compute_map() in sum</div><div class="line">     bool TimeOopMap2                               = false                               &#123;develop&#125;Time calls to GenerateOopMap::compute_map() individually</div><div class="line">    uintx TotalHandleAllocationLimit                = 1024                                &#123;develop&#125;Threshold for total handle allocation when +TraceHandleAllocation is used</div><div class="line">     bool TraceAdaptiveGCBoundary                   = false                               &#123;develop&#125;Trace young-old boundary moves</div><div class="line">     bool TraceBiasedLocking                        = false                               &#123;product&#125;Trace biased locking in JVM</div><div class="line">     bool TraceBlockOffsetTable                     = false                               &#123;develop&#125;Print BlockOffsetTable maps</div><div class="line">     bool TraceBytecodes                            = false                               &#123;develop&#125;Trace bytecode execution</div><div class="line">     intx TraceBytecodesAt                          = 0                                   &#123;develop&#125;Trace bytecodes starting with specified bytecode number</div><div class="line">     bool TraceCISCSpill                            = false                               &#123;C2 notproduct&#125;Trace allocators use of cisc spillable instructions</div><div class="line">     bool TraceCMSState                             = false                               &#123;develop&#125;Trace the state of the CMS collection</div><div class="line">     bool TraceCallFixup                            = false                               &#123;develop&#125;Trace all call fixups</div><div class="line">     bool TraceCardTableModRefBS                    = false                               &#123;develop&#125;Print CardTableModRefBS maps</div><div class="line">     bool TraceClassInitialization                  = false                               &#123;develop&#125;Trace class initialization</div><div class="line">     bool TraceClassLoaderData                      = false                               &#123;develop&#125;Trace class loader loader_data lifetime</div><div class="line">     bool TraceClassLoading                         = false                               &#123;product rw&#125;Trace all classes loaded</div><div class="line">     bool TraceClassLoadingPreorder                 = false                               &#123;product&#125;Trace all classes loaded in order referenced (not loaded)</div><div class="line">     bool TraceClassPaths                           = false                               &#123;product&#125;Trace processing of class paths</div><div class="line">     bool TraceClassResolution                      = false                               &#123;product&#125;Trace all constant pool resolutions (for debugging)</div><div class="line">     bool TraceClassUnloading                       = false                               &#123;product rw&#125;Trace unloading of classes</div><div class="line">     bool TraceClearedExceptions                    = false                               &#123;develop&#125;Print when an exception is forcibly cleared</div><div class="line">     bool TraceCodeBlobStacks                       = false                               &#123;notproduct&#125;Trace stack-walk of codeblobs</div><div class="line">     bool TraceCompilationPolicy                    = false                               &#123;develop&#125;Trace compilation policy</div><div class="line">     bool TraceCompiledIC                           = false                               &#123;develop&#125;Trace changes of compiled IC</div><div class="line">     bool TraceCreateZombies                        = false                               &#123;develop&#125;trace creation of zombie nmethods</div><div class="line">     bool TraceDefaultMethods                       = false                               &#123;develop&#125;Trace the default method processing steps</div><div class="line">     bool TraceDeoptimization                       = false                               &#123;develop&#125;Trace deoptimization</div><div class="line">     bool TraceDependencies                         = false                               &#123;develop&#125;Trace dependencies</div><div class="line">     bool TraceDerivedPointers                      = false                               &#123;develop&#125;Trace traversal of derived pointers on stack</div><div class="line">     bool TraceDynamicGCThreads                     = false                               &#123;product&#125;Trace the dynamic GC thread usage</div><div class="line">     bool TraceExceptions                           = false                               &#123;develop&#125;Trace exceptions</div><div class="line">     bool TraceFPURegisterUsage                     = false                               &#123;C1 develop&#125;Trace usage of FPU registers at start of blocks (intel only)</div><div class="line">     bool TraceFPUStack                             = false                               &#123;C1 develop&#125;Trace emulation of the FPU stack (intel only)</div><div class="line">     bool TraceFinalizerRegistration                = false                               &#123;develop&#125;Trace registration of final references</div><div class="line">     bool TraceFrequencyInlining                    = false                               &#123;develop&#125;Trace frequency based inlining</div><div class="line">     bool TraceGCTaskManager                        = false                               &#123;develop&#125;Trace actions of the GC task manager</div><div class="line">     bool TraceGCTaskQueue                          = false                               &#123;develop&#125;Trace actions of the GC task queues</div><div class="line">     bool TraceGCTaskThread                         = false                               &#123;diagnostic&#125;Trace actions of the GC task threads</div><div class="line">     bool TraceGen0Time                             = false                               &#123;product&#125;Trace accumulated time for Gen 0 collection</div><div class="line">     bool TraceGen1Time                             = false                               &#123;product&#125;Trace accumulated time for Gen 1 collection</div><div class="line">     bool TraceHandleAllocation                     = false                               &#123;develop&#125;Print out warnings when suspiciously many handles are allocated</div><div class="line">     bool TraceICBuffer                             = false                               &#123;develop&#125;Trace usage of IC buffer</div><div class="line">     bool TraceICs                                  = false                               &#123;develop&#125;Trace inline cache changes</div><div class="line">     bool TraceInlineCacheClearing                  = false                               &#123;develop&#125;Trace clearing of inline caches in nmethods</div><div class="line">     bool TraceInvocationCounterOverflow            = false                               &#123;notproduct&#125;Trace method invocation counter overflow</div><div class="line">     bool TraceInvokeDynamic                        = false                               &#123;develop&#125;trace internal invoke dynamic operations</div><div class="line">     bool TraceItables                              = false                               &#123;develop&#125;Trace initialization and use of itables</div><div class="line">     bool TraceIterativeGVN                         = false                               &#123;C2 develop&#125;Print progress during Iterative Global Value Numbering</div><div class="line">     bool TraceJNICalls                             = false                               &#123;develop&#125;Trace JNI calls</div><div class="line">     bool TraceJNIHandleAllocation                  = false                               &#123;develop&#125;Trace allocation/deallocation of JNI handle blocks</div><div class="line">     bool TraceJVMCalls                             = false                               &#123;notproduct&#125;Trace JVM calls</div><div class="line">    ccstr TraceJVMTI                                =                                     &#123;product&#125;Trace flags for JVMTI functions and events</div><div class="line">     bool TraceJVMTIObjectTagging                   = false                               &#123;diagnostic&#125;Trace JVMTI object tagging calls</div><div class="line">     bool TraceJavaAssertions                       = false                               &#123;develop&#125;Trace java language assertions</div><div class="line">     bool TraceJumps                                = false                               &#123;develop&#125;Trace assembly jumps in thread ring buffer</div><div class="line">     intx TraceLinearScanLevel                      = 0                                   &#123;C1 develop&#125;Debug levels for the linear scan allocator</div><div class="line">     bool TraceLivenessGen                          = false                               &#123;develop&#125;Trace the generation of liveness analysis information</div><div class="line">     bool TraceLivenessQuery                        = false                               &#123;notproduct&#125;Trace queries of liveness analysis information</div><div class="line">     bool TraceLoaderConstraints                    = false                               &#123;product rw&#125;Trace loader constraints</div><div class="line">     bool TraceLongCompiles                         = false                               &#123;develop&#125;Print out every time compilation is longer than a given threshold</div><div class="line">     bool TraceLoopLimitCheck                       = false                               &#123;C2 develop&#125;Trace generation of loop limits checks</div><div class="line">     bool TraceLoopOpts                             = false                               &#123;C2 develop&#125;Trace executed loop optimizations</div><div class="line">     bool TraceLoopPredicate                        = false                               &#123;C2 develop&#125;Trace generation of loop predicates</div><div class="line">     bool TraceLoopUnswitching                      = false                               &#123;C2 notproduct&#125;Trace loop unswitching</div><div class="line">     bool TraceMarkSweep                            = false                               &#123;notproduct&#125;Trace mark sweep</div><div class="line">     bool TraceMetadataChunkAllocation              = false                               &#123;develop&#125;Trace chunk metadata allocations</div><div class="line">     bool TraceMetadataHumongousAllocation          = false                               &#123;product&#125;Trace humongous metadata allocations</div><div class="line">     bool TraceMetavirtualspaceAllocation           = false                               &#123;develop&#125;Trace virtual space metadata allocations</div><div class="line">     bool TraceMethodHandles                        = false                               &#123;develop&#125;trace internal method handle operations</div><div class="line">     bool TraceMethodReplacement                    = false                               &#123;develop&#125;Print when methods are replaced do to recompilation</div><div class="line">     bool TraceMonitorInflation                     = false                               &#123;product&#125;Trace monitor inflation in JVM</div><div class="line">     bool TraceMonitorMismatch                      = false                               &#123;develop&#125;Trace monitor matching failures during OopMapGeneration</div><div class="line">     bool TraceNMethodInstalls                      = false                               &#123;diagnostic&#125;Trace nmethod installation</div><div class="line">     bool TraceNewOopMapGeneration                  = false                               &#123;develop&#125;Trace OopMapGeneration</div><div class="line">     bool TraceNewOopMapGenerationDetailed          = false                               &#123;develop&#125;Trace OopMapGeneration: print detailed cell states</div><div class="line">     bool TraceNewVectors                           = false                               &#123;C2 notproduct&#125;Trace creation of Vector nodes</div><div class="line">     bool TraceOnStackReplacement                   = false                               &#123;notproduct&#125;Trace on stack replacement</div><div class="line">     bool TraceOopMapGeneration                     = false                               &#123;develop&#125;Show OopMapGeneration</div><div class="line">     bool TraceOopMapRewrites                       = false                               &#123;develop&#125;Trace rewriting of method oops during oop map generation</div><div class="line">     bool TraceOptimizeFill                         = false                               &#123;C2 develop&#125;print detailed information about fill conversion</div><div class="line">     bool TraceOptoOutput                           = false                               &#123;C2 notproduct&#125;Trace pipelining information</div><div class="line">     bool TraceOptoParse                            = false                               &#123;C2 develop&#125;Trace bytecode parse and control-flow merge</div><div class="line">     bool TraceOptoPipelining                       = false                               &#123;C2 notproduct&#125;Trace pipelining information</div><div class="line">     bool TracePageSizes                            = false                               &#123;develop&#125;Trace page size selection and usage</div><div class="line">     bool TraceParallelOldGCCompactionPhase         = false                               &#123;develop&#125;Trace compaction phase in ParallelOldGC</div><div class="line">     bool TraceParallelOldGCDensePrefix             = false                               &#123;develop&#125;Trace dense prefix computation for ParallelOldGC</div><div class="line">     bool TraceParallelOldGCMarkingPhase            = false                               &#123;develop&#125;Trace marking phase in ParallelOldGC</div><div class="line">     bool TraceParallelOldGCSummaryPhase            = false                               &#123;develop&#125;Trace summary phase in ParallelOldGC</div><div class="line">     bool TraceParallelOldGCTasks                   = false                               &#123;product&#125;Trace multithreaded GC activity</div><div class="line">     bool TracePartialPeeling                       = false                               &#123;C2 notproduct&#125;Trace partial peeling (loop rotation) information</div><div class="line">     bool TracePatching                             = false                               &#123;C1 develop&#125;Trace patching of field access on uninitialized classes</div><div class="line">     bool TracePcPatching                           = false                               &#123;develop&#125;Trace usage of frame::patch_pc</div><div class="line">     bool TracePhaseCCP                             = false                               &#123;C2 notproduct&#125;Print progress during Conditional Constant Propagation</div><div class="line">     bool TracePostallocExpand                      = false                               &#123;C2 develop&#125;Trace expanding nodes after register allocation.</div><div class="line">     bool TracePredicateFailedTraps                 = false                               &#123;C1 develop&#125;trace runtime traps caused by predicate failure</div><div class="line">     bool TraceProfileInterpreter                   = false                               &#123;develop&#125;Trace profiling at the bytecode level during interpretation. This outputs the profiling information collected to improve jit compilation.</div><div class="line">     bool TraceProfileTripCount                     = false                               &#123;C2 notproduct&#125;Trace profile loop trip count information</div><div class="line">     bool TraceProtectionDomainVerification         = false                               &#123;develop&#125;Trace protection domain verification</div><div class="line">     bool TraceRangeCheckElimination                = false                               &#123;C1 develop&#125;Trace Range Check Elimination</div><div class="line">     bool TraceRangeLimitCheck                      = false                               &#123;C2 develop&#125;Trace additional overflow checks in RCE</div><div class="line">     intx TraceRedefineClasses                      = 0                                   &#123;product&#125;Trace level for JVMTI RedefineClasses</div><div class="line">     bool TraceReferenceGC                          = false                               &#123;develop&#125;Trace handling of soft/weak/final/phantom references</div><div class="line">     bool TraceRelocator                            = false                               &#123;develop&#125;Trace the bytecode relocator</div><div class="line">     bool TraceRuntimeCalls                         = false                               &#123;notproduct&#125;Trace run-time calls</div><div class="line">     bool TraceSafepoint                            = false                               &#123;develop&#125;Trace safepoint operations</div><div class="line">     bool TraceSafepointCleanupTime                 = false                               &#123;product&#125;Print the break down of clean up tasks performed during safepoint</div><div class="line">     bool TraceScavenge                             = false                               &#123;notproduct&#125;Trace scavenge</div><div class="line">     bool TraceSpilling                             = false                               &#123;C2 notproduct&#125;Trace spilling</div><div class="line">     bool TraceStartupTime                          = false                               &#123;develop&#125;Trace setup time</div><div class="line">     bool TraceSuperWord                            = false                               &#123;C2 notproduct&#125;Trace superword transforms</div><div class="line">     bool TraceSuspendWaitFailures                  = false                               &#123;product&#125;Trace external suspend wait failures</div><div class="line">     bool TraceThreadEvents                         = false                               &#123;develop&#125;Trace all thread events</div><div class="line">     bool TraceTypeProfile                          = false                               &#123;C2 diagnostic&#125;Trace type profile</div><div class="line">     bool TraceVMOperation                          = false                               &#123;develop&#125;Trace VM operations</div><div class="line">     bool TraceWorkGang                             = false                               &#123;develop&#125;Trace activities of work gangs</div><div class="line">     bool TraceZapDeadLocals                        = false                               &#123;notproduct&#125;Trace zapping dead locals</div><div class="line">     bool TraceZapUnusedHeapArea                    = false                               &#123;develop&#125;Trace zapping of unused heap space</div><div class="line">     intx TrackedInitializationLimit                = 50                                  &#123;C2 product&#125;When initializing fields, track up to this many words</div><div class="line">     bool TransmitErrorReport                       = false                               &#123;product&#125;Enable error report transmission on erroneous termination</div><div class="line">     bool TrapBasedNullChecks                       = false                               &#123;pd product&#125;Generate code for null checks that uses a cmp and trap instruction raising SIGTRAP.  This is only used if an access tonull (+offset) will not raise a SIGSEGV, i.e.,ImplicitNullChecks don&apos;t work (PPC64).</div><div class="line">     bool TrapBasedRangeChecks                      = false                               &#123;C2 pd product&#125;Generate code for range checks that uses a cmp and trap instruction raising SIGTRAP. Used on PPC64.</div><div class="line">     bool TwoOperandLIRForm                         = true                                &#123;C1 pd develop&#125;true if LIR requires src1 and dst to match in binary LIR ops</div><div class="line">     intx TypeProfileArgsLimit                      = 2                                   &#123;product&#125;max number of call arguments to consider for type profiling</div><div class="line">     bool TypeProfileCasts                          = true                                &#123;develop&#125;treat casts like calls for purposes of type profiling</div><div class="line">    uintx TypeProfileLevel                          = 111                                 &#123;pd product&#125;=XYZ, with Z: Type profiling of arguments at call; Y: Type profiling of return value at call; X: Type profiling of parameters to methods; X, Y and Z in 0=off ; 1=jsr292 only; 2=all methods</div><div class="line">     intx TypeProfileMajorReceiverPercent           = 90                                  &#123;C2 product&#125;% of major receiver type to all profiled receivers</div><div class="line">     intx TypeProfileParmsLimit                     = 2                                   &#123;product&#125;max number of incoming parameters to consider for type profiling, -1 for all</div><div class="line">     intx TypeProfileWidth                          = 2                                   &#123;product&#125;Number of receiver types to record in call/cast profile</div><div class="line">     bool UncommonNullCast                          = true                                &#123;pd develop&#125;track occurrences of null in casts; adjust compiler tactics</div><div class="line">     intx UnguardOnExecutionViolation               = 0                                   &#123;product&#125;Unguard page and retry on no-execute fault (Win32 only) 0=off, 1=conservative, 2=aggressive</div><div class="line">     bool UnlinkSymbolsALot                         = false                               &#123;product&#125;Unlink unreferenced symbols from the symbol table at safepoints</div><div class="line">     bool UnlockDiagnosticVMOptions                 = true                                &#123;diagnostic&#125;Enable normal processing of flags relating to field diagnostics</div><div class="line">     bool UnrollLimitCheck                          = true                                &#123;C2 diagnostic&#125;Additional overflow checks during loop unroll</div><div class="line">     intx UnrollLimitForProfileCheck                = 1                                   &#123;C2 develop&#125;Don&apos;t use profile_trip_cnt() to restrict unrolling until unrolling would push the number of unrolled iterations above UnrollLimitForProfileCheck. A higher value allows more unrolling. Zero acts as a very large value.</div><div class="line">     bool UnsyncloadClass                           = false                               &#123;diagnostic&#125;Unstable: VM calls loadClass unsynchronized. Custom class loader must call VM synchronized for findClass and defineClass.</div><div class="line">     bool Use24BitFP                                = true                                &#123;C2 develop&#125;use FP instructions that produce 24-bit precise results</div><div class="line">     bool Use24BitFPMode                            = true                                &#123;C2 develop&#125;Set 24-bit FPU mode on a per-compile basis </div><div class="line">     bool Use486InstrsOnly                          = false                               &#123;ARCH product&#125;Use 80486 Compliant instruction subset</div><div class="line">     bool UseAES                                    = false                               &#123;product&#125;Control whether AES instructions can be used on x86/x64</div><div class="line">     bool UseAESIntrinsics                          = false                               &#123;product&#125;Use intrinsics for AES versions of crypto</div><div class="line">     intx UseAVX                                    = 99                                  &#123;ARCH product&#125;Highest supported AVX instructions set on x86/x64</div><div class="line">     bool UseAdaptiveGCBoundary                     = false                               &#123;product&#125;Allow young-old boundary to move</div><div class="line">     bool UseAdaptiveGenerationSizePolicyAtMajorCollection  = true                                &#123;product&#125;Use adaptive young-old sizing policies at major collections</div><div class="line">     bool UseAdaptiveGenerationSizePolicyAtMinorCollection  = true                                &#123;product&#125;Use adaptive young-old sizing policies at minor collections</div><div class="line">     bool UseAdaptiveNUMAChunkSizing                = true                                &#123;product&#125;Enable adaptive chunk sizing for NUMA</div><div class="line">     bool UseAdaptiveSizeDecayMajorGCCost           = true                                &#123;product&#125;Adaptive size decays the major cost for long major intervals</div><div class="line">     bool UseAdaptiveSizePolicy                     = true                                &#123;product&#125;Use adaptive generation sizing policies</div><div class="line">     bool UseAdaptiveSizePolicyFootprintGoal        = true                                &#123;product&#125;Use adaptive minimum footprint as a goal</div><div class="line">     bool UseAdaptiveSizePolicyWithSystemGC         = false                               &#123;product&#125;Include statistics from System.gc() for adaptive size policy</div><div class="line">     bool UseAddressNop                             = false                               &#123;ARCH product&#125;Use &apos;0F 1F [addr]&apos; NOP instructions on x86 cpus</div><div class="line">     bool UseAltSigs                                = false                               &#123;product&#125;Use alternate signals instead of SIGUSR1 &amp; SIGUSR2 for VM internal signals (Solaris only)</div><div class="line">     bool UseAsyncConcMarkSweepGC                   = true                                &#123;develop&#125;Use Asynchronous Concurrent Mark-Sweep GC in the old generation</div><div class="line">     bool UseAutoGCSelectPolicy                     = false                               &#123;product&#125;Use automatic collection selection policy</div><div class="line">     bool UseBMI1Instructions                       = false                               &#123;ARCH product&#125;Use BMI1 instructions</div><div class="line">     bool UseBMI2Instructions                       = false                               &#123;ARCH product&#125;Use BMI2 instructions</div><div class="line">     bool UseBiasedLocking                          = true                                &#123;product&#125;Enable biased locking in JVM</div><div class="line">     bool UseBimorphicInlining                      = true                                &#123;C2 product&#125;Profiling based inlining for two receivers</div><div class="line">     bool UseBoundThreads                           = true                                &#123;product&#125;Bind user level threads to kernel threads (for Solaris only)</div><div class="line">     bool UseC1Optimizations                        = true                                &#123;C1 develop&#125;Turn on C1 optimizations</div><div class="line">     bool UseCHA                                    = true                                &#123;develop&#125;Enable CHA</div><div class="line">     bool UseCISCSpill                              = true                                &#123;C2 pd develop&#125;Use ADLC supplied cisc instructions during allocation</div><div class="line">     bool UseCLMUL                                  = false                               &#123;ARCH product&#125;Control whether CLMUL instructions can be used on x86/x64</div><div class="line">     bool UseCMSAdaptiveFreeLists                   = true                                &#123;develop&#125;Use adaptive free lists in the CMS generation</div><div class="line">     bool UseCMSBestFit                             = true                                &#123;product&#125;Use CMS best fit allocation strategy</div><div class="line">     bool UseCMSCollectionPassing                   = true                                &#123;product&#125;Use passing of collection from background to foreground</div><div class="line">     bool UseCMSCompactAtFullCollection             = true                                &#123;product&#125;Use Mark-Sweep-Compact algorithm at full collections</div><div class="line">     bool UseCMSInitiatingOccupancyOnly             = false                               &#123;product&#125;Only use occupancy as a criterion for starting a CMS collection</div><div class="line">     bool UseCRC32Intrinsics                        = false                               &#123;product&#125;use intrinsics for java.util.zip.CRC32</div><div class="line">     bool UseCodeCacheFlushing                      = true                                &#123;product&#125;Remove cold/old nmethods from the code cache</div><div class="line">     bool UseCompiler                               = true                                &#123;product&#125;Use Just-In-Time compilation</div><div class="line">     bool UseCompilerSafepoints                     = true                                &#123;product&#125;Stop at safepoints in compiled code</div><div class="line">     bool UseCompressedClassPointers                = false                               &#123;lp64_product&#125;Use 32-bit class pointers in 64-bit VM. lp64_product means flag is always constant in 32 bit VM</div><div class="line">     bool UseCompressedOops                         = false                               &#123;lp64_product&#125;Use 32-bit object references in 64-bit VM. lp64_product means flag is always constant in 32 bit VM</div><div class="line">     bool UseConcMarkSweepGC                        = false                               &#123;product&#125;Use Concurrent Mark-Sweep GC in the old generation</div><div class="line">     bool UseCondCardMark                           = false                               &#123;C2 product&#125;Check for already marked card before updating card table</div><div class="line">     bool UseCountLeadingZerosInstruction           = false                               &#123;ARCH product&#125;Use count leading zeros instruction</div><div class="line">     bool UseCountTrailingZerosInstruction          = false                               &#123;ARCH product&#125;Use count trailing zeros instruction</div><div class="line">     bool UseCountedLoopSafepoints                  = false                               &#123;C2 product&#125;Force counted loops to keep a safepoint</div><div class="line">     bool UseCounterDecay                           = true                                &#123;product&#125;Adjust recompilation counters</div><div class="line">     bool UseDetachedThreads                        = true                                &#123;develop&#125;Use detached threads that are recycled upon termination (for Solaris only)</div><div class="line">     bool UseDivMod                                 = true                                &#123;C2 product&#125;Use combined DivMod instruction if available</div><div class="line">     bool UseDynamicNumberOfGCThreads               = false                               &#123;product&#125;Dynamically choose the number of parallel threads parallel gc will use</div><div class="line">     bool UseExactTypes                             = true                                &#123;C2 develop&#125;Use exact types to eliminate array store checks and v-calls</div><div class="line">     bool UseFPUForSpilling                         = false                               &#123;C2 product&#125;Spill integer registers to FPU instead of stack when possible</div><div class="line">     bool UseFakeTimers                             = false                               &#123;develop&#125;Tell whether the VM should use system time or a fake timer</div><div class="line">     bool UseFastAccessorMethods                    = true                                &#123;product&#125;Use fast method entry code for accessor methods</div><div class="line">     bool UseFastEmptyMethods                       = true                                &#123;product&#125;Use fast method entry code for empty methods</div><div class="line">     bool UseFastJNIAccessors                       = true                                &#123;product&#125;Use optimized versions of Get&lt;Primitive&gt;Field</div><div class="line">     bool UseFastLocking                            = true                                &#123;C1 develop&#125;Use fast inlined locking code</div><div class="line">     bool UseFastNewInstance                        = true                                &#123;C1 develop&#125;Use fast inlined instance allocation</div><div class="line">     bool UseFastNewObjectArray                     = true                                &#123;C1 develop&#125;Use fast inlined object array allocation</div><div class="line">     bool UseFastNewTypeArray                       = true                                &#123;C1 develop&#125;Use fast inlined type array allocation</div><div class="line">     bool UseFastSignatureHandlers                  = true                                &#123;develop&#125;Use fast signature handlers for native calls</div><div class="line">     bool UseFastStosb                              = false                               &#123;ARCH product&#125;Use fast-string operation for zeroing: rep stosb</div><div class="line">     bool UseG1GC                                   = false                               &#123;product&#125;Use the Garbage-First garbage collector</div><div class="line">     bool UseGCLogFileRotation                      = false                               &#123;product&#125;Rotate gclog files (for long running applications). It requires -Xloggc:&lt;filename&gt;</div><div class="line">     bool UseGCOverheadLimit                        = true                                &#123;product&#125;Use policy to limit of proportion of time spent in GC before an OutOfMemory error is thrown</div><div class="line">     bool UseGCTaskAffinity                         = false                               &#123;product&#125;Use worker affinity when asking for GCTasks</div><div class="line">     bool UseGlobalValueNumbering                   = true                                &#123;C1 develop&#125;Use Global Value Numbering (separate phase)</div><div class="line">     bool UseHeavyMonitors                          = false                               &#123;product&#125;use heavyweight instead of lightweight Java monitors</div><div class="line">     bool UseHugeTLBFS                              = false                               &#123;product&#125;Use MAP_HUGETLB for large pages</div><div class="line">     bool UseImplicitStableValues                   = true                                &#123;C2 diagnostic&#125;Mark well-known stable fields as such (e.g. String.value)</div><div class="line">     bool UseIncDec                                 = true                                &#123;ARCH diagnostic&#125;Use INC, DEC instructions on x86</div><div class="line">     bool UseInlineCaches                           = true                                &#123;product&#125;Use Inline Caches for virtual calls </div><div class="line">     bool UseInlineDepthForSpeculativeTypes         = true                                &#123;C2 diagnostic&#125;Carry inline depth of profile point with speculative type and give priority to profiling from lower inline depth</div><div class="line">     bool UseInterpreter                            = true                                &#123;product&#125;Use interpreter for non-compiled methods</div><div class="line">     bool UseJumpTables                             = true                                &#123;C2 product&#125;Use JumpTables instead of a binary search tree for switches</div><div class="line">     bool UseLWPSynchronization                     = true                                &#123;product&#125;Use LWP-based instead of libthread-based synchronization (SPARC only)</div><div class="line">     bool UseLargePages                             = false                               &#123;pd product&#125;Use large page memory</div><div class="line">     bool UseLargePagesInMetaspace                  = false                               &#123;product&#125;Use large page memory in metaspace. Only used if UseLargePages is enabled.</div><div class="line">     bool UseLargePagesIndividualAllocation         = false                               &#123;pd product&#125;Allocate large pages individually for better affinity</div><div class="line">     bool UseLinuxPosixThreadCPUClocks              = true                                &#123;product&#125;enable fast Linux Posix clocks where available</div><div class="line">     bool UseLocalValueNumbering                    = true                                &#123;C1 develop&#125;Use Local Value Numbering (embedded in GraphBuilder)</div><div class="line">     bool UseLockedTracing                          = false                               &#123;product&#125;Use locked-tracing when doing event-based tracing</div><div class="line">     bool UseLoopCounter                            = true                                &#123;product&#125;Increment invocation counter on backward branch</div><div class="line">     bool UseLoopInvariantCodeMotion                = true                                &#123;C1 product&#125;Simple loop invariant code motion for short loops during GVN</div><div class="line">     bool UseLoopPredicate                          = true                                &#123;C2 product&#125;Generate a predicate to select fast/slow loop versions</div><div class="line">     bool UseLoopSafepoints                         = true                                &#123;develop&#125;Generate Safepoint nodes in every loop</div><div class="line">     bool UseMallocOnly                             = false                               &#123;develop&#125;Use only malloc/free for allocation (no resource area/arena)</div><div class="line">     bool UseMathExactIntrinsics                    = true                                &#123;C2 product&#125;Enables intrinsification of various java.lang.Math functions</div><div class="line">     bool UseMaximumCompactionOnSystemGC            = true                                &#123;product&#125;Use maximum compaction in the Parallel Old garbage collector for a system GC</div><div class="line">     bool UseMembar                                 = false                               &#123;pd product&#125;(Unstable) Issues membars on thread state transitions</div><div class="line">     bool UseMontgomeryMultiplyIntrinsic            = false                               &#123;C2 product&#125;Enables intrinsification of BigInteger.montgomeryMultiply()</div><div class="line">     bool UseMontgomerySquareIntrinsic              = false                               &#123;C2 product&#125;Enables intrinsification of BigInteger.montgomerySquare()</div><div class="line">     bool UseMulAddIntrinsic                        = false                               &#123;C2 product&#125;Enables intrinsification of BigInteger.mulAdd()</div><div class="line">     bool UseMultiplyToLenIntrinsic                 = false                               &#123;C2 product&#125;Enables intrinsification of BigInteger.multiplyToLen()</div><div class="line">     bool UseNUMA                                   = false                               &#123;product&#125;Use NUMA if available</div><div class="line">     bool UseNUMAInterleaving                       = false                               &#123;product&#125;Interleave memory across NUMA nodes if available</div><div class="line">     bool UseNewCode                                = false                               &#123;diagnostic&#125;Testing Only: Use the new version while testing</div><div class="line">     bool UseNewCode2                               = false                               &#123;diagnostic&#125;Testing Only: Use the new version while testing</div><div class="line">     bool UseNewCode3                               = false                               &#123;diagnostic&#125;Testing Only: Use the new version while testing</div><div class="line">     bool UseNewLongLShift                          = false                               &#123;ARCH product&#125;Use optimized bitwise shift left</div><div class="line">     bool UseNewReflection                          = true                                &#123;develop&#125;Temporary flag for transition to reflection based on dynamic bytecode generation in 1.4; can no longer be turned off in 1.4 JDK, and is unneeded in 1.3 JDK, but marks most places VM changes were needed</div><div class="line">     bool UseOSErrorReporting                       = false                               &#123;pd product&#125;Let VM fatal error propagate to the OS (ie. WER on Windows)</div><div class="line">     bool UseOldInlining                            = true                                &#123;C2 product&#125;Enable the 1.3 inlining strategy</div><div class="line">     bool UseOnStackReplacement                     = true                                &#123;pd product&#125;Use on stack replacement, calls runtime if invoc. counter overflows in loop</div><div class="line">     bool UseOnlyInlinedBimorphic                   = true                                &#123;C2 product&#125;Don&apos;t use BimorphicInlining if can&apos;t inline a second method</div><div class="line">     bool UseOprofile                               = false                               &#123;product&#125;enable support for Oprofile profiler</div><div class="line">     bool UseOptoBiasInlining                       = true                                &#123;C2 product&#125;Generate biased locking code in C2 ideal graph</div><div class="line">     bool UsePSAdaptiveSurvivorSizePolicy           = true                                &#123;product&#125;Use adaptive survivor sizing policies</div><div class="line">     bool UseParNewGC                               = false                               &#123;product&#125;Use parallel threads in the new generation</div><div class="line">     bool UseParallelGC                             = false                               &#123;product&#125;Use the Parallel Scavenge garbage collector</div><div class="line">     bool UseParallelOldGC                          = false                               &#123;product&#125;Use the Parallel Old garbage collector</div><div class="line">     bool UsePerfData                               = true                                &#123;product&#125;Flag to disable jvmstat instrumentation for performance testing and problem isolation purposes</div><div class="line">     bool UsePopCountInstruction                    = false                               &#123;product&#125;Use population count instruction</div><div class="line">     bool UsePrivilegedStack                        = true                                &#123;develop&#125;Enable the security JVM functions</div><div class="line">     bool UsePthreads                               = false                               &#123;develop&#125;Use pthread-based instead of libthread-based synchronization (SPARC only)</div><div class="line">     bool UseRDPCForConstantTableBase               = false                               &#123;C2 product&#125;Use Sparc RDPC instruction for the constant table base.</div><div class="line">     bool UseRTMDeopt                               = false                               &#123;ARCH product&#125;Perform deopt and recompilation based on RTM abort ratio</div><div class="line">     bool UseRTMLocking                             = false                               &#123;ARCH product&#125;Enable RTM lock eliding for inflated locks in compiled code</div><div class="line">     bool UseRelocIndex                             = false                               &#123;develop&#125;Use an index to speed random access to relocations</div><div class="line">     bool UseSHA                                    = false                               &#123;product&#125;Control whether SHA instructions can be used on SPARC</div><div class="line">     bool UseSHA1Intrinsics                         = false                               &#123;product&#125;Use intrinsics for SHA-1 crypto hash function</div><div class="line">     bool UseSHA256Intrinsics                       = false                               &#123;product&#125;Use intrinsics for SHA-224 and SHA-256 crypto hash functions</div><div class="line">     bool UseSHA512Intrinsics                       = false                               &#123;product&#125;Use intrinsics for SHA-384 and SHA-512 crypto hash functions</div><div class="line">     bool UseSHM                                    = false                               &#123;product&#125;Use SYSV shared memory for large pages</div><div class="line">     intx UseSSE                                    = 99                                  &#123;product&#125;Highest supported SSE instructions set on x86/x64</div><div class="line">     bool UseSSE42Intrinsics                        = false                               &#123;product&#125;SSE4.2 versions of intrinsics</div><div class="line">     bool UseSerialGC                               = false                               &#123;product&#125;Use the Serial garbage collector</div><div class="line">     bool UseSharedSpaces                           = true                                &#123;product&#125;Use shared spaces for metadata</div><div class="line">     bool UseSignalChaining                         = true                                &#123;product&#125;Use signal-chaining to invoke signal handlers installed by the application (Solaris &amp; Linux only)</div><div class="line">     bool UseSlowPath                               = false                               &#123;C1 develop&#125;For debugging: test slow cases by always using them</div><div class="line">     bool UseSquareToLenIntrinsic                   = false                               &#123;C2 product&#125;Enables intrinsification of BigInteger.squareToLen()</div><div class="line">     bool UseStackBanging                           = true                                &#123;develop&#125;use stack banging for stack overflow checks (required for proper StackOverflow handling; disable only to measure cost of stackbanging)</div><div class="line">     bool UseStoreImmI16                            = true                                &#123;ARCH product&#125;Use store immediate 16-bits value instruction on x86</div><div class="line">     bool UseStrictFP                               = true                                &#123;develop&#125;use strict fp if modifier strictfp is set</div><div class="line">     bool UseStringDeduplication                    = false                               &#123;product&#125;Use string deduplication</div><div class="line">     bool UseSuperWord                              = true                                &#123;C2 product&#125;Transform scalar operations into superword operations</div><div class="line">     bool UseTLAB                                   = true                                &#123;pd product&#125;Use thread-local object allocation</div><div class="line">     bool UseTableRanges                            = true                                &#123;C1 develop&#125;Faster versions of lookup table using ranges</div><div class="line">     bool UseThreadPriorities                       = true                                &#123;pd product&#125;Use native thread priorities</div><div class="line">     bool UseTransparentHugePages                   = false                               &#123;product&#125;Use MADV_HUGEPAGE for large pages</div><div class="line">     bool UseTypeProfile                            = true                                &#123;product&#125;Check interpreter profile for historically monomorphic calls</div><div class="line">     bool UseTypeSpeculation                        = true                                &#123;C2 product&#125;Speculatively propagate types from profiles</div><div class="line">     bool UseUnalignedLoadStores                    = false                               &#123;ARCH product&#125;Use SSE2 MOVDQU instruction for Arraycopy</div><div class="line">     bool UseUniqueSubclasses                       = true                                &#123;C2 develop&#125;Narrow an abstract reference to the unique concrete subclass</div><div class="line">     bool UseVMInterruptibleIO                      = false                               &#123;product&#125;(Unstable, Solaris-specific) Thread interrupt before or with EINTR for I/O operations results in OS_INTRPT. The default value of this flag is true for JDK 6 and earlier</div><div class="line">     bool UseXMMForArrayCopy                        = false                               &#123;product&#125;Use SSE2 MOVQ instruction for Arraycopy</div><div class="line">     bool UseXmmI2D                                 = false                               &#123;ARCH product&#125;Use SSE2 CVTDQ2PD instruction to convert Integer to Double</div><div class="line">     bool UseXmmI2F                                 = false                               &#123;ARCH product&#125;Use SSE2 CVTDQ2PS instruction to convert Integer to Float</div><div class="line">     bool UseXmmLoadAndClearUpper                   = true                                &#123;ARCH product&#125;Load low part of XMM register and clear upper part</div><div class="line">     bool UseXmmRegToRegMoveAll                     = false                               &#123;ARCH product&#125;Copy all XMM register bits when moving value between registers</div><div class="line">     bool VMThreadHintNoPreempt                     = false                               &#123;product&#125;(Solaris only) Give VM thread an extra quanta</div><div class="line">     intx VMThreadPriority                          = -1                                  &#123;product&#125;The native priority at which the VM thread should run (-1 means no change)</div><div class="line">     intx VMThreadStackSize                         = 1024                                &#123;pd product&#125;Non-Java Thread Stack Size (in Kbytes)</div><div class="line">     intx ValueMapInitialSize                       = 11                                  &#123;C1 product&#125;Initial size of a value map</div><div class="line">     intx ValueMapMaxLoopSize                       = 8                                   &#123;C1 product&#125;maximum size of a loop optimized by global value numbering</div><div class="line">     intx ValueSearchLimit                          = 1000                                &#123;C2 product&#125;Recursion limit in PhaseMacroExpand::value_from_mem_phi</div><div class="line">     bool Verbose                                   = false                               &#123;develop&#125;Print additional debugging information from other modes</div><div class="line">     bool VerboseInternalVMTests                    = false                               &#123;notproduct&#125;Turn on logging for internal VM tests.</div><div class="line">     bool VerboseVerification                       = false                               &#123;diagnostic&#125;Display detailed verification details</div><div class="line">     bool VerifyActivationFrameSize                 = false                               &#123;develop&#125;Verify that activation frame didn&apos;t become smaller than its minimal size</div><div class="line">     bool VerifyAdapterCalls                        = true                                &#123;diagnostic&#125;Verify that i2c/c2i adapters are called properly</div><div class="line">     bool VerifyAdapterSharing                      = false                               &#123;develop&#125;Verify that the code for shared adapters is the equivalent</div><div class="line">     bool VerifyAfterGC                             = false                               &#123;diagnostic&#125;Verify memory system after GC</div><div class="line">     bool VerifyAliases                             = false                               &#123;C2 develop&#125;perform extra checks on the results of alias analysis</div><div class="line">     bool VerifyBeforeExit                          = true                                &#123;diagnostic&#125;Verify system before exiting</div><div class="line">     bool VerifyBeforeGC                            = false                               &#123;diagnostic&#125;Verify memory system before GC</div><div class="line">     bool VerifyBeforeIteration                     = false                               &#123;diagnostic&#125;Verify memory system before JVMTI iteration</div><div class="line">     bool VerifyBlockOffsetArray                    = false                               &#123;develop&#125;Do (expensive) block offset array verification</div><div class="line">     bool VerifyCodeCacheOften                      = false                               &#123;notproduct&#125;Verify compiled-code cache often</div><div class="line">     bool VerifyCompiledCode                        = false                               &#123;develop&#125;Include miscellaneous runtime verifications in nmethod code; default off because it disturbs nmethod size heuristics</div><div class="line">     bool VerifyConnectionGraph                     = true                                &#123;C2 notproduct&#125;Verify Connection Graph construction in Escape Analysis</div><div class="line">     bool VerifyDUIterators                         = true                                &#123;C2 notproduct&#125;Verify the safety of all iterations of Bi-directional Edges</div><div class="line">     bool VerifyDataPointer                         = true                                &#123;develop&#125;Verify the method data pointer during interpreter profiling</div><div class="line">     bool VerifyDependencies                        = true                                &#123;develop&#125;Exercise and verify the compilation dependency mechanism</div><div class="line">     bool VerifyDuringGC                            = false                               &#123;diagnostic&#125;Verify memory system during GC (between phases)</div><div class="line">     bool VerifyDuringStartup                       = false                               &#123;diagnostic&#125;Verify memory system before executing any Java code during VM initialization</div><div class="line">     bool VerifyFPU                                 = false                               &#123;develop&#125;Verify FPU state (check for NaN&apos;s, etc.)</div><div class="line">     intx VerifyGCLevel                             = 0                                   &#123;diagnostic&#125;Generation level at which to start +VerifyBefore/AfterGC</div><div class="line">    uintx VerifyGCStartAt                           = 0                                   &#123;diagnostic&#125;GC invoke count where +VerifyBefore/AfterGC kicks in</div><div class="line">     bool VerifyGenericSignatures                   = false                               &#123;develop&#125;Abort VM on erroneous or inconsistent generic signatures</div><div class="line">     bool VerifyGraphEdges                          = false                               &#123;C2 notproduct&#125;Verify Bi-directional Edges</div><div class="line">     bool VerifyHashTableKeys                       = true                                &#123;C2 notproduct&#125;Verify the immutability of keys in the VN hash tables</div><div class="line">     bool VerifyIdealNodeCount                      = false                               &#123;C2 notproduct&#125;Verify that tracked dead ideal node count is accurate</div><div class="line">     bool VerifyIterativeGVN                        = false                               &#123;C2 develop&#125;Verify Def-Use modifications during sparse Iterative Global Value Numbering</div><div class="line">     bool VerifyJNIEnvThread                        = false                               &#123;notproduct&#125;Verify JNIEnv.thread == Thread::current() when entering VM from JNI</div><div class="line">     bool VerifyJNIFields                           = true                                &#123;develop&#125;Verify jfieldIDs for instance fields</div><div class="line">     bool VerifyLastFrame                           = false                               &#123;notproduct&#125;Verify oops on last frame on entry to VM</div><div class="line">     bool VerifyLoopOptimizations                   = false                               &#123;C2 notproduct&#125;verify major loop optimizations</div><div class="line">     bool VerifyMergedCPBytecodes                   = true                                &#123;product&#125;Verify bytecodes after RedefineClasses constant pool merging</div><div class="line">     bool VerifyMethodHandles                       = true                                &#123;diagnostic&#125;perform extra checks when constructing method handles</div><div class="line">     bool VerifyObjectStartArray                    = true                                &#123;diagnostic&#125;Verify GC object start array if verify before/after</div><div class="line">     bool VerifyOops                                = false                               &#123;develop&#125;Do plausibility checks for oops</div><div class="line">     bool VerifyOpto                                = false                               &#123;C2 notproduct&#125;Apply more time consuming verification during compilation</div><div class="line">     bool VerifyOptoOopOffsets                      = false                               &#123;C2 notproduct&#125;Check types of base addresses in field references</div><div class="line">     bool VerifyReflectionBytecodes                 = false                               &#123;develop&#125;Force verification of 1.4 reflection bytecodes. Does not work in situations like that described in 4486457 or for constructors generated for serialization, so can not be enabled in product.</div><div class="line">     bool VerifyRegisterAllocator                   = false                               &#123;C2 notproduct&#125;Verify Register Allocator</div><div class="line">     bool VerifyRememberedSets                      = false                               &#123;diagnostic&#125;Verify GC remembered sets</div><div class="line">     bool VerifySharedSpaces                        = false                               &#123;product&#125;Verify shared spaces (false for default archive, true for archive specified by -XX:SharedArchiveFile)</div><div class="line">     bool VerifySilently                            = false                               &#123;diagnostic&#125;Do not print the verification progress</div><div class="line">     bool VerifyStack                               = false                               &#123;develop&#125;Verify stack of each thread when it is entering a runtime call</div><div class="line">     bool VerifyStackAtCalls                        = false                               &#123;develop&#125;Verify that the stack pointer is unchanged after calls</div><div class="line">     bool VerifyStringTableAtExit                   = false                               &#123;diagnostic&#125;verify StringTable contents at exit</div><div class="line">ccstrlist VerifySubSet                              =                                     &#123;diagnostic&#125;Memory sub-systems to verify when Verify*GC flag(s) are enabled. One or more sub-systems can be specified in a comma separated string. Sub-systems are: threads, heap, symbol_table, string_table, codecache, dictionary, classloader_data_graph, metaspace, jni_handles, c-heap, codecache_oops</div><div class="line">     bool VerifyThread                              = false                               &#123;develop&#125;Watch the thread register for corruption (SPARC only)</div><div class="line">     bool WalkStackALot                             = false                               &#123;notproduct&#125;Trace stack (no print) at every exit from the runtime system</div><div class="line">     intx WarmCallMaxSize                           = 999999                              &#123;C2 develop&#125;size of the largest inlinable method</div><div class="line">     intx WarmCallMaxWork                           = 999999                              &#123;C2 develop&#125;execution time of the largest inlinable method</div><div class="line">     intx WarmCallMinCount                          = -1                                  &#123;C2 develop&#125;number of calls (per method invocation) to enable inlining</div><div class="line">     intx WarmCallMinProfit                         = -1                                  &#123;C2 develop&#125;number of calls (per method invocation) to enable inlining</div><div class="line">    uintx WarnOnStalledSpinLock                     = 0                                   &#123;notproduct&#125;Print warnings for stalled SpinLocks</div><div class="line">     bool WhiteBoxAPI                               = false                               &#123;diagnostic&#125;Enable internal testing APIs</div><div class="line">     bool WizardMode                                = false                               &#123;develop&#125;Print much more debugging information</div><div class="line">     intx WorkAroundNPTLTimedWaitHang               = 1                                   &#123;product&#125;(Unstable, Linux-specific) avoid NPTL-FUTEX hang pthread_cond_timedwait</div><div class="line">    uintx YoungGenerationSizeIncrement              = 20                                  &#123;product&#125;Adaptive size percentage change in young generation</div><div class="line">    uintx YoungGenerationSizeSupplement             = 80                                  &#123;product&#125;Supplement to YoungedGenerationSizeIncrement used at startup</div><div class="line">    uintx YoungGenerationSizeSupplementDecay        = 8                                   &#123;product&#125;Decay factor to YoungedGenerationSizeSupplement</div><div class="line">    uintx YoungPLABSize                             = 4096                                &#123;product&#125;Size of young gen promotion LAB&apos;s (in HeapWords)</div><div class="line">     bool ZapDeadCompiledLocals                     = false                               &#123;develop&#125;Zap dead locals in compiler frames</div><div class="line">     intx ZapDeadCompiledLocalsFirst                = 0                                   &#123;C2 notproduct&#125;If +ZapDeadCompiledLocals, skip this many before really doing it</div><div class="line">     intx ZapDeadCompiledLocalsLast                 = -1                                  &#123;C2 notproduct&#125;If +ZapDeadCompiledLocals, do this many after skipping (incl. skip count, -1 = all)</div><div class="line">     bool ZapDeadLocalsOld                          = false                               &#123;notproduct&#125;Zap dead locals (old version, zaps all frames when entering the VM</div><div class="line">     bool ZapFillerObjects                          = true                                &#123;develop&#125;Zap filler objects with 0xDEAFBABE</div><div class="line">     bool ZapJNIHandleArea                          = true                                &#123;develop&#125;Zap freed JNI handle space with 0xFEFEFEFE</div><div class="line">     bool ZapResourceArea                           = true                                &#123;develop&#125;Zap freed resource/arena space with 0xABABABAB</div><div class="line">     bool ZapStackSegments                          = true                                &#123;notproduct&#125;Zap allocated/freed stack segments with 0xFADFADED</div><div class="line">     bool ZapUnusedHeapArea                         = true                                &#123;develop&#125;Zap unused heap space with 0xBAADBABE</div><div class="line">     bool ZapVMHandleArea                           = true                                &#123;notproduct&#125;Zap freed VM handle space with 0xBCBCBCBC</div><div class="line">     bool ZeroTLAB                                  = false                               &#123;product&#125;Zero out the newly created TLAB</div><div class="line">     bool ZombieALot                                = false                               &#123;notproduct&#125;Create zombies (non-entrant) at exit from the runtime system</div><div class="line">     intx ZombieALotInterval                        = 5                                   &#123;notproduct&#125;Number of exits until ZombieALot kicks in</div><div class="line">     intx hashCode                                  = 5                                   &#123;product&#125;(Unstable) select hashCode generation algorithm</div></pre></td></tr></table></figure>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/09/23/jvm/java-xx-command/" class="archive-article-date">
  	<time datetime="2016-09-23T03:30:40.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-09-23</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/JAVA/">JAVA</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
    <a href="/2016/09/23/jvm/string-intern/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="icon-circle-left"></i>
      <div class="article-nav-title">
        
          Java String Intern
        
      </div>
    </a>
  
  
    <a href="/2016/09/23/jvm/symbol-table-1/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">JVM之SymbolTable(一)</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>




<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
	    <a class="jiathis_button_twitter"></a>
	    <a class="jiathis_button_plus"></a> 
	    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="jvm/java-xx-command" data-title="Java 命令行---XX详解" data-url="http://yoursite.com/2016/09/23/jvm/java-xx-command/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>





      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 Corner XX
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/"
	}
</script>

<script src="/./main.js"></script>





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/Hadoop-Hdfs/" style="font-size: 10px;">Hadoop Hdfs</a> <a href="/tags/Hadoop-Yran/" style="font-size: 10px;">Hadoop Yran</a> <a href="/tags/Hbase/" style="font-size: 16.67px;">Hbase</a> <a href="/tags/Hdfs/" style="font-size: 13.33px;">Hdfs</a> <a href="/tags/JVM/" style="font-size: 20px;">JVM</a> <a href="/tags/Kernel/" style="font-size: 13.33px;">Kernel</a> <a href="/tags/OpenJDK/" style="font-size: 13.33px;">OpenJDK</a> <a href="/tags/Phoenix/" style="font-size: 10px;">Phoenix</a> <a href="/tags/algorithm/" style="font-size: 16.67px;">algorithm</a> <a href="/tags/streamset/" style="font-size: 10px;">streamset</a>
    			</div>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">记录点点滴滴</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>