<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Corner XX daily log</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Corner XX daily log">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Corner XX daily log">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Corner XX daily log">
  
    <link rel="alternative" href="/atom.xml" title="Corner XX daily log" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.png">
  
  <script src="/style.js"></script>
</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/img/suolong.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Corner XX</a></h1>
		</hgroup>

		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="#" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/cornerxx" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">Corner XX</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="/img/suolong.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Corner XX</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/cornerxx" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-jvm/hotsport_c1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="hotspot运行时编译器"><a href="#hotspot运行时编译器" class="headerlink" title="hotspot运行时编译器"></a>hotspot运行时编译器</h2><p>Java虚拟机引用了JIT技术，极大增强的虚拟机的运行效率，这篇主要介绍hotsport中的c1编译器。c1编译器做了一些简单的优化技术，目标主要面向快速编译的需求，比如桌面系统等短时间运行的程序，将自己码快速编译成本地代码。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/04/11/jvm/hotsport_c1/" class="archive-article-date">
  	<time datetime="2017-04-11T01:43:43.251Z" itemprop="datePublished"><i class="icon-clock"></i>2017-04-11</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-伪缓存共享" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="伪缓存共享"><a href="#伪缓存共享" class="headerlink" title="伪缓存共享"></a>伪缓存共享</h1><ul>
<li>基础知识</li>
<li>什么是伪缓存共享？</li>
<li>怎么解决伪缓存共享的问题？</li>
<li>如何查看一个Java对象在内存中的表示？</li>
</ul>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>先看一个图（以下图均来自《深入理解计算机系统》）<br><img src="http://i.imgur.com/yelGjGf.png" alt=""><br>这个图表示一个处理器访问内存需要经过的存储层次，首先访问1级缓存，其次访问逻辑核共享的二级缓存，再访问处理器包共享的3级缓存，最后才是访问内存。<br><img src="http://i.imgur.com/GnJIIfI.png" alt=""><br>通过一些文献的数据，我们知道这些存储层次的时效。<br><img src="http://i.imgur.com/8uqfC1H.png" alt=""></p>
<p>通过以上的图例，可以了解到不同的存储层次访问所占用的延迟会有很大的差别，特别高速缓存和内存，内存和磁盘之间的访问速率。<br>我们可以利用时间局部性（一个良好的时间局部性的程序，被引用过一次的存储器位置可能在不远的将来被多次引用）和空间局部性（一个空间局部性良好的程序，如果一个存储器位置被引用了一次，那么程序很可能在不远的将来引用附近的一个存储器位置）编写对计算机良好的程序，可以极大的提成程序的性能。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a[M][N])</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> i,j,sum=<span class="number">0</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">for</span>(i =<span class="number">0</span> ; i &lt; M;i++)&#123;</div><div class="line">		<span class="keyword">for</span>(j =<span class="number">0</span>;j&lt; N;j++)&#123;</div><div class="line">			sum += a[i][j];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum1</span><span class="params">(<span class="keyword">int</span> a[M][N])</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> i,j,sum=<span class="number">0</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">for</span>(i =<span class="number">0</span> ; i &lt; N;i++)&#123;</div><div class="line">		<span class="keyword">for</span>(j =<span class="number">0</span>;j&lt; M;j++)&#123;</div><div class="line">			sum += a[j][i];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上只是基础知识，这和我们要将的伪缓存共享有什么关系呢？<br>首先，在单处理器中，处理器的主存访问次序一下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">寄存器-&gt;1级缓存-&gt;2级缓存-&gt;3级缓存-&gt;主存</div></pre></td></tr></table></figure></p>
<p>所以高速缓存的设计直接影响了程序的性能。<br>其次，在多处理器中，处理器之间最重要的问题就是处理器共享数据的处理问题，在intel的处理器中，intel利用硬件保证数据的之间的可靠共享，但是会占用部分指令周期，从而导致严重的性能的问题，而这个问题也是我们这里需要讨论的。</p>
<h3 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h3><p>处理器加载内存的数据到高速缓存不是按照一个个字节加载，而是加载一批，在我们常用的处理器，缓存行为64byte，具体的相关信息可以参考高速缓存缓存行的具体资料。这也正是时间和空间局部性原理的具体体现。</p>
<h2 id="什么是伪缓存共享？"><a href="#什么是伪缓存共享？" class="headerlink" title="什么是伪缓存共享？"></a>什么是伪缓存共享？</h2><p>缓存系统中是以缓存行（cache line）为单位存储的。缓存行是2的整数幂个连续字节，一般为32-256个字节。最常见的缓存行大小是64个字节。当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。缓存行上的写竞争是运行在SMP系统中并行线程实现可伸缩性最重要的限制因素。有人将伪共享描述成无声的性能杀手，因为从代码中很难看清楚是否会出现伪共享。<br>为了让可伸缩性与线程数呈线性关系，就必须确保不会有两个线程往同一个变量或缓存行中写。两个线程写同一个变量可以在代码中发现。<br><img src="http://i.imgur.com/TXBcCCa.png" alt=""><br>说明了伪共享的问题。在核心1上运行的线程想更新变量X，同时核心2上的线程想要更新变量Y。不幸的是，这两个变量在同一个缓存行中。每个线程都要去竞争缓存行的所有权来更新变量。如果核心1获得了所有权，缓存子系统将会使核心2中对应的缓存行失效。当核心2获得了所有权然后执行更新操作，核心1就要使自己对应的缓存行失效。这会来来回回的经过L3缓存，大大影响了性能。如果互相竞争的核心位于不同的插槽，就要额外横跨插槽连接，问题可能更加严重。</p>
<p>我们先看看一个Java对象在内存中的布局<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> --------------</div><div class="line">| mark         |</div><div class="line"> --------------</div><div class="line">|metadata      |</div><div class="line"> --------------</div><div class="line">|instance 1    |</div><div class="line"> --------------</div><div class="line"> --------------</div><div class="line">|instance ...  |</div><div class="line"> --------------</div><div class="line"> --------------</div><div class="line">|instance N    |</div><div class="line"> --------------</div><div class="line"> --------------</div><div class="line">|padding       |</div><div class="line"> --------------</div><div class="line">``` </div><div class="line">JVM为了效率考虑会安排不同的内存布局,虚拟机提供了3中内存布局策略,不同的布局主要是对象引用所处的位置,虚拟机使用FieldsAllocationStyle参数进程控制.在这里同样需要考虑压缩指针的使用.为了合理使用内存,JVM提供一种压缩指针的技术,让对象引用由64bit的机器上更改伪32bit.可以极大节约内存的使用.</div><div class="line"></div><div class="line">对象的第一部分是元数据包含的运行时信息和指向klass的指针信息.开启压缩指针总共占用12个字节.</div><div class="line">mark表示的是一个对象指针,在运行时候虚拟机会直接对这个内存区域解释.</div></pre></td></tr></table></figure></p>
<p>//  64 bits:<br>//  ——–<br>//  unused:25 hash:31 –&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)<br>//  JavaThread<em>:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)<br>//  PromotedObject</em>:61 ———————&gt;| promo_bits:3 —–&gt;| (CMS promoted object)<br>//  size:64 —————————————————–&gt;| (CMS free block)<br>//<br>//  unused:25 hash:31 –&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)<br>//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)<br>//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 —–&gt;| (COOPs &amp;&amp; CMS promoted object)<br>//  unused:21 size:35 –&gt;| cms_free:1 unused:7 ——————&gt;| (COOPs &amp;&amp; CMS free block)<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">下面重点看一下各种不同的内存布局.</div><div class="line">第一种.对象引用放在对前面,后面是基本类型.</div></pre></td></tr></table></figure></p>
<p>////Fields order: oops, longs/doubles, ints, shorts/chars, bytes, padded fields</p>
<hr>
<h2 id="oop-1"><a href="#oop-1" class="headerlink" title="|   oop 1       |"></a>|   oop 1       |</h2><h2 id="oop-…"><a href="#oop-…" class="headerlink" title="|   oop …     |"></a>|   oop …     |</h2><h2 id="oop-n"><a href="#oop-n" class="headerlink" title="|   oop n       |"></a>|   oop n       |</h2><h2 id="basic-type"><a href="#basic-type" class="headerlink" title="|   basic type  |"></a>|   basic type  |</h2><h2 id="padding"><a href="#padding" class="headerlink" title="|   padding     |"></a>|   padding     |</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">首先,内存中排列的是对象引用,由于使用了压缩指针,每一个需要占用4个字节空间,long和double占用8个字节,int占用4个字节,short和char占用2个字节,byte占用1个字节.</div><div class="line">第二种.对象引用在最后,前面是基本类型</div></pre></td></tr></table></figure>
<h2 id="Fields-order-longs-doubles-ints-shorts-chars-bytes-oops-padded-fields"><a href="#Fields-order-longs-doubles-ints-shorts-chars-bytes-oops-padded-fields" class="headerlink" title="// Fields order: longs/doubles, ints, shorts/chars, bytes, oops, padded fields"></a>// Fields order: longs/doubles, ints, shorts/chars, bytes, oops, padded fields</h2><h2 id="oop-1-1"><a href="#oop-1-1" class="headerlink" title="|   oop 1       |"></a>|   oop 1       |</h2><h2 id="oop-…-1"><a href="#oop-…-1" class="headerlink" title="|   oop …     |"></a>|   oop …     |</h2><h2 id="oop-n-1"><a href="#oop-n-1" class="headerlink" title="|   oop n       |"></a>|   oop n       |</h2><h2 id="basic-type-1"><a href="#basic-type-1" class="headerlink" title="|   basic type  |"></a>|   basic type  |</h2><h2 id="padding-1"><a href="#padding-1" class="headerlink" title="|   padding     |"></a>|   padding     |</h2><p>com.corner.base.jvm.bytecode.TestBytecode: field layout<br>  @ 12 — instance fields start —<br>  @ 44 “a” Ljava.lang.String;<br>  @ 36 “e” S<br>  @ 38 “f” C<br>  @ 40 “h” B<br>  @ 41 “k” B<br>  @ 16 “c” J<br>  @ 24 “d” D<br>  @ 12 “b” I<br>  @ 32 “j” I<br>  @ 48 — instance fields end —<br>  @ 48 — instance ends —<br>  @104 — static fields start —<br>  @104 — static fields end —<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">首先,如果按照我们所说的,基本类型按照longs/doubles, ints, shorts/chars, bytes排列内存布局很明显不对,这是因为JVM为了充分利用内存,8个字节的long和double会做内存对齐,这样如果先存储long和double会留4个字节的空洞,JVM会安排其他的域填充到这个序列中,这里选择了占用4个字节b成员,后面才是按照布局二产生的内存布局.另外为了保证对齐,虚拟机会在每个对象做内存对齐.作为填充.从这个例子中,我们可以知道这个对象在内存中大小为48字节.8字节对齐.</div><div class="line"></div><div class="line">因此当封装对象的时候为了高效率，对象字段声明的顺序会被重排序成下列基于字节大小的顺序：</div><div class="line">doubles (8) 和 longs (8)</div><div class="line">ints (4) 和 floats (4)</div><div class="line">shorts (2) 和 chars (2)</div><div class="line">booleans (1) 和 bytes (1)</div><div class="line">references (4/8)</div><div class="line">&lt;子类字段重复上述顺序&gt;</div><div class="line"></div><div class="line">内存布局最基本的是以上两种情况,还有一种就不说了.下面,JVM会对对象区和头部区做归零动作.做完所有的步骤,基本完成了一个对象的内存分配过程.</div><div class="line"></div><div class="line">我们稍微总结一下,内存分配主要考虑管理组织和实际使用的空间,尽量将使用率最大化,压缩管理所使用的空间,尽量将分配的对象保持内存对齐,让其对高速缓存是友好的代码,这些知识在我们编写Java程序已经被系统程序员隐藏了,了解了这些可以让我们更加了解系统的运行过程,写出更加符合JVM的程序.一个对象分配的时候静态区不包含在对象中,所有成员的位置都是Klass确定的.</div><div class="line"></div><div class="line">为了展示其性能影响，我们启动几个线程，每个都更新它自己独立的计数器。计数器是volatile long类型的，所以其它线程能看到它们的进展。</div><div class="line"></div><div class="line">```java</div><div class="line">public final class FalseSharing</div><div class="line">		implements Runnable</div><div class="line">&#123;</div><div class="line">	public final static int NUM_THREADS = 4; // change</div><div class="line"></div><div class="line">	public final static long ITERATIONS = 500L * 1000L * 1000L;</div><div class="line"></div><div class="line">	private final int arrayIndex;</div><div class="line"></div><div class="line">	private static VolatileLong[] longs = new VolatileLong[NUM_THREADS];</div><div class="line"></div><div class="line">	static</div><div class="line">	&#123;</div><div class="line">		for (int i = 0; i &lt; longs.length; i++)</div><div class="line">		&#123;</div><div class="line">			longs[i] = new VolatileLong();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public FalseSharing(final int arrayIndex)</div><div class="line">	&#123;</div><div class="line">		this.arrayIndex = arrayIndex;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	public static void main(final String[] args) throws Exception</div><div class="line">	&#123;</div><div class="line">		final long start = System.nanoTime();</div><div class="line">		runTest();</div><div class="line">		System.out.println(&quot;duration = &quot; + (System.nanoTime() - start));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static void runTest() throws InterruptedException</div><div class="line">	&#123;</div><div class="line">		Thread[] threads = new Thread[NUM_THREADS];</div><div class="line"></div><div class="line">		for (int i = 0; i &lt; threads.length; i++)</div><div class="line">		&#123;</div><div class="line">			threads[i] = new Thread(new FalseSharing(i));</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		for (Thread t : threads)</div><div class="line">		&#123;</div><div class="line">			t.start();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		for (Thread t : threads)</div><div class="line">		&#123;</div><div class="line">			t.join();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void run()</div><div class="line">	&#123;</div><div class="line">		long i = ITERATIONS + 1;</div><div class="line"></div><div class="line">		while (0 != --i)</div><div class="line">		&#123;</div><div class="line">			longs[arrayIndex].value = i;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public final static class VolatileLong</div><div class="line">	&#123;</div><div class="line">		public volatile long value = 0L;</div><div class="line"></div><div class="line">		public long p1, p2, p3, p4, p5, p6; // comment out</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行上面的代码，增加线程数以及添加/移除缓存行的填充，下面的图2描述了我得到的结果。这是在4核Nehalem上测得的运行时间。</p>
<p><img src="http://i.imgur.com/mjvNghu.png" alt=""></p>
<p>从不断上升的测试所需时间中能够明显看出伪共享的影响。没有缓存行竞争时，我们几近达到了随着线程数的线性扩展。</p>
<p>这并不是个完美的测试，因为我们不能确定这些VolatileLong会布局在内存的什么位置。它们是独立的对象。但是经验告诉我们同一时间分配的对象趋向集中于一块。</p>
<p>所以你也看到了，伪共享可能是无声的性能杀手。</p>
<h3 id="JDK7-以上代码并没有什么提升？"><a href="#JDK7-以上代码并没有什么提升？" class="headerlink" title="JDK7 以上代码并没有什么提升？"></a>JDK7 以上代码并没有什么提升？</h3><p>对于以上的代码在JDK7运行中并没有用，这是因为JDK增加了一个特性，对没有使用的字段进行屏蔽。<br>import java.util.concurrent.atomic.AtomicLong;</p>
<p>public class FalseSharingFinal  implements Runnable<br>{<br>    public final static int NUM_THREADS = 4; // change<br>    public final static long ITERATIONS = 500L <em> 1000L </em> 1000L;<br>    private final int arrayIndex;</p>
<pre><code>private static PaddedAtomicLong[] longs = new PaddedAtomicLong[NUM_THREADS];
static
{
    for (int i = 0; i &lt; longs.length; i++)
    {
        longs[i] = new PaddedAtomicLong();
    }
}

public FalseSharingFinal(final int arrayIndex)
{
    this.arrayIndex = arrayIndex;
}

public static void main(final String[] args) throws Exception
{
    final long start = System.nanoTime();
    runTest();
    System.out.println(&quot;duration = &quot; + (System.nanoTime() - start));
}

private static void runTest() throws InterruptedException
{
    Thread[] threads = new Thread[NUM_THREADS];

    for (int i = 0; i &lt; threads.length; i++)
    {
        threads[i] = new Thread(new FalseSharing(i));
    }

    for (Thread t : threads)
    {
        t.start();
    }

    for (Thread t : threads)
    {
        t.join();
    }
}

public void run()
{
    long i = ITERATIONS + 1;
    while (0 != --i)
    {
        longs[arrayIndex].set(i);
    }
}

// 之所以加入这段，主要是为了防止jdk7对没有使用的字段进行优化
public static long sumPaddingToPreventOptimisation(final int index)
{
    PaddedAtomicLong v = longs[index];
    return v.p1 + v.p2 + v.p3 + v.p4 + v.p5 + v.p6;
}

public static class PaddedAtomicLong extends AtomicLong
{
    public volatile long p1, p2, p3, p4, p5, p6 = 7L;
}
</code></pre><p>}</p>
<h2 id="伪缓存共享的场景"><a href="#伪缓存共享的场景" class="headerlink" title="伪缓存共享的场景"></a>伪缓存共享的场景</h2><ul>
<li>disruptor一个重要组件其主要思想就是避免伪缓存共享场景，从而达到更加高效的实现。</li>
</ul>
<h2 id="怎么解决伪缓存共享的问题？"><a href="#怎么解决伪缓存共享的问题？" class="headerlink" title="怎么解决伪缓存共享的问题？"></a>怎么解决伪缓存共享的问题？</h2><p>主要就是让修改比较平凡的数据占满一个缓存行，对于变更不是很平凡的数据没有必要使用这个优化。</p>
<h2 id="如何查看一个Java对象在内存中的表示？"><a href="#如何查看一个Java对象在内存中的表示？" class="headerlink" title="如何查看一个Java对象在内存中的表示？"></a>如何查看一个Java对象在内存中的表示？</h2><ul>
<li><p>使用的工具有很多，比如jol，这个工具的主页为<a href="http://openjdk.java.net/projects/code-tools/jol/。" target="_blank" rel="external">http://openjdk.java.net/projects/code-tools/jol/。</a><br>以下是一个实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">PaddedAtomicLong object internals:</div><div class="line"> OFFSET  SIZE  TYPE DESCRIPTION                    VALUE</div><div class="line">      0    12       (object header)                N/A</div><div class="line">     12     4       (alignment/padding gap)        N/A</div><div class="line">     16     8  long AtomicLong.value               N/A</div><div class="line">     24     8  long PaddedAtomicLong.p1            N/A</div><div class="line">     32     8  long PaddedAtomicLong.p2            N/A</div><div class="line">     40     8  long PaddedAtomicLong.p3            N/A</div><div class="line">     48     8  long PaddedAtomicLong.p4            N/A</div><div class="line">     56     8  long PaddedAtomicLong.p5            N/A</div><div class="line">     64     8  long PaddedAtomicLong.p6            N/A</div><div class="line">Instance size: 72 bytes (estimated, the sample instance is not available)</div><div class="line">Space losses: 4 bytes internal + 0 bytes external = 4 bytes total</div></pre></td></tr></table></figure>
</li>
<li><p>还有sa-jdi.jar中的sun.jvm.hotspot.HSDB工具。</p>
</li>
<li><p>在debug版本的jdk中，可以打开PrintFieldLayout选项查看对应对象的内存布局。</p>
</li>
</ul>
<h2 id="使用系统工具查看高速缓存"><a href="#使用系统工具查看高速缓存" class="headerlink" title="使用系统工具查看高速缓存"></a>使用系统工具查看高速缓存</h2><p>如何从系统层面观察到这种优化是切实有效的呢? 很可惜, 由于很多计算机的微架构不同, 我们没有工具来直接探测伪共享事件(包括Intel Vtune和Valgrind). 所有的工具都是从侧面来发现的, 下面通过Linux利器OProfile来证明一下. 上面的程序的数组只是占64 * 4 = 256字节, 而且在连续的物理空间, 照理来说数据会在L1缓存上就命中, 肯定不会传入到L2缓存中, 只有在伪共享发生时才会出现. 于是, 我们可以通过观察L2缓存的IN事件就可以证明了,步骤如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># 设置捕捉L2缓存IN事件</div><div class="line">$ sudo  opcontrol --setup --event=L2_LINES_IN:100000</div><div class="line"># 清空工作区</div><div class="line">$ sudo opcontrol --reset</div><div class="line"># 开始捕捉</div><div class="line">$ sudo opcontrol --start</div><div class="line"># 运行程序</div><div class="line">$ java FalseSharing</div><div class="line"># 程序跑完后, dump捕捉到的数据</div><div class="line">$ sudo opcontrol --dump</div><div class="line"># 停止捕捉</div><div class="line">$ sudo opcontrol -h</div><div class="line"># 报告结果</div><div class="line">$ opreport -l `which java`</div></pre></td></tr></table></figure></p>
<p>没有填充的版本<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">opreport -l `which java`</div><div class="line">CPU: Intel Westmere microarchitecture, speed 2400.2 MHz (estimated)</div><div class="line">Counted L2_LINES_IN events (L2 lines alloacated) with a unit mask of 0x07 (any L2 lines alloacated) count 100000</div><div class="line">samples  %        image name               symbol name</div><div class="line">34085    99.8447  anon (tgid:18051 range:0x7fcdee53d000-0x7fcdee7ad000) anon (tgid:18051 range:0x7fcdee53d000-0x7fcdee7ad000)</div><div class="line">51        0.1494  anon (tgid:16054 range:0x7fa485722000-0x7fa485992000) anon (tgid:16054 range:0x7fa485722000-0x7fa485992000)</div><div class="line">2         0.0059  anon (tgid:2753 range:0x7f43b317e000-0x7f43b375e000) anon (tgid:2753 range:0x7f43b317e000-0x7f43b375e000)</div></pre></td></tr></table></figure></p>
<p>填充版本<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ opreport -l `which java`</div><div class="line">CPU: Intel Westmere microarchitecture, speed 2400.2 MHz (estimated)</div><div class="line">Counted L2_LINES_IN events (L2 lines alloacated) with a unit mask of 0x07 (any L2 lines alloacated) count 100000</div><div class="line">samples  %        image name               symbol name</div><div class="line">22       88.0000  anon (tgid:18873 range:0x7f3e3fa8a000-0x7f3e3fcfa000) anon (tgid:18873 range:0x7f3e3fa8a000-0x7f3e3fcfa000)</div><div class="line">3        12.0000  anon (tgid:2753 range:0x7f43b317e000-0x7f43b375e000) anon (tgid:2753 range:0x7f43b317e000-0x7f43b375e000)</div></pre></td></tr></table></figure></p>
<p>慢的版本由于False Sharing引发的L2缓存IN事件达34085次, 而快版本的为0次.</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/03/20/伪缓存共享/" class="archive-article-date">
  	<time datetime="2017-03-20T05:56:15.652Z" itemprop="datePublished"><i class="icon-clock"></i>2017-03-20</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-jvm/锁的衡量指标" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>锁的衡量指标</p>
<p>1.性能<br>在早起自旋锁的实现中，主要是空转CPU，同时也不能切换上线文，操作系统如果需要切换上线文，必须等到时间片用完。导致性能底下，浪费能源。后续增加了让线程睡眠功能，让进程能够切换，同时充分利用CPU资源(同时此种实现需要考虑上下文切换带来的影响)。为了降低能耗，提高CPU的利用率，Intel增加了pause指令替代让线程睡眠。所以我们反汇编时在自旋锁的实现中，总能看到pause指令的身影。到后来的读写锁，以及现在的RCU锁，这些锁的实现比较适合读多，写少的情况，将锁更加细分为读写两种，RCU锁更是利用指令的原子性，将写锁细化为更改和删除，更改是原子性的，删除只会在其他线程不在共享资源的情况下，由操作系统找到一个合适的机会安全的回收资源。</p>
<p>1.公平性<br>如果让各个线程共同竞争共享资源，此时可能导致部分线程饿死，这是因为，在竞争共享资源，不加一些特殊的处理，可能导致相同的线程总是持有锁，从而导致其他线程饿死的情况，所以考虑线程的公平性也是锁实现的一方面。</p>
<p>1.排他性<br>有个实现只允许</p>
<p>2.可重入</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/03/18/jvm/锁的衡量指标/" class="archive-article-date">
  	<time datetime="2017-03-18T02:26:10.270Z" itemprop="datePublished"><i class="icon-clock"></i>2017-03-18</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-jvm/thread_dump_note" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Java线程栈"><a href="#Java线程栈" class="headerlink" title="Java线程栈"></a>Java线程栈</h2><p>在我们通过命令打出对应的线程栈的时候,通常县城会处于各种不同的状态,这些状态表示什么意思,不同状态之间的转换又是什么样?</p>
<h3 id="Java线程状态"><a href="#Java线程状态" class="headerlink" title="Java线程状态"></a>Java线程状态</h3><p>Java线程通常会处于以下几种状态:</p>
<ul>
<li>NEW</li>
<li>RUNNABLE</li>
<li>BLOCKED</li>
<li>WAITING</li>
<li>TIMED_WAITING</li>
<li>TERMINATED</li>
</ul>
<p>不同的状态表示不同的含义,也仅有的几个方法才能将当前线程进入相关的状态.</p>
<h3 id="Java线程栈的状态"><a href="#Java线程栈的状态" class="headerlink" title="Java线程栈的状态"></a>Java线程栈的状态</h3><p>我们导出的线程状态包含以下几种状态:</p>
<ul>
<li>NEW</li>
<li>RUNNABLE</li>
<li>TIMED_WAITING (sleeping)</li>
<li>WAITING (on object monitor)</li>
<li>TIMED_WAITING (on object monitor)</li>
<li>WAITING (parking)</li>
<li>TIMED_WAITING (parking)</li>
<li>BLOCKED (on object monitor)</li>
<li>TERMINATED</li>
</ul>
<p>我们开始这个状态之前先了解一下一个Java线程创建的过程,在Linux中Java线程使用的pthread线程库,由于这个线程库使用的用户态和内存态模型为1:1模型(不懂的话,找一下相关资料,Linux一个进程运行的过程中区分用户态和内核态,操作系统的调度在内核态进行,而应用程序只能感知用户态的信息,如果我们创建一个线程其实就是在用户态创建,但操作系统调度基于在内核态中能够看到的内核线程,这样就涉及一个用户线程和内核线程的映射关系,基本映射关系分为1:N,1:1,M:N).<br>我们创建Java线程原始的有两种方法(不包括线城池,线程池只是在两个原始的方法创建的变种):</p>
<ul>
<li>直接继承于Thread,然后创建Thread对象,调用start方法</li>
<li>实现Runnable方法,然后将这个对象作为参数传给Thread后,调用start方法,推荐使用此种方法.由于Java是单继承模型,如果继承Thread就损失了这种继承体系的优点,另外此种方法也有利于资源共享.</li>
</ul>
<p>其实两种方法都是一样的,只是做法不同,最终都是调用Thread对象的run方法,只不过Runnable方式做了一层代理,更加符合面向对象编程.</p>
<p>我们可以定义在执行run方法前都作为线程初始化过程,执行run方法后表示线程已经完成初始化.</p>
<h4 id="NEW"><a href="#NEW" class="headerlink" title="NEW"></a>NEW</h4><p>当线程处于创建和初始化的时候,状态为NEW,需要注意的是,这里的初始化和对象的初始化不一样,创建指的是Thread对象的创建,初始化在执行run方法前都是NEW状态,表明此时还不接受JMV(注意这里说的是虚拟机,而不是操作系统,在执行run方法前,操作系统已经创建了内核线程,接受操作系统的调度了,只不过被虚拟机滞留了)的调度.</p>
<h3 id="RUNNABLE"><a href="#RUNNABLE" class="headerlink" title="RUNNABLE"></a>RUNNABLE</h3><p>当执行run方法后,线程就处于RUNNABLE了,其他的线程状态同样也会将线程状态置换为此状态.</p>
<h3 id="TIMED-WAITING-sleeping"><a href="#TIMED-WAITING-sleeping" class="headerlink" title="TIMED_WAITING (sleeping)"></a>TIMED_WAITING (sleeping)</h3><p>由线程执行Thread.sleep()时,线程处于此状态.线程执行这个方法的时候需要注意的是</p>
<ul>
<li>虚拟机可以将Thread.sleep(0)调用转换为yield调用,即放弃当前时间片,让操作系统调度其他进程运行.yield调用并不是说当前线程一定不会继续运行,如果就绪队列没有其他可运行的进程,操作系统仍然运行此线程(这里的线程和进程并没有特殊的区分,yield实现具体依赖Linux调度策略).</li>
<li>虚拟机调用{Thread.sleep(n)|n&gt;0},表示线程主动挂起指定时间,让出当前时间片,挂起n毫秒,让其他线程有机会运行,此时此内核线程处于TASK_INTERRUPTIBLE状态 ，<br>虚拟机使用了pthread_cond_timedwait实现Thread.sleep()调用(在参数为0的情况下略有区别)，pthread_cond_timedwait函数采用了sys_futex系统调用实现。</li>
</ul>
<p>通过上面的描述，我们可以知道Thread.sleep(0)和Thread.yield()调用在默认情况下是一致的。Thread.sleep(n)虚拟机采用了park算法,在这个场景的park算法只会允许一个同步操作，另外Thread.sleep(n)调用线程可以通过指定时间超时（依赖操作系统底层实现）和interrupt调用才会结束这个调用，线程调用Thread.sleep(n)超时自动进入RUNNABLE状态，interrupt将终端线程执行。Thread.sleep(0)不允许调用interrupt中断。</p>
<h3 id="WAITING-on-object-monitor"><a href="#WAITING-on-object-monitor" class="headerlink" title="WAITING (on object monitor)"></a>WAITING (on object monitor)</h3><p>由线程执行Object.wait()时,线程处于此状态.</p>
<h3 id="TIMED-WAITING-on-object-monitor"><a href="#TIMED-WAITING-on-object-monitor" class="headerlink" title="TIMED_WAITING (on object monitor)"></a>TIMED_WAITING (on object monitor)</h3><p>由线程执行Object.wait(long)时,线程处于此状态.</p>
<h3 id="WAITING-parking"><a href="#WAITING-parking" class="headerlink" title="WAITING (parking)"></a>WAITING (parking)</h3><p>由线程执行LockSupport.park()时,线程处于此状态.</p>
<h3 id="TIMED-WAITING-parking"><a href="#TIMED-WAITING-parking" class="headerlink" title="TIMED_WAITING (parking)"></a>TIMED_WAITING (parking)</h3><p>由线程执行LockSupport.park(long)时,线程处于此状态.</p>
<h3 id="BLOCKED-on-object-monitor"><a href="#BLOCKED-on-object-monitor" class="headerlink" title="BLOCKED (on object monitor)"></a>BLOCKED (on object monitor)</h3><p>由线程等待进入同步区域时,线程处于此状态.也是我们分析线程最需要关注的状态</p>
<h3 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h3><p>由线程执行Thread.sleep()时,线程处于此状态.</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/03/09/jvm/thread_dump_note/" class="archive-article-date">
  	<time datetime="2017-03-09T02:09:41.694Z" itemprop="datePublished"><i class="icon-clock"></i>2017-03-09</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-jvm/jvm_object_init_call" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="从JVM理解对象初始化和调用"><a href="#从JVM理解对象初始化和调用" class="headerlink" title="从JVM理解对象初始化和调用"></a>从JVM理解对象初始化和调用</h2><p>之前也描述了Object对象初始化的过程,从类的加载和静态成员的初始化过程,我们在这里更加深入系统的介绍我们对一个对象赋值JVM所经历的过程.本章介绍一个对象的初始化过程和成员赋值的过程.</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.corner.base.jvm.bytecode;</div><div class="line"></div><div class="line">public class TestBytecode &#123;</div><div class="line">//Fields order: oops, longs/doubles, ints, shorts/chars, bytes, padded fields</div><div class="line">//Fields order: longs/doubles, ints, shorts/chars, bytes, oops, padded fields</div><div class="line">//Fields allocation: oops fields in super and sub classes are together.</div><div class="line">	private String a = &quot;aa&quot;;</div><div class="line">	private short e = 1;</div><div class="line">	private char f = 1;</div><div class="line">	private byte h = 1;</div><div class="line">	private byte k = 1;</div><div class="line">	private long c= 1;</div><div class="line">	private double d = 1;</div><div class="line">	private int b = 0;</div><div class="line">	private int j = 0;</div><div class="line">	</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new TestBytecode().b = 1;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此段代码反汇编成字节码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">corner@corner:~/workspace/test/target/classes$ javap -c -l com/corner/base/jvm/bytecode/TestBytecode.class </div><div class="line">Compiled from &quot;TestBytecode.java&quot;</div><div class="line">public class com.corner.base.jvm.bytecode.TestBytecode &#123;</div><div class="line">  public com.corner.base.jvm.bytecode.TestBytecode();</div><div class="line">    Code:</div><div class="line">       0: aload_0</div><div class="line">       1: invokespecial #24                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</div><div class="line">       4: aload_0</div><div class="line">       5: ldc           #26                 // String aa</div><div class="line">       7: putfield      #28                 // Field a:Ljava/lang/String;</div><div class="line">      10: aload_0</div><div class="line">      11: iconst_1</div><div class="line">      12: putfield      #30                 // Field e:S</div><div class="line">      15: aload_0</div><div class="line">      16: iconst_1</div><div class="line">      17: putfield      #32                 // Field f:C</div><div class="line">      20: aload_0</div><div class="line">      21: iconst_1</div><div class="line">      22: putfield      #34                 // Field h:B</div><div class="line">      25: aload_0</div><div class="line">      26: iconst_1</div><div class="line">      27: putfield      #36                 // Field k:B</div><div class="line">      30: aload_0</div><div class="line">      31: lconst_1</div><div class="line">      32: putfield      #38                 // Field c:J</div><div class="line">      35: aload_0</div><div class="line">      36: dconst_1</div><div class="line">      37: putfield      #40                 // Field d:D</div><div class="line">      40: aload_0</div><div class="line">      41: iconst_0</div><div class="line">      42: putfield      #42                 // Field b:I</div><div class="line">      45: aload_0</div><div class="line">      46: iconst_0</div><div class="line">      47: putfield      #44                 // Field j:I</div><div class="line">      50: return</div><div class="line">    LineNumberTable:</div><div class="line">      line 3: 0</div><div class="line">      line 7: 4</div><div class="line">      line 8: 10</div><div class="line">      line 9: 15</div><div class="line">      line 10: 20</div><div class="line">      line 11: 25</div><div class="line">      line 12: 30</div><div class="line">      line 13: 35</div><div class="line">      line 14: 40</div><div class="line">      line 15: 45</div><div class="line">      line 3: 50</div><div class="line">    LocalVariableTable:</div><div class="line">      Start  Length  Slot  Name   Signature</div><div class="line">          0      51     0  this   Lcom/corner/base/jvm/bytecode/TestBytecode;</div><div class="line"></div><div class="line">  public static void main(java.lang.String[]);</div><div class="line">    Code:</div><div class="line">       0: new           #1                  // class com/corner/base/jvm/bytecode/TestBytecode</div><div class="line">       3: dup</div><div class="line">       4: invokespecial #52                 // Method &quot;&lt;init&gt;&quot;:()V</div><div class="line">       7: iconst_1</div><div class="line">       8: putfield      #42                 // Field b:I</div><div class="line">      11: return</div><div class="line">    LineNumberTable:</div><div class="line">      line 19: 0</div><div class="line">      line 20: 11</div><div class="line">    LocalVariableTable:</div><div class="line">      Start  Length  Slot  Name   Signature</div><div class="line">          0      12     0  args   [Ljava/lang/String;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从第一个字节码new开始,我们一步步的看执行过程.</p>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>new字节码的含义是在Java堆中开辟一个空间存放我们建立的对象,一个Java对象在内存中的布局我们后面讨论,在这里详细描述一个对象在Java线程运行过程中分配的大致策略.此处不涉及具体Java堆的分配策略.<br>首先,JVM首先检测指定的类是否已经加载,如果没有加载,必须有加载器进行加载,链接,初始化工作,如果已经加载,虚拟机将进行下一步.<br>其次,JVM支持一个叫TLAB(thread-local object allocation,后面叫TLAB)的概念,支持 TLAB的垃圾回收器会为每一个线程创建一个叫TLAB的内存区域,这样已经初始化的类就会直接在此局域进程分配,如果分配失败,JVM会继续在eden中分配<br>最后,如果以上还是分配失败了,JVM可能会重建TLAB然后重新分配或者在Java堆中分配.<br>那么,JVM怎么确定一个对象在内存中的大小呢?</p>
<p>我们先看看一个Java对象在内存中的布局<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> --------------</div><div class="line">| mark         |</div><div class="line"> --------------</div><div class="line">|metadata      |</div><div class="line"> --------------</div><div class="line">|instance 1    |</div><div class="line"> --------------</div><div class="line"> --------------</div><div class="line">|instance ...  |</div><div class="line"> --------------</div><div class="line"> --------------</div><div class="line">|instance N    |</div><div class="line"> --------------</div><div class="line"> --------------</div><div class="line">|padding       |</div><div class="line"> --------------</div><div class="line">``` </div><div class="line">JVM为了效率考虑会安排不同的内存布局,虚拟机提供了3中内存布局策略,不同的布局主要是对象引用所处的位置,虚拟机使用FieldsAllocationStyle参数进程控制.在这里同样需要考虑压缩指针的使用.为了合理使用内存,JVM提供一种压缩指针的技术,让对象引用由64bit的机器上更改伪32bit.可以极大节约内存的使用.</div><div class="line"></div><div class="line">对象的第一部分是元数据包含的运行时信息和指向klass的指针信息.开启压缩指针总共占用12个字节.</div><div class="line">mark表示的是一个对象指针,在运行时候虚拟机会直接对这个内存区域解释.</div></pre></td></tr></table></figure></p>
<p>//  64 bits:<br>//  ——–<br>//  unused:25 hash:31 –&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)<br>//  JavaThread<em>:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)<br>//  PromotedObject</em>:61 ———————&gt;| promo_bits:3 —–&gt;| (CMS promoted object)<br>//  size:64 —————————————————–&gt;| (CMS free block)<br>//<br>//  unused:25 hash:31 –&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)<br>//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)<br>//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 —–&gt;| (COOPs &amp;&amp; CMS promoted object)<br>//  unused:21 size:35 –&gt;| cms_free:1 unused:7 ——————&gt;| (COOPs &amp;&amp; CMS free block)<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">下面重点看一下各种不同的内存布局.</div><div class="line">第一种.对象引用放在对前面,后面是基本类型.</div></pre></td></tr></table></figure></p>
<p>////Fields order: oops, longs/doubles, ints, shorts/chars, bytes, padded fields</p>
<hr>
<h2 id="oop-1"><a href="#oop-1" class="headerlink" title="|   oop 1       |"></a>|   oop 1       |</h2><h2 id="oop-…"><a href="#oop-…" class="headerlink" title="|   oop …     |"></a>|   oop …     |</h2><h2 id="oop-n"><a href="#oop-n" class="headerlink" title="|   oop n       |"></a>|   oop n       |</h2><h2 id="basic-type"><a href="#basic-type" class="headerlink" title="|   basic type  |"></a>|   basic type  |</h2><h2 id="padding"><a href="#padding" class="headerlink" title="|   padding     |"></a>|   padding     |</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">首先,内存中排列的是对象引用,由于使用了压缩指针,每一个需要占用4个字节空间,long和double占用8个字节,int占用4个字节,short和char占用2个字节,byte占用1个字节.</div><div class="line">第二种.对象引用在最后,前面是基本类型</div></pre></td></tr></table></figure>
<h2 id="Fields-order-longs-doubles-ints-shorts-chars-bytes-oops-padded-fields"><a href="#Fields-order-longs-doubles-ints-shorts-chars-bytes-oops-padded-fields" class="headerlink" title="// Fields order: longs/doubles, ints, shorts/chars, bytes, oops, padded fields"></a>// Fields order: longs/doubles, ints, shorts/chars, bytes, oops, padded fields</h2><h2 id="oop-1-1"><a href="#oop-1-1" class="headerlink" title="|   oop 1       |"></a>|   oop 1       |</h2><h2 id="oop-…-1"><a href="#oop-…-1" class="headerlink" title="|   oop …     |"></a>|   oop …     |</h2><h2 id="oop-n-1"><a href="#oop-n-1" class="headerlink" title="|   oop n       |"></a>|   oop n       |</h2><h2 id="basic-type-1"><a href="#basic-type-1" class="headerlink" title="|   basic type  |"></a>|   basic type  |</h2><h2 id="padding-1"><a href="#padding-1" class="headerlink" title="|   padding     |"></a>|   padding     |</h2><p>com.corner.base.jvm.bytecode.TestBytecode: field layout<br>  @ 12 — instance fields start —<br>  @ 44 “a” Ljava.lang.String;<br>  @ 36 “e” S<br>  @ 38 “f” C<br>  @ 40 “h” B<br>  @ 41 “k” B<br>  @ 16 “c” J<br>  @ 24 “d” D<br>  @ 12 “b” I<br>  @ 32 “j” I<br>  @ 48 — instance fields end —<br>  @ 48 — instance ends —<br>  @104 — static fields start —<br>  @104 — static fields end —<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">首先,如果按照我们所说的,基本类型按照longs/doubles, ints, shorts/chars, bytes排列内存布局很明显不对,这是因为JVM为了充分利用内存,8个字节的long和double会做内存对齐,这样如果先存储long和double会留4个字节的空洞,JVM会安排其他的域填充到这个序列中,这里选择了占用4个字节b成员,后面才是按照布局二产生的内存布局.另外为了保证对齐,虚拟机会在每个对象做内存对齐.作为填充.从这个例子中,我们可以知道这个对象在内存中大小为48字节.8字节对齐.</div><div class="line"></div><div class="line">内存布局最基本的是以上两种情况,还有一种就不说了.下面,JVM会对对象区和头部区做归零动作.做完所有的步骤,基本完成了一个对象的内存分配过程.</div><div class="line"></div><div class="line">我们稍微总结一下,内存分配主要考虑管理组织和实际使用的空间,尽量将使用率最大化,压缩管理所使用的空间,尽量将分配的对象保持内存对齐,让其对高速缓存是友好的代码,这些知识在我们编写Java程序已经被系统程序员隐藏了,了解了这些可以让我们更加了解系统的运行过程,写出更加符合JVM的程序.一个对象分配的时候静态区不包含在对象中,所有成员的位置都是Klass确定的.高级程序员对资源的使用是很抠门的.</div><div class="line"></div><div class="line">至此,一个new指令已经完成,返回的指针保存在rax寄存器中,这个寄存器指向了刚刚分配的内存对象.将此指针压入操作数栈中.</div><div class="line"></div><div class="line">### dup ###</div><div class="line">dup指令赋值当前操作数栈的值,并且压入操作数栈,操作效果如下:</div></pre></td></tr></table></figure></p>
<p>value -&gt;</p>
<p>value,value -&gt;<br>```</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/03/07/jvm/jvm_object_init_call/" class="archive-article-date">
  	<time datetime="2017-03-07T08:00:31.341Z" itemprop="datePublished"><i class="icon-clock"></i>2017-03-07</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-jvm/jvm_memory_order" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在多核心计算机中保持顺序是很复杂的一件事情,特别是对共享对象的访问,在Java中提供了多种机制的实现,让处理器能够看到一个一致的顺序.我们在此讨论怎么提供一个高效的同步原语.</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>计算机为了高效的运行,通常允许处理器看到的memory order和我们代码中表现的不一致,如<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">--thread1</div><div class="line">[store n1]</div><div class="line">[load n2]</div><div class="line">[test n2 and clear n1]</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">[store n2]</div><div class="line"></div><div class="line">--thread2</div><div class="line">[store n2]</div><div class="line">[load n1]</div><div class="line">[test n1 and clean n2]</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">[store n1]</div></pre></td></tr></table></figure></p>
<p>由于处理器的memory oder的不一致,导致这段程序在多处理器中是不对的.这个会导致访问共享区的不一致,这里需要程序员做一些特殊的处理.<br>为了验证这个场景,我们来看一个例子.</p>
<h2 id="单处理器上的例子"><a href="#单处理器上的例子" class="headerlink" title="单处理器上的例子"></a>单处理器上的例子</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execinfo.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> FLAG_STATE &#123;</div><div class="line">	<span class="keyword">volatile</span> <span class="keyword">int</span> flag;</div><div class="line"></div><div class="line">	<span class="keyword">char</span> dummy[<span class="number">120</span>]; <span class="comment">// 缓存线对齐,避免false sharing.</span></div><div class="line">&#125; g[<span class="number">2</span>];</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> true 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> false 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FENCE __asm__ volatile (<span class="meta-string">"mfence"</span> : : : <span class="meta-string">"memory"</span>);</span></div><div class="line"></div><div class="line"><span class="comment">//volatile</span></div><div class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> c = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">volatile</span> <span class="keyword">char</span> lock_word = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">	c++;</div><div class="line">	c--;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (c != <span class="number">0</span>)</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"get fail %d\n"</span>, c);</div><div class="line"></div><div class="line">	FENCE;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> turn = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_lock</span><span class="params">(<span class="keyword">int</span> tid)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> other = <span class="number">1</span> - tid;</div><div class="line"></div><div class="line">	g[tid].flag = <span class="literal">true</span>; <span class="comment">// I want in the CS.</span></div><div class="line"></div><div class="line">	<span class="keyword">while</span> (<span class="literal">true</span> == g[other].flag) &#123;</div><div class="line">		<span class="comment">//</span></div><div class="line">		<span class="comment">// The other guy is in the CS or wants in.</span></div><div class="line">		<span class="comment">//</span></div><div class="line">		<span class="keyword">if</span> (turn != tid) &#123;</div><div class="line">			<span class="comment">// he said he wants it, but hasn't given me my turn yet.</span></div><div class="line">			<span class="comment">//</span></div><div class="line">			<span class="comment">// let him have a chance.</span></div><div class="line">			<span class="comment">//</span></div><div class="line">			g[tid].flag = <span class="literal">false</span>;</div><div class="line"></div><div class="line">			<span class="comment">// wait till he gives me my turn</span></div><div class="line">			<span class="keyword">while</span> (turn != tid) &#123;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">// he's about to give up his turn or has, so I can say I want it again.</span></div><div class="line">			<span class="comment">//</span></div><div class="line">			<span class="comment">// I'll now spin on his flag changing (though I could miss it if</span></div><div class="line">			<span class="comment">// unlucky and have to start all over if he tries again fast).</span></div><div class="line">			<span class="comment">//</span></div><div class="line">			g[tid].flag = <span class="literal">true</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_unlock</span><span class="params">(<span class="keyword">int</span> tid)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> other = <span class="number">1</span> - tid;</div><div class="line"></div><div class="line">	turn = other;</div><div class="line"></div><div class="line">	g[tid].flag = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">run1</span><span class="params">(<span class="keyword">int</span> tid)</span> </span>&#123;</div><div class="line">	my_lock(tid);</div><div class="line">	<span class="comment">//...</span></div><div class="line">	doSomething();</div><div class="line">	my_unlock(tid);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread1</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> tid = (<span class="keyword">int</span>) ptr;</div><div class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</div><div class="line">		run1(tid);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">run2</span><span class="params">(<span class="keyword">int</span> tid)</span> </span>&#123;</div><div class="line">	my_lock(tid);</div><div class="line">	<span class="comment">//...</span></div><div class="line">	doSomething();</div><div class="line"></div><div class="line">	my_unlock(tid);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread2</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> tid = (<span class="keyword">int</span>) ptr;</div><div class="line"></div><div class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</div><div class="line">		run2(tid);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">pthread_t</span> thr1, thr2;</div><div class="line">	<span class="keyword">int</span> t1 = <span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> t2 = <span class="number">1</span>;</div><div class="line"></div><div class="line">	pthread_create(&amp;thr1, <span class="literal">NULL</span>, thread1, (<span class="keyword">void</span> *) t1);</div><div class="line"></div><div class="line">	pthread_create(&amp;thr2, <span class="literal">NULL</span>, thread2, (<span class="keyword">void</span> *) t2);</div><div class="line"></div><div class="line">	pthread_join(thr1, <span class="literal">NULL</span>);</div><div class="line">	pthread_join(thr2, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们通过一下命令运行:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">taskset -c 1 ./test_c</div></pre></td></tr></table></figure></p>
<p>这段程序没有任何问题,也不会打印出”get fail”,这是因为在单处理器上这种memory order是一致的,处理器看到的内存内容是一致的.</p>
<h3 id="多处理器的例子"><a href="#多处理器的例子" class="headerlink" title="多处理器的例子"></a>多处理器的例子</h3><p>我们运行一样的例子<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">./test_c</div></pre></td></tr></table></figure></p>
<p>这段程序此时就会打印出”get fail”,说明我们通过此种无锁的保证共享区的代码失效了.这里就是我们描述的memory order导致的共享区被破坏的情况,在intel文档中说明,由于store buffer的存在,处理器为了性能允许store可以被后续的load乱序执行,导致不同处理器看到的内存顺序和我们的代码是不一致的.那我们怎么解决这个问题呢?</p>
<h3 id="通过内存屏障"><a href="#通过内存屏障" class="headerlink" title="通过内存屏障"></a>通过内存屏障</h3><p>内存屏障是处理器为了解决memory order所带来问题的一种解决方案,允许处理器直接刷新store buffer,这样不同处理器看到的memory order是一致的了.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">--thread1</div><div class="line">[store n1]</div><div class="line">[memory barrier]</div><div class="line">[load n2]</div><div class="line">[test n2 and clear n1]</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">[store n2]</div><div class="line"></div><div class="line">--thread2</div><div class="line">[store n2]</div><div class="line">[memory barrier]</div><div class="line">[load n1]</div><div class="line">[test n1 and clean n2]</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">[store n1]</div></pre></td></tr></table></figure>
<p>这样我们增加了内存屏障后,不管thread1和thread2得到变量的值都是最新的了.从而符合我们所需要的逻辑<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;pthread.h&gt;</div><div class="line">#include &lt;execinfo.h&gt;</div><div class="line">#include &lt;signal.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line"></div><div class="line">struct FLAG_STATE &#123;</div><div class="line">	volatile int flag;</div><div class="line"></div><div class="line">	char dummy[120]; // 缓存线对齐,避免false sharing.</div><div class="line">&#125; g[2];</div><div class="line"></div><div class="line">#define true 1</div><div class="line">#define false 0</div><div class="line">#define FENCE __asm__ volatile (&quot;mfence&quot; : : : &quot;memory&quot;);</div><div class="line"></div><div class="line">//volatile</div><div class="line">volatile int c = 0;</div><div class="line"></div><div class="line">volatile char lock_word = 0;</div><div class="line"></div><div class="line">void doSomething() &#123;</div><div class="line">	c++;</div><div class="line">	c--;</div><div class="line"></div><div class="line">	if (c != 0)</div><div class="line">		printf(&quot;get fail %d\n&quot;, c);</div><div class="line"></div><div class="line">	FENCE;</div><div class="line">&#125;</div><div class="line"></div><div class="line">volatile int turn = 0;</div><div class="line"></div><div class="line">void my_lock(int tid) &#123;</div><div class="line">	int other = 1 - tid;</div><div class="line"></div><div class="line">	g[tid].flag = true; // I want in the CS.</div><div class="line"></div><div class="line">	FENCE;</div><div class="line"></div><div class="line">	while (true == g[other].flag) &#123;</div><div class="line">		//</div><div class="line">		// The other guy is in the CS or wants in.</div><div class="line">		//</div><div class="line">		if (turn != tid) &#123;</div><div class="line">			// he said he wants it, but hasn&apos;t given me my turn yet.</div><div class="line">			//</div><div class="line">			// let him have a chance.</div><div class="line">			//</div><div class="line">			g[tid].flag = false;</div><div class="line"></div><div class="line">			// wait till he gives me my turn</div><div class="line">			while (turn != tid) &#123;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			// he&apos;s about to give up his turn or has, so I can say I want it again.</div><div class="line">			//</div><div class="line">			// I&apos;ll now spin on his flag changing (though I could miss it if</div><div class="line">			// unlucky and have to start all over if he tries again fast).</div><div class="line">			//</div><div class="line">			g[tid].flag = true;</div><div class="line">			FENCE;   //此处同样需要一个内存屏障</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void my_unlock(int tid) &#123;</div><div class="line">	int other = 1 - tid;</div><div class="line"></div><div class="line">	turn = other;</div><div class="line"></div><div class="line">	g[tid].flag = false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void run1(int tid) &#123;</div><div class="line">	my_lock(tid);</div><div class="line">	//...</div><div class="line">	doSomething();</div><div class="line">	my_unlock(tid);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void *thread1(void *ptr) &#123;</div><div class="line">	int tid = (int) ptr;</div><div class="line">	while (1)</div><div class="line">		run1(tid);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void run2(int tid) &#123;</div><div class="line">	my_lock(tid);</div><div class="line">	//...</div><div class="line">	doSomething();</div><div class="line"></div><div class="line">	my_unlock(tid);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void *thread2(void *ptr) &#123;</div><div class="line">	int tid = (int) ptr;</div><div class="line"></div><div class="line">	while (1)</div><div class="line">		run2(tid);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(void) &#123;</div><div class="line"></div><div class="line">	pthread_t thr1, thr2;</div><div class="line">	int t1 = 0;</div><div class="line">	int t2 = 1;</div><div class="line"></div><div class="line">	pthread_create(&amp;thr1, NULL, thread1, (void *) t1);</div><div class="line"></div><div class="line">	pthread_create(&amp;thr2, NULL, thread2, (void *) t2);</div><div class="line"></div><div class="line">	pthread_join(thr1, NULL);</div><div class="line">	pthread_join(thr2, NULL);</div><div class="line"></div><div class="line">	return EXIT_SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上是一个典型的dekker算法,dekker算法在单处理器中处理的很好,但是在多处理器中,由于memory order的不一致导致此算法会出问题,从而导致无法正常进入临界区,我在测试的过程中发现网络上只是对进入的时候做了内存屏障,但此时同样会存在问题,需要在内循环中同样介入内存屏障.<br>其中FENCE可以为:</p>
<ol>
<li><strong>asm</strong> volatile (“mfence” : : : “memory”);</li>
<li><strong>asm</strong> volatile (“lock; addl $0,0(%%rsp)” : : : “cc”, “memory”);</li>
</ol>
<p>建议使用第二种,第二种使用lock前缀,比第一种效率要高.</p>
<h2 id="非对称内存屏障"><a href="#非对称内存屏障" class="headerlink" title="非对称内存屏障"></a>非对称内存屏障</h2><p>通过上面的介绍,我们知道内存屏障可以用在临界区中,那我们是否还可以增强此种使用的性能呢?我们下面介绍另外一种思想,其主要思想如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">fast thread                     slow thread</div><div class="line"></div><div class="line">store n1                        store n2</div><div class="line">load  n2                        fence</div><div class="line">                                mproctect page RO</div></pre></td></tr></table></figure></p>
<p>由于thread1执行的指令比较少,此时成为fast thread,thread2执行的比较多,所以叫做slow thread,此时分以下几种情况:</p>
<ol>
<li>fast thread在mprotect之前执行,slow thread执行mmprotect后,看到的n1内存是最新的,mprotect将执行页修改为只读,系统会自动冲刷缓存,将fast thread的缓存冲刷会内存,系统调用返回后,slow thread将得到n1的最新状态</li>
<li>fast thread在mprotect之后执行,由于mproctect将此页修改为只读,写此内存页,会引起中断,默认中断也会刷新处理器缓存到内存,fast thread将得到最新的n2状态,slow thread也会得到n1的最新状态.</li>
<li>slow thread 执行mprotect后,会将之前所有写此页的缓存全部冲刷进内存.</li>
</ol>
<p>通过以上的方式,我们将会得到一个更加优化的方案:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">n * fastthread + slow thread(fence+mprotect) &lt; n * slow thread(fence)</div></pre></td></tr></table></figure></p>
<p>我们在JVM中safepoint的代码中,经常看到以下场景,利用的就是此种知识;<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// Flush all thread states to memory</div><div class="line">if (!UseMembar) &#123;</div><div class="line">  os::serialize_thread_states();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Serialize all thread state variables</div><div class="line">void os::serialize_thread_states() &#123;</div><div class="line">  // On some platforms such as Solaris &amp; Linux, the time duration of the page</div><div class="line">  // permission restoration is observed to be much longer than expected  due to</div><div class="line">  // scheduler starvation problem etc. To avoid the long synchronization</div><div class="line">  // time and expensive page trap spinning, &apos;SerializePageLock&apos; is used to block</div><div class="line">  // the mutator thread if such case is encountered. See bug 6546278 for details.</div><div class="line">  Thread::muxAcquire(&amp;SerializePageLock, &quot;serialize_thread_states&quot;);</div><div class="line">  os::protect_memory((char *)os::get_memory_serialize_page(),</div><div class="line">                     os::vm_page_size(), MEM_PROT_READ);</div><div class="line">  os::protect_memory((char *)os::get_memory_serialize_page(),</div><div class="line">                     os::vm_page_size(), MEM_PROT_RW);</div><div class="line">  Thread::muxRelease(&amp;SerializePageLock);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//Java Thread状态转换</div><div class="line">    // Make sure new state is seen by VM thread</div><div class="line">    if (os::is_MP()) &#123;</div><div class="line">      if (UseMembar) &#123;</div><div class="line">        // Force a fence between the write above and read below</div><div class="line">        OrderAccess::fence();</div><div class="line">      &#125; else &#123;</div><div class="line">        // store to serialize page so VM thread can do pseudo remote membar</div><div class="line">        os::write_memory_serialize_page(thread);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  static inline void write_memory_serialize_page(JavaThread *thread) &#123;</div><div class="line">    uintptr_t page_offset = ((uintptr_t)thread &gt;&gt;</div><div class="line">                            get_serialize_page_shift_count()) &amp;</div><div class="line">                            get_serialize_page_mask();</div><div class="line">    *(volatile int32_t *)((uintptr_t)_mem_serialize_page+page_offset) = 1;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>首先,VMThread会把serialize page通过系统调用修改为只读,Java线程在状态转换的时候会调用os::write_memory_serialize_page写serialize page,此时会把之前所有写此页的缓存写入内存,VMThread后续将会得到最新的所有线程状态.</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/03/06/jvm/jvm_memory_order/" class="archive-article-date">
  	<time datetime="2017-03-06T08:44:05.619Z" itemprop="datePublished"><i class="icon-clock"></i>2017-03-06</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-eagle/eagle-IncompatibleClassChangeError" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/07/eagle/eagle-IncompatibleClassChangeError/">log4j和log4j-over-slf4j-1.6.6.jar不兼容问题排查</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>部署eagle过程中，提交storm任务发现出现java.lang.IncompatibleClassChangeError错误，以下是问题原因和排查过程,错误栈如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">java.util.concurrent.ExecutionException: java.lang.IncompatibleClassChangeError: Implementing class</div><div class="line">        at java.util.concurrent.FutureTask.report(FutureTask.java:122) ~[na:1.8.0_101]</div><div class="line">        at java.util.concurrent.FutureTask.get(FutureTask.java:206) ~[na:1.8.0_101]</div><div class="line">        at org.apache.eagle.alert.engine.publisher.email.AlertEmailGenerator.sendAlertEmail(AlertEmailGenerator.java:89) [stormjar.jar:na]</div><div class="line">        at org.apache.eagle.alert.engine.publisher.email.AlertEmailGenerator.sendAlertEmail(AlertEmailGenerator.java:55) [stormjar.jar:na]</div><div class="line">        at org.apache.eagle.alert.engine.publisher.impl.AlertEmailPublisher.onAlert(AlertEmailPublisher.java:128) [stormjar.jar:na]</div><div class="line">        at org.apache.eagle.alert.engine.publisher.impl.AlertPublisherImpl.notifyAlert(AlertPublisherImpl.java:88) [stormjar.jar:na]</div><div class="line">        at org.apache.eagle.alert.engine.publisher.impl.AlertPublisherImpl.nextEvent(AlertPublisherImpl.java:70) [stormjar.jar:na]</div><div class="line">        at org.apache.eagle.alert.engine.runner.AlertPublisherBolt.execute(AlertPublisherBolt.java:92) [stormjar.jar:na]</div><div class="line">        at backtype.storm.daemon.executor$fn__3441$tuple_action_fn__3443.invoke(executor.clj:633) [storm-core-0.9.3.jar:0.9.3]</div><div class="line">        at backtype.storm.daemon.executor$mk_task_receiver$fn__3364.invoke(executor.clj:401) [storm-core-0.9.3.jar:0.9.3]</div><div class="line">        at backtype.storm.disruptor$clojure_handler$reify__1447.onEvent(disruptor.clj:58) [storm-core-0.9.3.jar:0.9.3]</div><div class="line">        at backtype.storm.utils.DisruptorQueue.consumeBatchToCursor(DisruptorQueue.java:125) [storm-core-0.9.3.jar:0.9.3]</div><div class="line">        at backtype.storm.utils.DisruptorQueue.consumeBatchWhenAvailable(DisruptorQueue.java:99) [storm-core-0.9.3.jar:0.9.3]</div><div class="line">        at backtype.storm.disruptor$consume_batch_when_available.invoke(disruptor.clj:80) [storm-core-0.9.3.jar:0.9.3]</div><div class="line">        at backtype.storm.daemon.executor$fn__3441$fn__3453$fn__3500.invoke(executor.clj:748) [storm-core-0.9.3.jar:0.9.3]</div><div class="line">        at backtype.storm.util$async_loop$fn__464.invoke(util.clj:463) [storm-core-0.9.3.jar:0.9.3]</div><div class="line">        at clojure.lang.AFn.run(AFn.java:24) [clojure-1.5.1.jar:na]</div><div class="line">        at java.lang.Thread.run(Thread.java:745) [na:1.8.0_101]</div><div class="line">Caused by: java.lang.IncompatibleClassChangeError: Implementing class</div><div class="line">        at java.lang.ClassLoader.defineClass1(Native Method) ~[na:1.8.0_101]</div><div class="line">        at java.lang.ClassLoader.defineClass(ClassLoader.java:763) ~[na:1.8.0_101]</div><div class="line">        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) ~[na:1.8.0_101]</div><div class="line">        at java.net.URLClassLoader.defineClass(URLClassLoader.java:467) ~[na:1.8.0_101]</div><div class="line">        at java.net.URLClassLoader.access$100(URLClassLoader.java:73) ~[na:1.8.0_101]</div><div class="line">        at java.net.URLClassLoader$1.run(URLClassLoader.java:368) ~[na:1.8.0_101]</div><div class="line">        at java.net.URLClassLoader$1.run(URLClassLoader.java:362) ~[na:1.8.0_101]</div><div class="line">        at java.security.AccessController.doPrivileged(Native Method) ~[na:1.8.0_101]</div><div class="line">        at java.net.URLClassLoader.findClass(URLClassLoader.java:361) ~[na:1.8.0_101]</div><div class="line">        at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[na:1.8.0_101]</div><div class="line">        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) ~[na:1.8.0_101]</div><div class="line">        at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_101]</div><div class="line">        at org.apache.velocity.runtime.log.Log4JLogChute.initAppender(Log4JLogChute.java:118) ~[stormjar.jar:na]</div><div class="line">        at org.apache.velocity.runtime.log.Log4JLogChute.init(Log4JLogChute.java:85) ~[stormjar.jar:na]</div><div class="line">        at org.apache.velocity.runtime.log.LogManager.createLogChute(LogManager.java:157) ~[stormjar.jar:na]</div><div class="line">        at org.apache.velocity.runtime.log.LogManager.updateLog(LogManager.java:269) ~[stormjar.jar:na]</div><div class="line">        at org.apache.velocity.runtime.RuntimeInstance.initializeLog(RuntimeInstance.java:871) ~[stormjar.jar:na]</div><div class="line">        at org.apache.velocity.runtime.RuntimeInstance.init(RuntimeInstance.java:262) ~[stormjar.jar:na]</div><div class="line">        at org.apache.velocity.app.VelocityEngine.init(VelocityEngine.java:93) ~[stormjar.jar:na]</div><div class="line">        at org.apache.eagle.alert.engine.publisher.email.EagleMailClient.&lt;init&gt;(EagleMailClient.java:57) ~[stormjar.jar:na]</div><div class="line">        at org.apache.eagle.alert.engine.publisher.email.AlertEmailSender.run(AlertEmailSender.java:87) ~[stormjar.jar:na]</div><div class="line">        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[na:1.8.0_101]</div><div class="line">        at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[na:1.8.0_101]</div><div class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) ~[na:1.8.0_101]</div><div class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) ~[na:1.8.0_101]</div><div class="line">        ... 1 common frames omitted</div></pre></td></tr></table></figure></p>
<h2 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h2><ol>
<li>java命令行选项告诉加载顺序<br>Java运行时提供了一个verbose选项和TraceClassLoadingPreorder，通过传入storm的work任务提交两个命令选项“-XX:+TraceClassLoadingPreorder -verbose”获取加载类过程，由于类加载过程是迭代过程，如加载类发现父类和父接口没有加载，则优先加载父类和父接口，依次类推。verbose选项可以告诉我们那个类加载过了，没办法判断先加载的类。通过使用TraceClassLoadingPreorder选项可以获取加载的顺序。</li>
<li>什么时候报Caused by: java.lang.IncompatibleClassChangeError: Implementing class<br>虚拟机加载类的时候在发现有继承接口信息的时候会验证类规范，如果发现继承的实体不是接口，则报出此Error。</li>
</ol>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>通过概述中的栈信息，我们主要看<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">at org.apache.velocity.runtime.log.Log4JLogChute.initAppender(Log4JLogChute.java:118) ~[stormjar.jar:na]</div></pre></td></tr></table></figure></p>
<p>此行主要由于在调用<strong>Log4JLogChute.initAppender</strong>方法的时候错误，在此类118行通过反编译代码如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">this.appender = new RollingFileAppender(layout, file, true);</div></pre></td></tr></table></figure></p>
<p>对应字节码<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">11 new #41 &lt;org/apache/log4j/RollingFileAppender&gt;</div></pre></td></tr></table></figure></p>
<p>我们可以知道在加载RollingFileAppender过程中出现了此类错误，怀疑加载的类不一致导致此错误。通过执行对应程序加上<strong>-XX:+TraceClassLoadingPreorder -verbose</strong>,查找RollingFileAppender类。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[Loading org.apache.log4j.RollingFileAppender from file:/opt/apache-storm-0.9.3/storm-local/supervisor/stormdist/ALERT_UNIT_TOPOLOGY_</div><div class="line">APP_SANDBOX-1-1486386532/stormjar.jar]</div><div class="line">[Loading org.apache.log4j.FileAppender from file:/opt/apache-storm-0.9.3/storm-local/supervisor/stormdist/ALERT_UNIT_TOPOLOGY_APP_SAN</div><div class="line">DBOX-1-1486386532/stormjar.jar]</div><div class="line">[Loading org.apache.log4j.WriterAppender from file:/opt/apache-storm-0.9.3/storm-local/supervisor/stormdist/ALERT_UNIT_TOPOLOGY_APP_SANDBOX-1-1486386532/stormjar.jar]</div><div class="line">[Loading org.apache.log4j.AppenderSkeleton from file:/opt/apache-storm-0.9.3/storm-local/supervisor/stormdist/ALERT_UNIT_TOPOLOGY_APP_SANDBOX-1-1486386532/stormjar.jar]</div><div class="line">[Loaded org.apache.log4j.AppenderSkeleton from file:/opt/apache-storm-0.9.3/storm-local/supervisor/stormdist/ALERT_UNIT_TOPOLOGY_APP_SANDBOX-1-1486386532/stormjar.jar]</div><div class="line">[Loaded org.apache.log4j.WriterAppender from file:/opt/apache-storm-0.9.3/storm-local/supervisor/stormdist/ALERT_UNIT_TOPOLOGY_APP_SANDBOX-1-1486386532/stormjar.jar]</div><div class="line">[Loaded org.apache.log4j.FileAppender from file:/opt/apache-storm-0.9.3/storm-local/supervisor/stormdist/ALERT_UNIT_TOPOLOGY_APP_SANDBOX-1-1486386532/stormjar.jar]</div><div class="line">[Loaded org.apache.log4j.RollingFileAppender from file:/opt/apache-storm-0.9.3/storm-local/supervisor/stormdist/ALERT_UNIT_TOPOLOGY_APP_SANDBOX-1-1486386532/stormjar.jar]</div><div class="line">[Loading org.apache.log4j.spi.ErrorHandler from file:/opt/apache-storm-0.9.3/lib/log4j-over-slf4j-1.6.6.jar]</div><div class="line">[Loaded org.apache.log4j.spi.ErrorHandler from file:/opt/apache-storm-0.9.3/lib/log4j-over-slf4j-1.6.6.jar]</div><div class="line">[Loading com.google.common.collect.Iterators from file:/opt/apache-storm-0.9.3/storm-local/supervisor/stormdist/ALERT_UNIT_TOPOLOGY_A</div><div class="line">PP_SANDBOX-1-1486386532/stormjar.jar]</div><div class="line">[Loading org.apache.log4j.helpers.OnlyOnceErrorHandler from file:/opt/apache-storm-0.9.3/storm-local/supervisor/stormdist/ALERT_UNIT_</div><div class="line">TOPOLOGY_APP_SANDBOX-1-1486386532/stormjar.jar]</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">[Loading org.apache.log4j.helpers.OnlyOnceErrorHandler from file:/opt/apache-storm-0.9.3/storm-local/supervisor/stormdist/ALERT_UNIT_TOPOLOGY_APP_SANDBOX-1-1486386532/stormjar.jar]</div><div class="line">...</div><div class="line">[Loading org.apache.log4j.helpers.OnlyOnceErrorHandler from file:/opt/apache-storm-0.9.3/storm-local/supervisor/stormdist/ALERT_UNIT_TOPOLOGY_APP_SANDBOX-1-1486386532/stormjar.jar]</div></pre></td></tr></table></figure></p>
<p>从加载的顺序可以看到如我们所说的一致，按需加载。需要重点关注OnlyOnceErrorHandler，我们发现虚拟机一致在加载此类，一致没有成功，假设可能其父接口加载导致无法加载此类。反编译此类为<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class OnlyOnceErrorHandler</div><div class="line">  implements ErrorHandler</div><div class="line">&#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到ErrorHandler是一个接口<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[Loading org.apache.log4j.spi.ErrorHandler from file:/opt/apache-storm-0.9.3/lib/log4j-over-slf4j-1.6.6.jar]</div><div class="line">[Loaded org.apache.log4j.spi.ErrorHandler from file:/opt/apache-storm-0.9.3/lib/log4j-over-slf4j-1.6.6.jar]</div></pre></td></tr></table></figure></p>
<p>我们看到这个关键点，反编译对应jar的此类<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class ErrorHandler &#123;&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看出加载的此类是一个具体类，而不是接口，所以虚拟机认为此类违反了java语言规范。所以出错误。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>提交到strom的包打的log4j和log4j-over-slf4j-1.6.6.jar冲突。同样log4j和log4j-over-slf4j-1.6.6.jar也有冲突，剔除storm中的log4j-over-slf4j-1.6.6.jar就好了。</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>在storm提交任务给supervisor执行的时候，会启动对应的worker执行，通过worker.childopts: “-Xmx768m -verbose”发现是不行了，虚拟机会一致挂住。<br>我们可以通过另外一种方法，找到对应的启动命令，比如<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/opt/jdk1.8.0_101/bin/java -server -Xmx768m -verbose  -XX:+TraceClassLoadingPreorder -Djava.library.path=storm-local/supervisor/stormdist/ALERT_UNIT_TOPOLOGY_APP_SANDBOX-1-1486386532/resources/Linux-amd64:storm-local/supervisor/stormdist/ALERT_UNIT_TOPOLOGY_APP_SANDBOX-1-1486386532/resources:/usr/local/lib:/opt/local/lib:/usr/lib -Dlogfile.name=worker-6701.log -Dstorm.home=/opt/apache-storm-0.9.3 -Dstorm.conf.file= -Dstorm.options= -Dstorm.log.dir=/opt/apache-storm-0.9.3/logs -Dlogback.configurationFile=/opt/apache-storm-0.9.3/logback/cluster.xml -Dstorm.id=ALERT_UNIT_TOPOLOGY_APP_SANDBOX-1-1486386532 -Dworker.id=f9460422-b3e3-49f9-97d3-a5f63b949902 -Dworker.port=6701 -cp /opt/apache-storm-0.9.3/lib/json-simple-1.1.jar:/opt/apache-storm-0.9.3/lib/ring-devel-0.3.11.jar:/opt/apache-storm-0.9.3/lib/tools.logging-0.2.3.jar:/opt/apache-storm-0.9.3/lib/hiccup-0.3.6.jar:/opt/apache-storm-0.9.3/lib/commons-codec-1.6.jar:/opt/apache-storm-0.9.3/lib/commons-logging-1.1.3.jar:/opt/apache-storm-0.9.3/lib/reflectasm-1.07-shaded.jar:/opt/apache-storm-0.9.3/lib/compojure-1.1.3.jar:/opt/apache-storm-0.9.3/lib/clj-time-0.4.1.jar:/opt/apache-storm-0.9.3/lib/jersey-core-1.19.1.jar:/opt/apache-storm-0.9.3/lib/commons-lang-2.5.jar:/opt/apache-storm-0.9.3/lib/servlet-api-2.5.jar:/opt/apache-storm-0.9.3/lib/ring-jetty-adapter-0.3.11.jar:/opt/apache-storm-0.9.3/lib/jersey-client-1.19.1.jar:/opt/apache-storm-0.9.3/lib/slf4j-api-1.7.5.jar:/opt/apache-storm-0.9.3/lib/kryo-2.21.jar:/opt/apache-storm-0.9.3/lib/core.incubator-0.1.0.jar:/opt/apache-storm-0.9.3/lib/log4j-over-slf4j-1.6.6.jar:/opt/apache-storm-0.9.3/lib/jgrapht-core-0.9.0.jar:/opt/apache-storm-0.9.3/lib/clout-1.0.1.jar:/opt/apache-storm-0.9.3/lib/ring-servlet-0.3.11.jar:/opt/apache-storm-0.9.3/lib/carbonite-1.4.0.jar:/opt/apache-storm-0.9.3/lib/jetty-6.1.26.jar:/opt/apache-storm-0.9.3/lib/commons-io-2.4.jar:/opt/apache-storm-0.9.3/lib/tools.cli-0.2.4.jar:/opt/apache-storm-0.9.3/lib/logback-classic-1.0.13.jar:/opt/apache-storm-0.9.3/lib/disruptor-2.10.1.jar:/opt/apache-storm-0.9.3/lib/math.numeric-tower-0.0.1.jar:/opt/apache-storm-0.9.3/lib/minlog-1.2.jar:/opt/apache-storm-0.9.3/lib/storm-core-0.9.3.jar:/opt/apache-storm-0.9.3/lib/ring-core-1.1.5.jar:/opt/apache-storm-0.9.3/lib/clojure-1.5.1.jar:/opt/apache-storm-0.9.3/lib/chill-java-0.3.5.jar:/opt/apache-storm-0.9.3/lib/commons-fileupload-1.2.1.jar:/opt/apache-storm-0.9.3/lib/jetty-util-6.1.26.jar:/opt/apache-storm-0.9.3/lib/objenesis-1.2.jar:/opt/apache-storm-0.9.3/lib/commons-exec-1.1.jar:/opt/apache-storm-0.9.3/lib/tools.macro-0.1.0.jar:/opt/apache-storm-0.9.3/lib/logback-core-1.0.13.jar:/opt/apache-storm-0.9.3/lib/asm-4.0.jar:/opt/apache-storm-0.9.3/lib/clj-stacktrace-0.2.2.jar:/opt/apache-storm-0.9.3/lib/jline-2.11.jar:/opt/apache-storm-0.9.3/lib/joda-time-2.0.jar:/opt/apache-storm-0.9.3/lib/snakeyaml-1.11.jar:/opt/apache-storm-0.9.3/conf:storm-local/supervisor/stormdist/ALERT_UNIT_TOPOLOGY_APP_SANDBOX-1-1486386532/stormjar.jar backtype.storm.daemon.worker ALERT_UNIT_TOPOLOGY_APP_SANDBOX-1-1486386532 20329ac2-9c6f-42d3-9a6e-f9e66fe49cc1 6701 f9460422-b3e3-49f9-97d3-a5f63b949902</div></pre></td></tr></table></figure></p>
<p>在启动此命令前需要在storm-local创建<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mkdir -p storm-local/workers/f9460422-b3e3-49f9-97d3-a5f63b949902/pids</div></pre></td></tr></table></figure></p>
<p>这样此worker一样可以运行，这个tips在storm-0.9.3测试可行。就可以获取加载类的反馈信息。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/02/07/eagle/eagle-IncompatibleClassChangeError/" class="archive-article-date">
  	<time datetime="2017-02-07T02:27:43.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-02-07</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hadoop-Eagle-Storm/">Hadoop Eagle Storm</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Hadoop/">Hadoop</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-jvm/新文档" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>虚拟机中类的生命周期有一个阶段叫做重写，主要负责以下事项：</p>
<ul>
<li>建立常量池缓存</li>
<li>注册finalizer</li>
<li>lookupswitch优化</li>
</ul>
<h3 id="注册finalizer"><a href="#注册finalizer" class="headerlink" title="注册finalizer"></a>注册finalizer</h3><p>虚拟机在重写阶段会将Object的<init>方法的返回指令修改，被修改的指令执行注册动作，由于虚拟机中每个类都会调用Object的<init>方法，从而达到所有对象都会执行注册动作。虚拟机会创建一个java.lang.ref.Finalizer。每个对象都会维护一个java.lang.ref.Finalizer类实例。</init></init></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/01/20/jvm/新文档/" class="archive-article-date">
  	<time datetime="2017-01-20T09:37:19.956Z" itemprop="datePublished"><i class="icon-clock"></i>2017-01-20</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-streamsets/sample_db_dcp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/23/streamsets/sample_db_dcp/">研发环境ODS201610分片tf_evt_cps_clr_list表导入DCP平台</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>实现研发环境ODS201610分片tf_evt_cps_clr_list表导入DCP平台<br>
        <p class="article-more-link">
          <a  href="/2016/12/23/streamsets/sample_db_dcp/#more">more >></a>
        </p>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/12/23/streamsets/sample_db_dcp/" class="archive-article-date">
  	<time datetime="2016-12-23T07:47:34.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-12-23</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/streamset/">streamset</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/data-import-export/">data import export</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-linux-invoke-main-plt-got" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/21/linux-invoke-main-plt-got/">Linux 动态链接过程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>文中描述了动态链接的详细过程，基于x86_amd64平台。<br>
        <p class="article-more-link">
          <a  href="/2016/10/21/linux-invoke-main-plt-got/#more">more >></a>
        </p>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/21/linux-invoke-main-plt-got/" class="archive-article-date">
  	<time datetime="2016-10-21T01:03:34.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-21</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 Corner XX
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/"
	}
</script>

<script src="/./main.js"></script>





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/Hadoop-Eagle-Storm/" style="font-size: 10px;">Hadoop Eagle Storm</a> <a href="/tags/Hadoop-Hdfs/" style="font-size: 10px;">Hadoop Hdfs</a> <a href="/tags/Hadoop-Yran/" style="font-size: 10px;">Hadoop Yran</a> <a href="/tags/Hbase/" style="font-size: 16.67px;">Hbase</a> <a href="/tags/Hdfs/" style="font-size: 13.33px;">Hdfs</a> <a href="/tags/JVM/" style="font-size: 20px;">JVM</a> <a href="/tags/Kernel/" style="font-size: 13.33px;">Kernel</a> <a href="/tags/OpenJDK/" style="font-size: 13.33px;">OpenJDK</a> <a href="/tags/Phoenix/" style="font-size: 10px;">Phoenix</a> <a href="/tags/algorithm/" style="font-size: 16.67px;">algorithm</a> <a href="/tags/streamset/" style="font-size: 10px;">streamset</a>
    			</div>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">记录点点滴滴</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>