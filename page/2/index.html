<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Corner XX daily log</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Corner XX daily log">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Corner XX daily log">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Corner XX daily log">
  
    <link rel="alternative" href="/atom.xml" title="Corner XX daily log" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.png">
  
  <script src="/style.js"></script>
</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/img/suolong.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Corner XX</a></h1>
		</hgroup>

		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="#" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/cornerxx" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">Corner XX</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="/img/suolong.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Corner XX</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/cornerxx" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-jvm/string-intern" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/23/jvm/string-intern/">Java String Intern</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>String.intern()在jdk7以后的实现。</p>
<h2 id="String-intern"><a href="#String-intern" class="headerlink" title="String intern"></a>String intern</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> string;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test11</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		<span class="comment">//-----s0-----</span></div><div class="line">		<span class="comment">/**</span></div><div class="line">		 * 不要使用new String("aaaaa")此类;</div><div class="line">		 * 可以使用s01 = "aaaaa";</div><div class="line">		 * 可以节约内存</div><div class="line">		 */</div><div class="line">		<span class="comment">//建立两个对象，"aaaaa"在符号表中，s00指向的对象在堆中</span></div><div class="line">		String s00 = <span class="keyword">new</span> String(<span class="string">"aaaaa"</span>);</div><div class="line">		String s01 = <span class="string">"aaaaa"</span>;</div><div class="line">		<span class="comment">//false,由于s00中建立了两个字符串对象，第一个是"aaaaa"，第二个才是new的,s00指向new的,s00.intern()指向第一個在符号表的对象</span></div><div class="line">		System.out.println(<span class="string">"s00.intern() == s00:"</span>+(s00.intern() == s00));</div><div class="line">		<span class="comment">//true</span></div><div class="line">		System.out.println(<span class="string">"s01.intern() == s01:"</span>+(s01.intern() == s01));</div><div class="line"></div><div class="line">		</div><div class="line">		<span class="comment">//-----s1-----</span></div><div class="line">		<span class="comment">/**</span></div><div class="line">		 * 使用常量拼接会比使用StringBuilder效率更高(编译器可以确定为常量)</div><div class="line">		 * 对于不确定是常量的字符串拼接，还是老老实实的使用StringBuilder</div><div class="line">		 */</div><div class="line">		<span class="comment">//在符号表建立"aaabb"。javac会优化此类方式</span></div><div class="line">		String s10 = <span class="string">"aaa"</span> + <span class="string">"bb"</span>;</div><div class="line">		<span class="keyword">final</span> String s11 =  <span class="string">"aaa"</span>;</div><div class="line">		String s12 = s11 + <span class="string">"bb"</span>;</div><div class="line">		String s13 = <span class="string">"aaa"</span>;</div><div class="line">		String s14 = s13+<span class="string">"bb"</span>;</div><div class="line">		String s15 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>) + <span class="string">"bb"</span>;</div><div class="line">		<span class="comment">//true</span></div><div class="line">		System.out.println(<span class="string">"s10 == s12:"</span>+ (s10 == s12));</div><div class="line">		<span class="comment">//false,由于编译器无法确定为常量,所以不会优化,s14是在堆中新建的字符串，所以和和s10不一样</span></div><div class="line">		System.out.println(<span class="string">"s14 == s10:"</span>+ (s14 == s10));</div><div class="line">		<span class="comment">//false,同上</span></div><div class="line">		System.out.println(<span class="string">"s15 == s10:"</span>+ (s15 == s10));</div><div class="line">		</div><div class="line">		<span class="comment">/**</span></div><div class="line">		 * intern根据不同的jdk版本不一样，下面的结果jdk6和jdk7是不一样的，描述适用于jdk7.</div><div class="line">		 * 合理使用intern,可以减少内存使用</div><div class="line">		 */</div><div class="line">		<span class="comment">//-----s2-----</span></div><div class="line">		String s20 = <span class="keyword">new</span> StringBuilder(<span class="string">"z"</span>).append(<span class="string">".AccessibleObject"</span>).toString(); <span class="comment">//new string object</span></div><div class="line">		String s21 = <span class="keyword">new</span> StringBuilder(<span class="string">"z"</span>).append(<span class="string">".AccessibleObject"</span>).toString(); <span class="comment">//new string object</span></div><div class="line">		String s22 = <span class="keyword">new</span> StringBuilder(<span class="string">"jav"</span>).append(<span class="string">"a.lang.String"</span>).toString();<span class="comment">//old stringtable</span></div><div class="line">		<span class="comment">//true，intern如果字符串表没有这个字符串，则建立字符串表到这个对象的映射,所以这里s20.intern指向的是s20</span></div><div class="line">		System.out.println(<span class="string">"s20.intern() == s20:"</span>+(s20.intern() == s20));</div><div class="line">		<span class="comment">//true，同上</span></div><div class="line">		System.out.println(<span class="string">"s20 == s21.intern():"</span>+(s20 == s21.intern()));</div><div class="line">		<span class="comment">//由于虚拟机已经池化了这个字符串,所以intern指向的是虚拟机的字符串对象，而不是s22</span></div><div class="line">		System.out.println(<span class="string">"a2.intern() == a2:"</span>+(s22.intern() == s22));</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/09/23/jvm/string-intern/" class="archive-article-date">
  	<time datetime="2016-09-23T03:30:40.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-09-23</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/JAVA/">JAVA</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-jvm/java-xx-command-NativeMemoryTracking" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/23/jvm/java-xx-command-NativeMemoryTracking/">Java 命令行---（NativeMemoryTracking）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>JVM提供了详细追踪内存使用的工具，文中详细描述-XX:+NativeMemoryTracking的作用，设计，使用等范围。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/09/23/jvm/java-xx-command-NativeMemoryTracking/" class="archive-article-date">
  	<time datetime="2016-09-23T03:30:40.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-09-23</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/JAVA/">JAVA</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-jvm/OrderAccess" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/23/jvm/OrderAccess/">JVM之OrderAcess</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>OrderAcess是Java内存模型的一个重要组成部分。<br>intel x86_64处理器在执行的时候基于性能的考虑，在store buffer(不是cache，不翻译知道意思就行)满的时候，允许处理器先处理load的指令，这样就可能导致在执行的时候处理器处理指令的时候可能和我们在程序中写的顺序是不一致的，处理器定义内存的处理器序(弱虚，处理器尽可能的优化指令的执行顺序，达到并行)和程序序(强序，按照程序的定义执行执行)。<br>通常处理器会优化执行执行顺序，编译器也会优化执行的顺序，让执行尽可能安装处理器的顺序分布执行。这样就会导致我们在程序中声明的执行顺序和最终执行的不一致，就会导致处理器看到的内容不一致。<br>这篇就是解决这种不一致性导致了不可知的问题。<br>我们这里描述是基于intel平台的实现</p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>声明为volatile的变量，编译器不会做优化，可能保证变量在程序中的位置。在Java中的语义和gcc是不一样的。</p>
<h2 id="LoadLoad"><a href="#LoadLoad" class="headerlink" title="LoadLoad"></a>LoadLoad</h2><p>序列：Load1,Loadload,Load2</p>
<p>确保Load1所要读入的数据能够在被Load2和后续的load指令访问前读入。通常能执行预加载指令或/和支持乱序处理的处理器中需要显式声明Loadload屏障，因为在这些处理器中正在等待的加载指令能够绕过正在等待存储的指令。 而对于总是能保证处理顺序的处理器上，设置该屏障相当于无操作。<br>我们看看怎么实现的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:hotspot\src\os_cpu\linux_x86\vm\orderAccess_linux_x86.inline.hpp</div><div class="line"></div><div class="line">inline void OrderAccess::loadload()   &#123; acquire(); &#125;</div><div class="line"></div><div class="line">inline void OrderAccess::acquire() &#123;</div><div class="line">  volatile intptr_t local_dummy;</div><div class="line">#ifdef AMD64</div><div class="line">  __asm__ volatile (&quot;movq 0(%%rsp), %0&quot; : &quot;=r&quot; (local_dummy) : : &quot;memory&quot;);</div><div class="line">#else</div><div class="line">  __asm__ volatile (&quot;movl 0(%%esp),%0&quot; : &quot;=r&quot; (local_dummy) : : &quot;memory&quot;);</div><div class="line">#endif // AMD64</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>反汇编后：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">5f6f8e:       55                      push   %rbp</div><div class="line">5f6f8f:       48 89 e5                mov    %rsp,%rbp</div><div class="line">5f6f92:       48 8b 04 24             mov    (%rsp),%rax</div><div class="line">5f6f96:       48 89 45 f8             mov    %rax,-0x8(%rbp)</div><div class="line">5f6f9a:       c9                      leaveq </div><div class="line">5f6f9b:       c3                      retq</div></pre></td></tr></table></figure></p>
<p>为什么这么写呢？这段指令的作用又是什么呢？<br>在《Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3 (3A, 3B, 3C &amp;3D):System Programming Guide》中<strong>8.2.3.2 Neither Loads Nor Stores Are Reordered with Like Operations
</strong>节，intel规定Load指令和Load指令不会重排(reorder)。这样保证Load1必须在Loadload(mov    %rax,-0x8(%rbp))指令之前执行，Loadload必须在Load2指令之前执行。这样在同一个处理器上Load1总是保证在Load2和后续的Load前执行。所以这段执行就是简单的内存Load指令。</p>
<p>在《Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3 (3A, 3B, 3C &amp;3D):System Programming Guide》中<strong>8.2.3.5 Intra-Processor Forwarding Is Allowed
</strong>节，intel多个处理器可能看到的内存顺序就不一致了。由于store buffer的存在，不同的处理器可能看不到其他处理器对同一个内存位置的修改。</p>
<p>StoreStore  屏障</p>
<p>序列：Store1，StoreStore，Store2</p>
<p>确保Store1的数据在Store2以及后续Store指令操作相关数据之前对其它处理器可见（例如向主存刷新数据）。通常情况下，如果处理器不能保证从写缓冲或/和缓存向其它处理器和主存中按顺序刷新数据，那么它需要使用StoreStore屏障。</p>
<p>我们看看怎么实现的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:hotspot\src\os_cpu\linux_x86\vm\orderAccess_linux_x86.inline.hpp</div><div class="line"></div><div class="line">inline void OrderAccess::storestore() &#123; release(); &#125;</div><div class="line"></div><div class="line">inline void OrderAccess::release() &#123;</div><div class="line">  // Avoid hitting the same cache-line from</div><div class="line">  // different threads.</div><div class="line">  volatile jint local_dummy = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>反汇编后：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">5f6f9c:       55                      push   %rbp</div><div class="line">5f6f9d:       48 89 e5                mov    %rsp,%rbp</div><div class="line">5f6fa0:       c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%rbp)</div><div class="line">5f6fa7:       c9                      leaveq </div><div class="line">5f6fa8:       c3                      retq   </div><div class="line">5f6fa9:       90                      nop</div></pre></td></tr></table></figure></p>
<p>在《Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3 (3A, 3B, 3C &amp;3D):System Programming Guide》中<strong>8.2.3.2 Neither Loads Nor Stores Are Reordered with Like Operations
</strong>节，intel规定Store指令和Store指令不会重排(reorder)。这样保证Store1必须在StoreStore(movl   $0x0,-0x4(%rbp))指令之前执行，StoreStore必须在Store2指令之前执行。这样在同一个处理器上Store1总是保证在Store2和后续的Store前执行。所以这段执行就是简单的内存Store指令。</p>
<p>LoadStore 屏障</p>
<p>序列： Load1; LoadStore; Store2</p>
<p>确保Load1的数据在Store2和后续Store指令被刷新之前读取。在等待Store指令可以越过loads指令的乱序处理器上需要使用LoadStore屏障。</p>
<p>我们看看怎么实现的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:hotspot\src\os_cpu\linux_x86\vm\orderAccess_linux_x86.inline.hpp</div><div class="line"></div><div class="line">inline void OrderAccess::loadstore()  &#123; acquire(); &#125;</div><div class="line"></div><div class="line">inline void OrderAccess::acquire() &#123;</div><div class="line">  volatile intptr_t local_dummy;</div><div class="line">#ifdef AMD64</div><div class="line">  __asm__ volatile (&quot;movq 0(%%rsp), %0&quot; : &quot;=r&quot; (local_dummy) : : &quot;memory&quot;);</div><div class="line">#else</div><div class="line">  __asm__ volatile (&quot;movl 0(%%esp),%0&quot; : &quot;=r&quot; (local_dummy) : : &quot;memory&quot;);</div><div class="line">#endif // AMD64</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看出LoadLoad和LoadStore实现是一样的。为什么呢？<br>还是需要从intel文档中找答案。在《Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3 (3A, 3B, 3C &amp;3D):System Programming Guide》中《8.2.3.3 Stores Are Not Reordered With Earlier Loads》节，我们知道如果Load执行在前面，那么后面的store的执行不会重排(reorder)，这样就保证Load1的数据在Store2和后续Store指令被刷新之前读取。</p>
<p>StoreLoad Barriers</p>
<p>序列: Store1; StoreLoad; Load2</p>
<p>确保Store1的数据在被Load2和后续的Load指令读取之前对其他处理器可见。StoreLoad屏障可以防止一个后续的load指令 不正确的使用了Store1的数据，而不是另一个处理器在相同内存位置写入一个新数据。正因为如此，所以在下面所讨论的处理器为了在屏障前读取同样内存位置存过的数据，必须使用一个StoreLoad屏障将存储指令和后续的加载指令分开。Storeload屏障在几乎所有的现代多处理器中都需要使用，但通常它的开销也是最昂贵的。它们昂贵的部分原因是它们必须关闭通常的略过缓存直接从写缓冲区读取数据的机制。这可能通过让一个缓冲区进行充分刷新（flush）,以及其他延迟的方式来实现。<br>我们看看怎么实现的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:hotspot\src\os_cpu\linux_x86\vm\orderAccess_linux_x86.inline.hpp</div><div class="line"></div><div class="line">inline void OrderAccess::storeload()  &#123; fence(); &#125;</div><div class="line"></div><div class="line">inline void OrderAccess::fence() &#123;</div><div class="line">  if (os::is_MP()) &#123;</div><div class="line">    // always use locked addl since mfence is sometimes expensive</div><div class="line">#ifdef AMD64</div><div class="line">    __asm__ volatile (&quot;lock; addl $0,0(%%rsp)&quot; : : : &quot;cc&quot;, &quot;memory&quot;);</div><div class="line">#else</div><div class="line">    __asm__ volatile (&quot;lock; addl $0,0(%%esp)&quot; : : : &quot;cc&quot;, &quot;memory&quot;);</div><div class="line">#endif</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从代码中我们可以知道这是个重量级的操作，使用lock前缀，而且是一个空操作(将0加到栈顶)，在《Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3 (3A, 3B, 3C &amp;3D):System Programming Guide》<strong>8.2.3.9 Loads and Stores Are Not Reordered with Locked Instructions</strong>节规定使用lock前缀的执行不允许排序，不管是store还是load。所以我们知道这个屏障其实也是最重量的实现，也是对性能影响最大的操作。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="Memory-Reording-Caught-in-Act"><a href="#Memory-Reording-Caught-in-Act" class="headerlink" title="Memory Reording Caught in Act"></a>Memory Reording Caught in Act</h3><p>前言：<br>首先是翻译的几篇有关memory reordering的文章，作者是一个老外，虽然文章是几年前的，但是很值得一读。<br>最近不知道写些什么东西，拿这个先凑几篇<br>其次有关什么memory ordering，memory reordering，memory model这些名词，可能很多时候直接e文，没有翻译，个人习惯。</p>
<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a><a href="http://preshing.com/20120515/memory-reordering-caught-in-the-act/" target="_blank" rel="external">原文</a></h2><p>当使用C或者C++编写lock-free的代码时，你必须特别小心的保证正确的内存顺序。否则的话，会遇到不少“惊喜”。</p>
<p>Intel在它们的x86/64体系结构规范的第三卷8.2.3节列举了几种这样的case。拿最简单的那个例子来说。假设在内存中有两个整数变量x和y，都初始化为0，两个并行运行的processor执行下面的机器码：<br>乱序的例子<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">                | Processor 1  | Processor 1 |</div><div class="line"> store to X ---&gt;|mov [X], 1    | mov [Y],1   | &lt;---store to Y</div><div class="line">load form Y ---&gt;|mov r1 , [Y]  | mov r2 ,[X] | &lt;---load from X</div></pre></td></tr></table></figure></p>
<p>别被其中的汇编语言吓到，这其实是描述CPU执行顺序的最佳方式。每个processor将1保存到其中一个整形变量，然后将另外一个变量读取到一个register（这里r1和r2是表示x86 register的符号，比如eax）。</p>
<p>现在，无论哪个processor先把1写到内存，很自然我们期望另一个processor会把这个值读出来，也就是说，代码执行完后，我们应该得到的结果是：r1=1或者r2=1，或者r1和r2都是1。但是，根据Intel的规范，结果并不总是这样，规范说本例还有另外一种合法的结果：r1和r2都是0——一个违反直觉的结果。</p>
<p>因为像其它的处理器家族一样，Intel x86/64处理器在特定的规则下允许将内存指令重排序，只要不会改变单线程程序的执行（as long it never changes the execution of a single-threaded program）。<br>特别的，每一个processor都允许将一个store的影响推迟到任何读取其它内存的load之后（each processor is allowed to delay the effect of a store past any load from a different location）。结果就是，实际上可能根据如下的指令顺序来执行的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">     | Processor 1  | Processor 2  |</div><div class="line">---&gt; | mov r1 ,[Y]  |              |</div><div class="line">|    |              | mov r2 ,[X]  | &lt;---</div><div class="line">---&gt; | mov [X],1    |                    |</div><div class="line">                    | mov [Y],1    | &lt;---</div></pre></td></tr></table></figure></p>
<p>–&gt;Spark注：这里作者只是介绍了StoreLoad内存序，实际上基于store和load有4种内存序，这是CPU内存模型的主要部分，在后面的文章中会专门介绍。还有就是MOV r1, [y]实际上有两步：读y写r1；<br>以P1为例上面的操作实际上是三步：store x; load y; store r1;</p>
<h4 id="Let’s-Make-It-Happen"><a href="#Let’s-Make-It-Happen" class="headerlink" title="Let’s Make It Happen"></a>Let’s Make It Happen</h4><p>有人告诉你可能会出现这种结果也是不错的，但是还远不如亲眼看到这种结果。所以我写了一个小程序来说明这种乱序确实会发生，源代码在这里。<br>示例代码包括Win32和POSIX两个版本，它创建两个工作线程，无限重复上面的事务，然后主线程同步并检查它们的结果。</p>
<p>这是第一个工作线程的代码。X, Y, r1和r2都是全局变量，POSIX信号量用于协调每次循环的开始和结束。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sem_t beginSema1;</div><div class="line">sem_t beginSema2;</div><div class="line">sem_t endSema;</div><div class="line"></div><div class="line">int X, Y;</div><div class="line">int r1, r2;</div><div class="line"></div><div class="line">void *thread1Func(void *param) &#123;</div><div class="line">    MersenneTwister random(1);</div><div class="line">    for (;;) &#123;</div><div class="line">        sem_wait(&amp;beginSema1);  // Wait for signal</div><div class="line">        while (random.integer() % 8 != 0) &#123;&#125;  // Random delay</div><div class="line"></div><div class="line">        // ----- THE TRANSACTION! -----</div><div class="line">        X = 1;</div><div class="line">        asm volatile(&quot;&quot; ::: &quot;memory&quot;);  // Prevent compiler</div><div class="line">        r1 = Y;</div><div class="line"></div><div class="line">        sem_post(&amp;endSema);  // Notify transaction complete</div><div class="line">    &#125;</div><div class="line">    return NULL;  // Never returns</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这段代码在每次事务之前加了一个随机的短暂延迟，这是为了让线程的运行时间交错。记住，一共有两个工作线程，我们要试着让它们的指令执行产生重叠。随机延迟是使用的是前面几篇文章中中实现的MersennelTwister，比如measuring lock contention。<br>注spark：这里不需要关注这个MersennelTwister，其实直接使用rand()函数也是一样的，在 main中srand(time(0))；测试结果不变，而且碰撞的概率更高。</p>
<p>也不要被代码中的asm volatile吓到，这只是告诉GCC编译器在生成机器码时不要重排store和load操作的指令顺序，防止它在优化时搞什么我们不想要的花样。我们可以检查汇编代码来验证这一点，比如下面的代码片段。如同所期望的那样，store和load指令是期望的顺序。后面的指令将保存结果的register eax写回到了全局变量r1。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ gcc -O2 -c -S -masm=intel ordering.cpp</div><div class="line">$ cat ordering.s</div><div class="line">    ...</div><div class="line">    mov    DWORD PTR _X, 1</div><div class="line">    mov    eax, DWORD PTR _Y</div><div class="line">    mov    DWORD PTR _r1, eax</div><div class="line">    ...</div></pre></td></tr></table></figure></p>
<p>主线程代码如下，就是一个管理工作。它在初始化之后无限循环，每次循环之前将X和Y重置为0。<br>特别注意程序是如何让写共享内存发生在sem_post之前的，以及让所有读共享内存发生在sem_wait之后的。工作线程和主线程之间的通信也采用了同样的机制。<br>在所有平台上，Semaphores都给我们提供了acquire-release语义，这个后面会仔细分析。这就意味着，我们保证X=0和Y=0的初始化结果会完整的传播给工作线程，r1和r2的结果都会完整的传播回来。换句话说，semaphores防止我们程序框架的memory reordering，让我们专注于测试StoreLoad reordering的情况。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int main() &#123;</div><div class="line">    // Initialize the semaphores</div><div class="line">    sem_init(&amp;beginSema1, 0, 0);</div><div class="line">    sem_init(&amp;beginSema2, 0, 0);</div><div class="line">    sem_init(&amp;endSema, 0, 0);</div><div class="line"></div><div class="line">    // Spawn the threads</div><div class="line">    pthread_t thread1, thread2;</div><div class="line">    pthread_create(&amp;thread1, NULL, thread1Func, NULL);</div><div class="line">    pthread_create(&amp;thread2, NULL, thread2Func, NULL);</div><div class="line">    // Repeat the experiment ad infinitum</div><div class="line">    int detected = 0;</div><div class="line">    for (int iterations = 1; ; iterations++) &#123;</div><div class="line">        // Reset X and Y</div><div class="line">        X = 0;</div><div class="line">        Y = 0;</div><div class="line">        // Signal both threads</div><div class="line">        sem_post(&amp;beginSema1);</div><div class="line">        sem_post(&amp;beginSema2);</div><div class="line">        // Wait for both threads</div><div class="line">        sem_wait(&amp;endSema);</div><div class="line">        sem_wait(&amp;endSema);</div><div class="line">        // Check if there was a simultaneous reorder</div><div class="line">        if (r1 == 0 &amp;&amp; r2 == 0) &#123;</div><div class="line">            detected++;</div><div class="line">            printf(&quot;%d reorders detected after %d iterations\n&quot;, </div><div class="line">                                           detected, iterations);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;  // Never returns</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果显示，发生了很多次的重排序，也就是结果r1和r2都是0：<br>注spark：下面都是我自己的测试结果。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1 reorders detected after 1 iterations</div><div class="line">2 reorders detected after 2 iterations</div><div class="line">3 reorders detected after 3 iterations</div><div class="line">... ...</div><div class="line">31 reorders detected after 799 iterations</div><div class="line">32 reorders detected after 1058 iterations</div></pre></td></tr></table></figure></p>
<p>而且可以看出概率相当的高，简直是必现，我这里是Mac系统，Intel Core i5处理器；<br>换到Linux继续测试，Intel x86_64处理器，概率相对低一些：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1 reorders detected after 4760 iterations</div><div class="line">2 reorders detected after 6671 iterations</div><div class="line">3 reorders detected after 8859 iterations</div><div class="line">4 reorders detected after 12980 iterations</div></pre></td></tr></table></figure></p>
<p>好了，我们当然期望能消除这种乱序。至少有两种方法可以做到，一个是设置线程的CPU亲缘性，这样两个线程都运行在同一个CPU core上，在Linux：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">cpu_set_t cpus;</div><div class="line">CPU_ZERO(&amp;cpus);</div><div class="line">CPU_SET(0, &amp;cpus);</div><div class="line">pthread_setaffinity_np(thread1, sizeof(cpu_set_t), &amp;cpus);</div><div class="line">pthread_setaffinity_np(thread2, sizeof(cpu_set_t), &amp;cpus);</div></pre></td></tr></table></figure></p>
<p>因为单个processor看到自己的操作肯定不会是乱序的，即使在线程被任意次的抢占和重新调度但。很显然，这并不是好方法。<br>—&gt;spark注：<br>可以再引申一下：<br>在单processor下，下面的执行顺序都是合法的：<br>1 线程1：x = 1; r2 = y; -&gt; 线程2：r1 = x; y = 1;<br>仅仅线程2中顺序重排，不违反原则，对x的reads没有和线程1中的写x=1重排序；<br>2 线程1：r2 = y; x = 1; -&gt; 线程2：y = 1; r1 = x;<br>仅仅线程1中顺序重排，不违反原则，对y的reads没有和线程2中的写y=1重排序；<br>单processor上，对同一地址的loads不能提前到它前面的stores而先执行，这应该是所有CPU体系结构的共同原则，否则就是错误！所以将这两个线程绑定在同一个processor上不会再出现r1和r2都是0的情况。<br>&lt;—over<br>一个相关的note，在PlayStation3上，没有检测到内存乱序。这显示（但并不能确定）两个PPU内的硬件线程可能像单一的processor在运行，有很细粒度的硬件调度。</p>
<h4 id="Preventing-It-With-a-StoreLoad-Barrier"><a href="#Preventing-It-With-a-StoreLoad-Barrier" class="headerlink" title="Preventing It With a StoreLoad Barrier"></a>Preventing It With a StoreLoad Barrier</h4><p>另外一个方法就是在两个操作之间引入CPU barrier，这里我们要防止store和它后面的load指令重排。用通常的barrier说法就是，我们需要一个StoreLoad barrier。</p>
<p>虽然x86/64处理器没有专门的用作StoreLoad barrier的指令，但是有好几个指令包含了StoreLoad的功能，并且还可以做得更多。mfence指令是一个全内存barrier，它防止任何情况下的memory reordering，在GCC下，代码可以这样写：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">for (;;)   &#123;                               // Loop indefinitely</div><div class="line">    sem_wait(&amp;beginSema1);                // Wait for signal from main thread</div><div class="line">    while (random.integer() % 8 != 0) &#123;&#125;  // Add a short, random delay</div><div class="line"></div><div class="line">    // ----- THE TRANSACTION! -----</div><div class="line">    X = 1;</div><div class="line">    asm volatile(&quot;mfence&quot; ::: &quot;memory&quot;);  // Prevent memory reordering</div><div class="line">    r1 = Y;</div><div class="line"></div><div class="line">    sem_post(&amp;endSema);                   // Notify transaction complete</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再次查看汇编代码验证：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">...</div><div class="line">mov    DWORD PTR _X, 1</div><div class="line">mfence</div><div class="line">mov    eax, DWORD PTR _Y</div><div class="line">mov    DWORD PTR _r1, eax</div><div class="line">...</div></pre></td></tr></table></figure></p>
<h4 id="Similar-Instructions-and-Different-Platforms"><a href="#Similar-Instructions-and-Different-Platforms" class="headerlink" title="Similar Instructions and Different Platforms"></a>Similar Instructions and Different Platforms</h4><p>有趣的是，mfence不是x86/64上唯一可以用作full memory barrier的指令，在这些处理器上，任何锁指令，比如xchg，也可以用作full memory barrier——当你不使用SSE指令或者写组合内存时。实际上至少在VS2008之前，当你使用MemoryBarrier时，Microsoft C++生成的都是xchg指令~~~</p>
<p>而mfence指令是x86/64特有的，如果你希望跨平台，就需要自己自己wrap一个。Linux内核wrap了一个smp_mb的宏，类似的还有smb_rmb和smp_wmb。比如在PowerPC上，smp_mb就是sync。<br>所有不同的CPU家族，都有自己的强制memory ordering的指令，每一个跨平台的项目都需要实现自己的跨平台代码库，这显然不是一个轻松的事情。这也是为什么C++11引入了atomic库标准，这会简化编写可移植lock-free代码的工作量。</p>
<h4 id="评论摘选"><a href="#评论摘选" class="headerlink" title="评论摘选"></a>评论摘选</h4><p>文章有些评论很不错，这条是来自于Bruce Dawson：<br>非常不错——写测试代码来验证是不错的注意。<br>我想对本文提出一点修正和解释。<br>修正之处就是：reads/writes的重排序和指令重排序是正交的（没有必然联系）。Xbox360 CPU不会做指令重排序，但是底层的reads/writes却会重排序。实际上相比Xbox360这种有序的CPU，Intel/AMD这些out-of-oder的CPUs上对read/write的重排序还少很多。</p>
<p>这种情况下，在光速有限的宇宙中，任何多核系统中reordering都是不可避免的。如果两个processor同时write 1，期望它们可以在下一个指令就可以看到彼此的write是不切实际的。实际上，这个write传播到其它core可能需要花费数十个CPU周期。任何防止这种重排序的系统，它的运行速度不可能超过100MHz，甚至更慢。因为一个它必须不断的等待其它core的signal（等待其它core对write的响应）。<br>—-&gt;spark注：多说一点，现代CPU为了提升执行速度，通常都会采用多级cache，每个core都会自己的一级cache。由于这些cache的存在，读写的reordering是难以避免的，相比指令乱序，它是导致memory reordering的更主要的原因。<br>正如Bruce Dawson所说的：<br>如果要保持各个core的cache之间严格一致，那么每次更新都要等待其它core的响应。这样的话，CPU的速度就不然被限制了。</p>
<h3 id="MEMORY-ORDERING"><a href="#MEMORY-ORDERING" class="headerlink" title="MEMORY ORDERING"></a>MEMORY ORDERING</h3><p>前言：这篇文章是翻译自的Intel x86/64的规范文档，其中第8.2节中有关Memory Ordering的几段。整个文档是一本巨书，这里可以download：<a href="http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-system-programming-manual-325384.pdf" target="_blank" rel="external">http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-system-programming-manual-325384.pdf</a><br>因为我们有必要了解一下CPU对memory ordering的规范说明，这里我们看看Intel的。</p>
<hr>
<p>术语memory ordering指的是，processor以何种顺序通过系统总线发起到系统内存的读（loads）和写（stores）操作。基于体系结构的实现，Intel64和IA-32支持好几种memory-ordering模型。比如Intel386处理器强制执行程序顺序（通常被称为strong ordering（强排序）），在任何情况下，对系统总线发起的读和写都是根据他们在指令流中的顺序进行的。<br>为了优化指令执行的性能，IA-32体系结构允许违背strong ordering模型，在P4，Xeon和P6 processor家族中，这被称为processor ordering。这些processor-ordering变形（这里成为memory ordering模型）允许提升性能的而一些操作，比如允许读提升到缓存写的前面。这些变形的目的都是为了在维持内存conherency的基础上提升执行的速度，甚至在多核系统中。</p>
<h3 id="Memory-Ordering-in-the-Pentium-and-Intel486-Processors"><a href="#Memory-Ordering-in-the-Pentium-and-Intel486-Processors" class="headerlink" title="Memory Ordering in the Pentium and Intel486 Processors"></a>Memory Ordering in the Pentium and Intel486 Processors</h3><p>Pentium和Intel486 processor遵循processor-ordered内存模型，然而在大多数情况下，它们都是按照strong-ordered processor运行的。在系统总线上的读和写通常都是程序序——除了如下的情况会展现出processor ordering。当所有的buffered write cache命中时，Read misses允许被提升到对系统总线的buffered writes之前，因此buffered write不会同时指向被read miss访问的同一块地址上（因为buffered write cache命中）。<br>在I/O操作的情形，读和写都是根据程序序。<br>期望在processor-ordered processor上正确执行的软件不应该依赖Pentium和Intel486的相对strong ordering。相反，应该保证对共享变量的访问如果要控制processor之间的并发执行，要显式的使用lock和序列化操作来保证程序序。</p>
<h3 id="Memory-Ordering-in-P6-and-More-Recent-Processor-Families"><a href="#Memory-Ordering-in-P6-and-More-Recent-Processor-Families" class="headerlink" title="Memory Ordering in P6 and More Recent Processor Families"></a>Memory Ordering in P6 and More Recent Processor Families</h3><p>Intel Core 2Duo，Atom，Core Duo，Pentium4和P6家族使用的processor-ordered memory-ordering模型，又可以被进一步定义为：write ordered with store-buffer forwarding。这种模型的特性如下面的描述：<br>在single-processor系统中对于被定义为write-back cacheable的内存区域，memory-ordering模型有如下的原则（注意对于single和multiple processor的memory-ordering原则都是从在processor上执行的软件的角度来说的，这里的属于processor指的是logical processor。比如，一个支持multiple core或者Intel Hyper-Threading计数的物理processor也被当做multi-processor系统看待）：</p>
<p>1 读和读不会重排序；Reads are not reordered with other reads<br>2 写和older读不会重排序；Writes are not reordered with older reads;<br>3 写和写不会重排序；Writes are not reordered with other writes，除了如下情况：<br>— 使用nonn-temporal move指令（MOVNT1, MOVENTQ，MOVNTDQ等）的streaming<br>stores（writes）<br>— string操作（见8.2.4.1）<br>4 Reads可能会和对不同地址的older writes重排序，但是同一地址不会（prefetch？）<br>5 Reads不能越过前面的LFENCE和MFENCE指令；<br>6 还有其它规则，不一一列举了，直接看文档；<br>在multiple-processor系统上应用了如下的规则：</p>
<p>1 单processor使用和single-processor系统相同的规则<br>2 一个processor的writes会按照相同的顺序对所有的processor可见<br>3 一个processor的writes不要求与其它processor的writes有序<br>Writes from a single processor are NOT ordered with respect to<br>the writes from other processors<br>4 Memory ordering遵从因果关系（memory ordering遵守传递可见性）<br>Memory ordering byes causality (memory ordering respects transitive visibility)<br>5 Lock指令是全序的，Locked instructions have a total order</p>
<h3 id="Examples-Illustrating-the-Memory-Ordering-Principles"><a href="#Examples-Illustrating-the-Memory-Ordering-Principles" class="headerlink" title="Examples Illustrating the Memory-Ordering Principles"></a>Examples Illustrating the Memory-Ordering Principles</h3><p>本节提供几个例子来说明8.2.2节中介绍的memory-ordering原则下的行为；可以帮助软件编写者明白memory ordering可能影响指令不同顺序时的结果。<br>这些例子仅限于访问被定义为write-back cacheable（WB）的内存区域（8.2.3.1节描述了其它的一些限制）。读者应该明白它们只是描述了对软件可见的行为。一个logic processor也可能重排两个access，即使一个例子表示他们可能没有重排。<br>这个例子只是说明软件不能检测出这样的一个重排发生了。类似的，一个logic processor可能会多次执行一个内存access操作，只要对软件来说这个行为和只执行一次内存access的结果是一致的。</p>
<h4 id="Assumptions-Terminology-and-Notion"><a href="#Assumptions-Terminology-and-Notion" class="headerlink" title="Assumptions, Terminology, and Notion"></a>Assumptions, Terminology, and Notion</h4><p>前面说过的，本节中的例子仅限于访问被定义为write-back cacheable（WB）的内存区域。它们只应用在通常的loads stores，已经locked read-modify-write指令。并不应用于如下的几种情况：string指令的out-of-order stores（8.2.4节）；等等，后面集中不翻译了。</p>
<p>本节例子的基础原则适用于单个的memory accesses和locked read-modify-write指令。Intel-64 memory-ordering模型保证：下面的每一种memory-access指令，其内存操作看来就像执行一个单个的内存访问。</p>
<p>1 读写单个byte；<br>2 读写单个word(2 bytes)，地址对齐在2 byte；<br>3 读写单个double word（4 bytes），字节对齐在4 byte；<br>4 读写单个quadword（8 bytes），字节对齐在8byte；<br>任何locked指令（XCHG或者其它任何待LOCK前缀的read-modify-write指令）看起来就像执行不可见的不可中断的顺序：load(s) followed by store(s)，并且忽略对齐。<br>其它指令可能会实现成多个内存访问。从memory-ordering的角度看，并且没有相对顺序的保证。</p>
<p>8.2.3.2到8.2.3.7给了使用MOV指令的例子，这些例子中的原则同样用于通用的load和store，以及其它从内存load或者向内存的store的指令。</p>
<p>本节中的术语“processor”代表的是logic processor，例子是基于Intel-64汇编语言语法，并且使用如下的符号约定：</p>
<p>1 使用r开头的变量，比如r1和r2，代表了寄存器；<br>2 内存地址用x,y,z表示；<br>3 Store操作写作 mov [_x], val，表示将val存储到地址x中；<br>4 Load操作写作mov r, [_x]，表示读取地址x中的内容并保存到寄存器r；<br>再说一遍，例子仅仅代表从软件的角度看到的行为，当后面的小节说“这两个stores被重排序了”，指的是“从软件的角度看，这两个stores重排序了”。</p>
<h4 id="Neither-Loads-Nor-Stores-Are-Reordered-with-Like-Operations"><a href="#Neither-Loads-Nor-Stores-Are-Reordered-with-Like-Operations" class="headerlink" title="Neither Loads Nor Stores Are Reordered with Like Operations"></a>Neither Loads Nor Stores Are Reordered with Like Operations</h4><p>在Intel-64 memory-ordering模型中，loads和loads之间，以及stores和stores之间是绝对不允许重排序的。也就是说，它保证，loads和程序序一致，stores和程序序一致；比如如下的例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1 | Processor 0            |  Processor 1  |</div><div class="line">2 | mov [_x], 1            |  mov r1, [_y] |</div><div class="line">3 | mov [_y], 1            |  mov r2, [_x] |</div></pre></td></tr></table></figure></p>
<p>初始值x = y = 0，执行结果r1=1，r2=0是不允许的。<br>这种不允许的结果只有在如下的两种情况下才会出现：<br>1 processor0的两个stores重新排序了；（processor1的两个loads在它们中间执行）<br>2 或者processor1的两个loads重新排序了；（processor0的两个stores在它们中间执行）</p>
<p>如果r1=1，那么对y的store操作早于对y的load操作。（继续）因为Intel-64 memory-ordering模型不允许store之间重排序，所以对x的store早于对y的load。因为也不允许loads之间重新排序，所以对x的store也早于对x的load，因此r2=1。</p>
<h4 id="Stores-Are-Not-Reordered-With-Earlier-Loads"><a href="#Stores-Are-Not-Reordered-With-Earlier-Loads" class="headerlink" title="Stores Are Not Reordered With Earlier Loads"></a>Stores Are Not Reordered With Earlier Loads</h4><p>Intel-64 memory-ordering保证，对于同一个processor，store操作不能在在它前面的load之前执行；用如下的例子说明：<br>例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1 |  Processor 0              |  Processor 1</div><div class="line">2 |  mov r1, [_x]             |  mov r2, [_y]</div><div class="line">3 |  mov [_y], 1              |  mov [_x], 1</div></pre></td></tr></table></figure></p>
<p>初始值x = y = 0，执行结果r1=1，r2=1是不允许的。</p>
<p>假设r1 = 1；</p>
<blockquote>
<p>因为r1=1，processor1的store to x早于processor0的load from x；<br>因为Intel-64 memory-ordering模型阻止在同一个processor上store与它前面的loads重新排序， 所以processor1的load from y早于它的store to x；<br>同样的，processor0的load from x早于它的store to y；<br>所以，processor1的load from y早于processor0的store to y，暗示r2=0；</p>
<h4 id="Loads-May-be-Reordered-with-Earlier-Stores-to-Different-Locations"><a href="#Loads-May-be-Reordered-with-Earlier-Stores-to-Different-Locations" class="headerlink" title="Loads May be Reordered with Earlier Stores to Different Locations"></a>Loads May be Reordered with Earlier Stores to Different Locations</h4></blockquote>
<p>这就是前面文章中的那个例子，Intel-64 memory-ordering模型下，load可以和前面的store重新排序，但是只能是对不同的地址。<br>例子1：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1 |Processor 0              |  Processor 1</div><div class="line">2 |mov [_x], 1              |  mov [_y], 1</div><div class="line">3 |mov r1, [_y]             |  mov r2, [_x]</div></pre></td></tr></table></figure></p>
<p>初始值x = y = 0，执行结果r1=0，r2=0是允许的。<br>在每一个processor上，load和store都是操作不同的地址，因此可以重排序。操作的任意交叉都是允许的，当两个loads早于两个stores执行时，就会出现r1=0和r2=0的结果。</p>
<p>对于同一个地址，则不允许，如下面的例子2：<br>Processor 0<br>mov [_x], 1<br>mov r1, [_x]<br>初始值x=0，那么r1=0是不允许的。<br>很显然如果mov r1, [_x]先执行，即使对于单线程程序，整个结果也是错误的。也就是前面的例子1在设置cpu affinity后，不会再出现r1=0和r2=0的结果。<br>虽然是两个线程，但是对于processor而言，对同一内存地址，load不能前面的store重排序。（对于processor其实是没有线程的概念的，在processor的视角上，只是对内存的store和load指令序列）</p>
<h4 id="Intra-Processor-Forwarding-is-Allowed"><a href="#Intra-Processor-Forwarding-is-Allowed" class="headerlink" title="Intra-Processor Forwarding is Allowed"></a>Intra-Processor Forwarding is Allowed</h4><p>Intel-64 memory-ordering模型允许两个processor的并发store时，这两个processor看到的顺序可能互不不同。特别的，每一个processor可能认知它自己的store发生在另一个processor之前。用如下的例子说明：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1 |Processor 0            |  Processor 1</div><div class="line">2 |mov [_x], 1            |  mov [_y], 1</div><div class="line">3 |mov r1, [_x]           |  mov r3, [_y]</div><div class="line">4 |mov r2, [_y]           |  mov r4, [_x]</div></pre></td></tr></table></figure></p>
<p>初始值x = y = 0；结果r2 = r4 = 0是允许的。<br>Memory-ordering对于两个processor执行的两个stores的顺序没有任何的限制。于是processor0看到自己的store早于processor1的，而processor1则看到自己的store早于processor0的（每一个processor都是自我一致性的），这就允许r2=r4=0；</p>
<p>在实际中，本例的这种重排现象会导致store-buffer forwarding这一结果。当store被临时的放在一个processor的store buffer中，这可以满足processor自己的load，但是却不能被其它的processor看到，因而不能load最新的结果。</p>
<h4 id="Stores-Are-Transitively-Visible"><a href="#Stores-Are-Transitively-Visible" class="headerlink" title="Stores Are Transitively Visible"></a>Stores Are Transitively Visible</h4><p>Intel64保证store的可见性是传递的，stores that are causally related appear to all<br>processors to occur in an order consistent with the causality relation。下面的例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1 |Process 0             | Processor 1               | Process 2</div><div class="line">2 |mov [_x], 1           | mov r1, [_x]              |</div><div class="line">3 |                      | mov [_y], 1               | mov r2, [_y]</div><div class="line">4 |                      |                           | mov r3, [_x]</div></pre></td></tr></table></figure></p>
<p>初始值x = y = 0; r1=1, r2 = 1, r3 = 0是不允许的；<br>假设r1 = r2 = 1；</p>
<blockquote>
<p>因为r1 = 1，processor0的store早于processor1的load；<br>因为Intel64不允许store和前面的load重排序（见2.4.3），processor1的load早于它的store；因此processor0的store早于processor1的store；<br>因为processor0的store早于process1的store，memory-ordering模型保证了从所有processor的角度看，processor0的store早于processor1的store；<br>因为r2 = 1，processor1的store早于processor2的load；<br>因为Intel64阻止了load之间的重排序，processor2的load是根据次序发生的；<br>上面的条目暗示了processor0对x的store发生于processor2从x的load，因此r3 = 1；</p>
<h4 id="Stores-Are-Seen-in-a-Consistent-Order-by-Other-Processors"><a href="#Stores-Are-Seen-in-a-Consistent-Order-by-Other-Processors" class="headerlink" title="Stores Are Seen in a Consistent Order by Other Processors"></a>Stores Are Seen in a Consistent Order by Other Processors</h4></blockquote>
<p>就像2.4.5节提到的，对于两个processor的stores，memory-ordering允许它们看到不同的顺序。然而对于它们之外的其它的processor而言，这两个store的执行顺序必须看起来是一致的。用下面的例子说明：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1 |Processor 0   | Processor 1    | Processor 2    | Processor 3</div><div class="line">2 |mov [_x], 1   | mov [_y], 1    | mov r1, [_x]   | mov r3, [_y]</div><div class="line">3 |                               | mov r2, [_y]   | mov r4, [_x]</div></pre></td></tr></table></figure></p>
<p>初始值x = y = 0，r1 = 1, r2 = 0, r3 = 1, r4 = 0是不允许的。<br>基于2.4.3的原则：</p>
<blockquote>
<p>processor2的两个load不能重排序；<br>processor3的两个load不能重排序；<br>如果r1 = 1， 并且r2 = 0，那么在processor2看来，processor0的store早于<br>processor1的store；<br>同样的，r3 = 1并且r4 = 0暗示了processor1的store早于processor0的store<br>（注：这里应该是从processor3的角度）<br>因为本条规则保证了：对于其它的processor，它们看到的任何两条store的执行顺序都需要是一致的；那么这个结果无疑违反了这个原则。<br>好了，后面还有其它的几个例子，不列举了，到这里应该足够了。</p>
</blockquote>
<h3 id="Memory-Ordering-at-Compile-Time"><a href="#Memory-Ordering-at-Compile-Time" class="headerlink" title="Memory Ordering at Compile Time"></a>Memory Ordering at Compile Time</h3><p>JUN 25, 2012 <a href="http://preshing.com/20120625/memory-ordering-at-compile-time/" target="_blank" rel="external">原文</a></p>
<p>从你写C/C++源代码到它在CPU里执行，这段代码的内存交互可能会根据特定的规则被重新排序了。编译器（编译期）和processor（运行期）都有可能导致内存序的改变，都是为了能够让你的代码运行的更快。<br>对于memory reordering，被编译器开发者和CPU制造商广泛遵循的主要原则就是：<br>绝对不能修改单线程程序的行为；<br>Thou shalt not modify the behavior of a single-threaded program.</p>
<p>这条规则的结果就是，对于单线程代码，程序员完全无需关注memory reordering。通常多线程程序也不需要关注，因为从设计上，mutex， semaphore和event都会在它们的调用点防止memory reordering。仅仅在编写lock-free代码时memory reordering才可能会出来捣乱——被多线程共享的内存没有任何的互斥锁，memory reordering的影响很容易观察到，可见前一章的例子。</p>
<p>需要提醒你的是，在编写多核平台上的lock-free代码时还是有方法可以回避memory reordering的困难。就像在introduction to lock-free programming中提到的，你可以利用sequential consistent类型，比如Java中的volatile和C++11的atomic——可能只是很小的性能代价。这里不再深入说了。本篇文章，我将集中关注编译器memory reordering对常规的non-consequential-consistent类型的影响。</p>
<h4 id="Compiler-Instruction-Reordering"><a href="#Compiler-Instruction-Reordering" class="headerlink" title="Compiler Instruction Reordering"></a>Compiler Instruction Reordering</h4><p>如你所知，编译器的职责就是将源代码转换为CPU可以执行的机器码，在转换过程中，编译器有许多自由空间可以操作。<br>compiler-reordering<br>其中一种自由就是指令重排序——再一次，只有单线程程序的行为不会修改。这种指令重排序只是在开启了编译优化时才生效。考虑下面的函数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int A, B;</div><div class="line">void foo() &#123;</div><div class="line">    A = B + 1;</div><div class="line">    B = 0;</div><div class="line">&#125;</div><div class="line">`</div></pre></td></tr></table></figure></p>
<p>如果我们在关闭编译优化的情况下使用GCC4.6.1编译这个函数，它会生成如下的机器码，对全局变量B的store刚好在对A的store之后，就像在源代码中那样。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ gcc -S -masm=intel foo.c</div><div class="line">$ cat foo.s</div><div class="line">        ...</div><div class="line">        mov     eax, DWORD PTR _B  (redo this at home...)</div><div class="line">        add     eax, 1</div><div class="line">        mov     DWORD PTR _A, eax</div><div class="line">        mov     DWORD PTR _B, 0</div><div class="line">        ...</div></pre></td></tr></table></figure></p>
<p>注意上面的mov DWORD PTR B, 0的位置，这一语句是对B的赋值。然后开启-O2优化再编译一次，对比看看：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ gcc -O2 -S -masm=intel foo.c</div><div class="line">$ cat foo.s</div><div class="line">        ...</div><div class="line">        mov     eax, DWORD PTR B</div><div class="line">        mov     DWORD PTR B, 0</div><div class="line">        add     eax, 1</div><div class="line">        mov     DWORD PTR A, eax</div><div class="line">        ...</div></pre></td></tr></table></figure></p>
<p>这一次，编译器自由发挥了，将对B的store重新排序到了对A store的前面。有何不可呢？这并没有破坏memory reordering的规则：一个单线程执行的程序永远不知道这种差异。</p>
<p>在另一方面，这样的编译器reordering会使lock-free代码产生问题。下面就是一个被广泛引用的例子，一个共享flag用来表示另外的一些共享数据是否ready：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int Value;</div><div class="line">int IsPublished = 0;</div><div class="line"></div><div class="line">void sendValue(int x) &#123;</div><div class="line">    Value = x;</div><div class="line">    IsPublished = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>想象一下，如果编译器将对IsPublished的store操作重排到对value的store操作之前，会发生什么。即使在单核系统上，我们也会遇到一个问题：一个线程可能正好在执行这两个store操作之间被操作系统抢占，其它线程将会相信value已经更新了，而其实并没有。</p>
<p>当然，编译器可能不会重排这些操作，生成的机器码是lock-free的操作，并且可以在任何具有强内存模型的多核CPU上运行良好（strong memory model，后面会详解），比如x86/64，或者单核CPU。这种情况下，其实是运气成分。不用说，我们最好能认识到可能对共享变量的memory reordering，并且强制保证正确的顺序。</p>
<h4 id="Explicit-Compiler-Barriers"><a href="#Explicit-Compiler-Barriers" class="headerlink" title="Explicit Compiler Barriers"></a>Explicit Compiler Barriers</h4><p>阻止编译器重排序的最小手段就是使用特别的指令，称之为compiler barrier（编译器栅栏），前面已经提到过。下面就是一个GCC中的full compiler barrier，在Visual C++中，_ReadWriteBarrier具有相同的效果。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int A, B;</div><div class="line"></div><div class="line">void foo() &#123;</div><div class="line">    A = B + 1;</div><div class="line">    asm volatile(&quot;&quot; ::: &quot;memory&quot;);</div><div class="line">    B = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>加上了这个barrier，然后再打开编译器优化，内存store指令的顺序将不会被编译器重排。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ gcc -O2 -S -masm=intel foo.c</div><div class="line">$ cat foo.s</div><div class="line">        ...</div><div class="line">        mov     eax, DWORD PTR _B</div><div class="line">        add     eax, 1</div><div class="line">        mov     DWORD PTR _A, eax</div><div class="line">        mov     DWORD PTR _B, 0</div><div class="line">        ...</div></pre></td></tr></table></figure></p>
<p>类似的，如果你想保证前面的sendMessage正确工作，并且我们只关注单核系统，我们就可以使用compiler barrier。不仅发送操作需要compiler barrier来防止store操作的reordering，接收端同样需要。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#define COMPILER_BARRIER() asm volatile(&quot;&quot; ::: &quot;memory&quot;)</div><div class="line"></div><div class="line">int Value;</div><div class="line">int IsPublished = 0;</div><div class="line"></div><div class="line">void sendValue(int x) &#123;</div><div class="line">    Value = x;</div><div class="line">    COMPILER_BARRIER();   // prevent reordering of stores</div><div class="line">    IsPublished = 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int tryRecvValue() &#123;</div><div class="line">    if (IsPublished) &#123;</div><div class="line">        COMPILER_BARRIER(); // prevent reordering of loads</div><div class="line">        return Value;</div><div class="line">    &#125;</div><div class="line">    return -1;  // or some other value to mean not yet received</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>就像我提到的，compiler barrier对于防止单核系统的memory reordering是足够的。但是在当前的时代，多核系统是很普遍的。如果要确保我们的代码在多核环境下按照期望的顺序执行，那么仅仅只有compiler barrier是不够的，我们或者需要一个CPU fence，或者任何具有运行时memory barrier的操作。这就是下一篇文章了。</p>
<p>Linux内核以宏的方式暴露了集中CPU fence指令，比如smb_rmb，并且这些宏在单核系统下编译时会退化为compiler barrier。</p>
<h4 id="Implied-Compiler-Barriers"><a href="#Implied-Compiler-Barriers" class="headerlink" title="Implied Compiler Barriers"></a>Implied Compiler Barriers</h4><p>还有其他的方式可以阻止编译器重排序，确实，刚才提到的CPU fence就可以作为compiler barrier。这里是PowerPC上的fence命令，在GCC中是一个宏：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#define RELEASE_FENCE() asm volatile(&quot;lwsync&quot; ::: &quot;memory&quot;)</div></pre></td></tr></table></figure></p>
<p>无论我们在代码的任何地方加上RELEASE_FENCE宏，除了阻止compiler reordering，还有processor reordering。比如它可以使我们的sendValue函数安全的运行在多核环境下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void sendValue(int x) &#123;</div><div class="line">    Value = x;</div><div class="line">    RELEASE_FENCE();</div><div class="line">    IsPublished = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在新的C++11 atomic标准库，每一个non-relaxed atomic操作都可以作为compiler barrier。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int Value;</div><div class="line">std::atomic&lt;int&gt; IsPublished(0);</div><div class="line"></div><div class="line">void sendValue(int x) &#123;</div><div class="line">    Value = x;</div><div class="line">    // &lt;-- reordering is prevented here!</div><div class="line">    IsPublished.store(1, std::memory_order_release);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如何所期望的那样，每一个包含compiler barrier的函数同样也是一个compiler barrier，即使是inline函数（然而微软的文档建议在早期的Visual C++编译器中可能并非如此！！！）。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void doSomeStuff(Foo* foo) &#123;</div><div class="line">    foo-&gt;bar = 5;</div><div class="line">    sendValue(123);   // prevents reordering of neighboring assignments</div><div class="line">    foo-&gt;bar2 = foo-&gt;bar;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实际上不管函数本身有没有compiler barrier，大多数的函数调用都可以作为memory barrier，除了inline函数，使用了pure属性的函数声明，以及使用了link-time代码生成的情况。其它情况下，调用外部函数甚至是比compiler barrier更强的barrier，因为编译器不知道函数是否有其它影响（side effects）。对于被函数潜在可见的内存，它必须忘记任何有关的假设。</p>
<p>仔细想想，这很有道理。在上面的代码片段中，假设我们的sendValue实现是在一个外部库中。Compiler怎么会知道sendValue并不依赖foo-&gt;bar呢？它不会知道。因此，为了遵守memory reordering规则，它必须不能重排sendValue函数调用周围的所有内存操作。类似的，在调用完成后，它必须从内存重新load foo-&gt;bar，而不能假设它还是5，即使优化是打开的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ gcc -O2 -S -masm=intel dosomestuff.c</div><div class="line">$ cat dosomestuff.s</div><div class="line">        ...</div><div class="line">        mov    ebx, DWORD PTR [esp+32]</div><div class="line">        mov    DWORD PTR [ebx], 5            // Store 5 to foo-&gt;bar</div><div class="line">        mov    DWORD PTR [esp], 123</div><div class="line">        call    sendValue                     // Call sendValue</div><div class="line">        mov    eax, DWORD PTR [ebx]          // Load fresh value from foo-&gt;bar</div><div class="line">        mov    DWORD PTR [ebx+4], eax</div><div class="line">        ...</div></pre></td></tr></table></figure></p>
<p>正如你所看到的，有很多情况下编译器指令reordering都是被禁止的，甚至编译器必须重新从内存中reload一些值。我相信，人们一直以来之所以说在C中正确编写多线程程序时volatile并不是必要的，和这些隐藏的规则有很大的关系。<br>——&gt;Spark注：这里可能不完全正确，结合Meyers在关于DCLP的文章，有些编译器可以利用过程间分析来发现你对temp懂得小脑筋，再一次优化掉temp。还有一些编译环境会采用链接时内联的代码优化。<br>也就是说编译器对于本地函数可能有优化的手段，导致实际生产的memory ordering与你的期望不符。<br>&lt;——over</p>
<h3 id="Out-Of-Thin-Air-Stores"><a href="#Out-Of-Thin-Air-Stores" class="headerlink" title="Out-Of-Thin-Air Stores"></a>Out-Of-Thin-Air Stores</h3><p>（spark：out-of-thin-air，无中生有的，可见这种编译器技巧有多么的坑人！）<br>指令重排会导致lock-free编程变得很tricky？在C++11标准化之前，技术上没有能阻止编译器通向更加糟糕的窍门的技巧。特别的，编译器可以自由的引入对共享内存的store操作，如果目前还没有。这是一个极度简化的例子，灵感来自于Hans Boehm在多篇文章中提供的例子。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int A, B;</div><div class="line"></div><div class="line">void foo() &#123;</div><div class="line">    if (A) B++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>尽管实际中很不常见，并没有什么能阻止编译器在检查A之前将B提升到一个register，从而生成和下面等价的机器码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void foo() &#123;</div><div class="line">    register int r = B;  // Promote B to a register before checking A.</div><div class="line">    if (A)  r++;</div><div class="line">    B = r;    // Surprise! A new memory store where there previously was none.</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再一次，依然遵循了memory reordering的规则。一个单线程运行的程序依然不会察觉。但是在多线程环境下，这个函数可能会将其它线程对B的任何并发修改清除掉——即使当A为0的时候，而原始代码不会这样。这类很晦涩的技术上并非不可能的情况，正是人们说C++不支持线程的一部分原因，即使我们已经愉快的使用C/C++写了几十年的多线程和lock-free的代码。</p>
<p>我不知道是否有人在实际中踩过这种“out-of-thin-air” stores的大坑（I don’t know anyone who ever fell victim to such “out-of-thin-air” stores in practice）。可能正好因为我们趋向于写的lock-free代码，并没有大量的优化对应这种模式。如果你遇到过，希望能在评论中让我知道。</p>
<p>无论如何，新的C++11标准明确禁止了编译器的这种行为，以防止它可能引入的竞争。在最新的C++11草稿的1.10.22节：<br>Compiler transformations that introduce assignments to a potentially shared memory location that would not be modified by the abstract machine are generally precluded by this standard.<br>这句话的大意是说，对不会被抽象机器修改的潜在共享内存地址，编译器不能引入赋值操作。这样，上面的那种“无中生有”类型的store优化就被禁止了，因为它引入了对r的赋值，而实际上r是不会被抽象机器修改的内存（编译器自己引入的）。</p>
<h4 id="Why-Compiler-Reordering？"><a href="#Why-Compiler-Reordering？" class="headerlink" title="Why Compiler Reordering？"></a>Why Compiler Reordering？</h4><p>就像我在开始时指出的，编译器修改内存指令的顺序的原因和processor是一样的——性能优化。这些优化是现代CPU复杂性的直接后果。<br>后面回顾了CPU的发展历程，以及编译优化的情况。不翻译了。</p>
<p>后注：还真有人在评论中提到了“out-of-thin-air”的例子：<br><a href="http://www.airs.com/blog/archives/79，Linux" target="_blank" rel="external">http://www.airs.com/blog/archives/79，Linux</a> kernel和gcc的开发者都抱怨过这种问题。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/09/23/jvm/OrderAccess/" class="archive-article-date">
  	<time datetime="2016-09-23T03:30:40.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-09-23</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/JAVA/">JAVA</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-jvm/java-xx-command" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/23/jvm/java-xx-command/">Java 命令行---XX详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>描述Java命令行的相关命令以及用法，说明等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[Global flags]</div><div class="line">    ccstr AbortVMOnException                        =                                     &#123;notproduct&#125;Call fatal if this exception is thrown.  Example: java -XX:AbortVMOnException=java.lang.NullPointerException Foo</div><div class="line">    ccstr AbortVMOnExceptionMessage                 =                                     &#123;notproduct&#125;Call fatal if the exception pointed by AbortVMOnException has this message</div><div class="line">    uintx AdaptiveSizeDecrementScaleFactor          = 4                                   &#123;product&#125;Adaptive size scale down factor for shrinking</div><div class="line">    uintx AdaptiveSizeMajorGCDecayTimeScale         = 10                                  &#123;product&#125;Time scale over which major costs decay</div><div class="line">    uintx AdaptiveSizePausePolicy                   = 0                                   &#123;product&#125;Policy for changing generation size for pause goals</div><div class="line">    uintx AdaptiveSizePolicyCollectionCostMargin    = 50                                  &#123;product&#125;If collection costs are within margin, reduce both by full delta</div><div class="line">    uintx AdaptiveSizePolicyGCTimeLimitThreshold    = 5                                   &#123;develop&#125;Number of consecutive collections before gc time limit fires</div><div class="line">    uintx AdaptiveSizePolicyInitializingSteps       = 20                                  &#123;product&#125;Number of steps where heuristics is used before data is used</div><div class="line">    uintx AdaptiveSizePolicyOutputInterval          = 0                                   &#123;product&#125;Collection interval for printing information; zero means never</div><div class="line">    uintx AdaptiveSizePolicyReadyThreshold          = 5                                   &#123;develop&#125;Number of collections before the adaptive sizing is started</div><div class="line">    uintx AdaptiveSizePolicyWeight                  = 10                                  &#123;product&#125;Weight given to exponential resizing, between 0 and 100</div><div class="line">    uintx AdaptiveSizeThroughPutPolicy              = 0                                   &#123;product&#125;Policy for changing generation size for throughput goals</div><div class="line">    uintx AdaptiveTimeWeight                        = 25                                  &#123;product&#125;Weight given to time in adaptive policy, between 0 and 100</div><div class="line">     bool AdjustConcurrency                         = false                               &#123;product&#125;Call thr_setconcurrency at thread creation time to avoid LWP starvation on MP systems (for Solaris Only)</div><div class="line">     bool AggressiveOpts                            = false                               &#123;product&#125;Enable aggressive optimizations - see arguments.cpp</div><div class="line">     intx AliasLevel                                = 3                                   &#123;C2 product&#125;0 for no aliasing, 1 for oop/field/static/array split, 2 for class split, 3 for unique instances</div><div class="line">     bool AlignVector                               = true                                &#123;C2 product&#125;Perform vector store/load alignment in loop</div><div class="line">     intx AllocateInstancePrefetchLines             = 1                                   &#123;product&#125;Number of lines to prefetch ahead of instance allocation pointer</div><div class="line">     intx AllocatePrefetchDistance                  = -1                                  &#123;product&#125;Distance to prefetch ahead of allocation pointer</div><div class="line">     intx AllocatePrefetchInstr                     = 0                                   &#123;product&#125;Prefetch instruction to prefetch ahead of allocation pointer</div><div class="line">     intx AllocatePrefetchLines                     = 3                                   &#123;product&#125;Number of lines to prefetch ahead of array allocation pointer</div><div class="line">     intx AllocatePrefetchStepSize                  = 16                                  &#123;product&#125;Step size in bytes of sequential prefetch instructions</div><div class="line">     intx AllocatePrefetchStyle                     = 1                                   &#123;product&#125;0 = no prefetch, 1 = prefetch instructions for each allocation, 2 = use TLAB watermark to gate allocation prefetch, 3 = use BIS instruction on Sparc for allocation prefetch</div><div class="line">     bool AllowJNIEnvProxy                          = false                               &#123;product&#125;Allow JNIEnv proxies for jdbx</div><div class="line">     bool AllowNonVirtualCalls                      = false                               &#123;product&#125;Obey the ACC_SUPER flag and allow invokenonvirtual calls</div><div class="line">     bool AllowParallelDefineClass                  = false                               &#123;product&#125;Allow parallel defineClass requests for class loaders registering as parallel capable</div><div class="line">     bool AllowUserSignalHandlers                   = false                               &#123;product&#125;Do not complain if the application installs signal handlers (Solaris &amp; Linux only)</div><div class="line">     bool AlwaysActAsServerClassMachine             = false                               &#123;product&#125;Always act like a server-class machine</div><div class="line">     bool AlwaysCompileLoopMethods                  = false                               &#123;product&#125;When using recompilation, never interpret methods containing loops</div><div class="line">     bool AlwaysIncrementalInline                   = false                               &#123;C2 develop&#125;do all inlining incrementally</div><div class="line">     bool AlwaysLockClassLoader                     = false                               &#123;product&#125;Require the VM to acquire the class loader lock before calling loadClass() even for class loaders registering as parallel capable</div><div class="line">     bool AlwaysPreTouch                            = false                               &#123;product&#125;Force all freshly committed pages to be pre-touched</div><div class="line">     bool AlwaysRestoreFPU                          = false                               &#123;product&#125;Restore the FPU control word after every JNI call (expensive)</div><div class="line">     bool AlwaysTenure                              = false                               &#123;product&#125;Always tenure objects in eden (ParallelGC only)</div><div class="line">     bool AssertOnSuspendWaitFailure                = false                               &#123;product&#125;Assert/Guarantee on external suspend wait failure</div><div class="line">     bool AssertRangeCheckElimination               = false                               &#123;C1 develop&#125;Assert Range Check Elimination</div><div class="line">     intx AssertRepeat                              = 1                                   &#123;notproduct&#125;number of times to evaluate expression in assert (to estimate overhead); only works with -DUSE_REPEATED_ASSERTS</div><div class="line">     bool AssumeMP                                  = false                               &#123;product&#125;Instruct the VM to assume multiple processors are available</div><div class="line">     intx AutoBoxCacheMax                           = 128                                 &#123;C2 product&#125;Sets max value cached by the java.lang.Integer autobox cache</div><div class="line">    uintx AutoGCSelectPauseMillis                   = 5000                                &#123;product&#125;Automatic GC selection pause threshold in milliseconds</div><div class="line">     intx BCEATraceLevel                            = 0                                   &#123;product&#125;How much tracing to do of bytecode escape analysis estimates</div><div class="line">     intx BackEdgeThreshold                         = 100000                              &#123;pd product&#125;Interpreter Back edge threshold at which an OSR compilation is invoked</div><div class="line">     bool BackgroundCompilation                     = true                                &#123;pd product&#125;A thread requesting compilation is not blocked during compilation</div><div class="line">     bool BailoutAfterHIR                           = false                               &#123;C1 develop&#125;bailout of compilation after building of HIR</div><div class="line">     bool BailoutAfterLIR                           = false                               &#123;C1 develop&#125;bailout of compilation after building of LIR</div><div class="line">     bool BailoutOnExceptionHandlers                = false                               &#123;C1 develop&#125;bailout of compilation for methods with exception handlers</div><div class="line">     bool BailoutToInterpreterForThrows             = false                               &#123;C2 develop&#125;Compiled methods which throws/catches exceptions will be deopt and intp.</div><div class="line">    uintx BaseFootPrintEstimate                     = 268435456                           &#123;product&#125;Estimate of footprint other than Java Heap</div><div class="line">     intx BciProfileWidth                           = 2                                   &#123;develop&#125;Number of return bci&apos;s to record in ret profile</div><div class="line">     intx BiasedLockingBulkRebiasThreshold          = 20                                  &#123;product&#125;Threshold of number of revocations per type to try to rebias all objects in the heap of that type</div><div class="line">     intx BiasedLockingBulkRevokeThreshold          = 40                                  &#123;product&#125;Threshold of number of revocations per type to permanently revoke biases of all objects in the heap of that type</div><div class="line">     intx BiasedLockingDecayTime                    = 25000                               &#123;product&#125;Decay time (in milliseconds) to re-enable bulk rebiasing of a type after previous bulk rebias</div><div class="line">     intx BiasedLockingStartupDelay                 = 4000                                &#123;product&#125;Number of milliseconds to wait before enabling biased locking</div><div class="line">     intx BinarySwitchThreshold                     = 5                                   &#123;develop&#125;Minimal number of lookupswitch entries for rewriting to binary switch</div><div class="line">     bool BindCMSThreadToCPU                        = false                               &#123;diagnostic&#125;Bind CMS Thread to CPU if possible</div><div class="line">     bool BindGCTaskThreadsToCPUs                   = false                               &#123;product&#125;Bind GCTaskThreads to CPUs if possible</div><div class="line">     bool BlockLayoutByFrequency                    = true                                &#123;C2 product&#125;Use edge frequencies to drive block ordering</div><div class="line">     intx BlockLayoutMinDiamondPercentage           = 20                                  &#123;C2 product&#125;Miniumum %% of a successor (predecessor) for which block layout a will allow a fork (join) in a single chain</div><div class="line">     bool BlockLayoutRotateLoops                    = true                                &#123;C2 product&#125;Allow back branches to be fall throughs in the block layour</div><div class="line">     bool BlockOffsetArrayUseUnallocatedBlock       = false                               &#123;diagnostic&#125;Maintain _unallocated_block in BlockOffsetArray (currently applicable only to CMS collector)</div><div class="line">     bool BranchOnRegister                          = false                               &#123;C2 product&#125;Use Sparc V9 branch-on-register opcodes</div><div class="line">     intx BreakAtNode                               = 0                                   &#123;C2 notproduct&#125;Break at construction of this Node (either _idx or _debug_idx)</div><div class="line">     bool BreakAtWarning                            = false                               &#123;develop&#125;Execute breakpoint upon encountering VM warning</div><div class="line">     bool BytecodeVerificationLocal                 = false                               &#123;product&#125;Enable the Java bytecode verifier for local classes</div><div class="line">     bool BytecodeVerificationRemote                = true                                &#123;product&#125;Enable the Java bytecode verifier for remote classes</div><div class="line">     bool C1Breakpoint                              = false                               &#123;C1 develop&#125;Sets a breakpoint at entry of each compiled method</div><div class="line">     bool C1OptimizeVirtualCallProfiling            = true                                &#123;C1 product&#125;Use CHA and exact type results at call sites when updating MDOs</div><div class="line">     bool C1PatchInvokeDynamic                      = true                                &#123;C1 diagnostic&#125;Patch invokedynamic appendix not known at compile time</div><div class="line">     bool C1ProfileBranches                         = true                                &#123;C1 product&#125;Profile branches when generating code for updating MDOs</div><div class="line">     bool C1ProfileCalls                            = true                                &#123;C1 product&#125;Profile calls when generating code for updating MDOs</div><div class="line">     bool C1ProfileCheckcasts                       = true                                &#123;C1 product&#125;Profile checkcasts when generating code for updating MDOs</div><div class="line">     bool C1ProfileInlinedCalls                     = true                                &#123;C1 product&#125;Profile inlined calls when generating code for updating MDOs</div><div class="line">     bool C1ProfileVirtualCalls                     = true                                &#123;C1 product&#125;Profile virtual calls when generating code for updating MDOs</div><div class="line">     bool C1UpdateMethodData                        = true                                &#123;C1 product&#125;Update MethodData*s in Tier1-generated code</div><div class="line">     intx CIBreakAt                                 = -1                                  &#123;develop&#125;The id of compilation to break at</div><div class="line">     intx CIBreakAtOSR                              = -1                                  &#123;develop&#125;The id of osr compilation to break at</div><div class="line">     bool CICompileNatives                          = true                                &#123;develop&#125;compile native methods if supported by the compiler</div><div class="line">     bool CICompileOSR                              = true                                &#123;pd develop&#125;compile on stack replacement methods if supported by the compiler</div><div class="line">     intx CICompilerCount                           = 2                                   &#123;product&#125;Number of compiler threads to run</div><div class="line">     bool CICompilerCountPerCPU                     = false                               &#123;product&#125;1 compiler thread for log(N CPUs)</div><div class="line">     bool CICountOSR                                = false                               &#123;develop&#125;use a separate counter when assigning ids to osr compilations</div><div class="line">     intx CICrashAt                                 = -1                                  &#123;notproduct&#125;id of compilation to trigger assert in compiler thread for the purpose of testing, e.g. generation of replay data</div><div class="line">     intx CIFireOOMAt                               = -1                                  &#123;develop&#125;Fire OutOfMemoryErrors throughout CI for testing the compiler (non-negative value throws OOM after this many CI accesses in each compile)</div><div class="line">     bool CIObjectFactoryVerify                     = false                               &#123;notproduct&#125;enable potentially expensive verification in ciObjectFactory</div><div class="line">     bool CIPrintCompileQueue                       = false                               &#123;develop&#125;display the contents of the compile queue whenever a compilation is enqueued</div><div class="line">     bool CIPrintCompilerName                       = false                               &#123;develop&#125;when CIPrint is active, print the name of the active compiler</div><div class="line">     bool CIPrintMethodCodes                        = false                               &#123;develop&#125;print method bytecodes of the compiled code</div><div class="line">     bool CIPrintRequests                           = false                               &#123;develop&#125;display every request for compilation</div><div class="line">     bool CIPrintTypeFlow                           = false                               &#123;develop&#125;print the results of ciTypeFlow analysis</div><div class="line">     intx CIStart                                   = 0                                   &#123;develop&#125;The id of the first compilation to permit</div><div class="line">     intx CIStartOSR                                = 0                                   &#123;develop&#125;The id of the first osr compilation to permit (CICountOSR must be on)</div><div class="line">     intx CIStop                                    = 2147483647                          &#123;develop&#125;The id of the last compilation to permit</div><div class="line">     intx CIStopOSR                                 = 2147483647                          &#123;develop&#125;The id of the last osr compilation to permit (CICountOSR must be on)</div><div class="line">     bool CITime                                    = false                               &#123;product&#125;collect timing information for compilation</div><div class="line">     bool CITimeEach                                = false                               &#123;develop&#125;display timing information after each successful compilation</div><div class="line">     bool CITraceTypeFlow                           = false                               &#123;develop&#125;detailed per-bytecode tracing of ciTypeFlow analysis</div><div class="line">     bool CMSAbortSemantics                         = false                               &#123;product&#125;Whether abort-on-overflow semantics is implemented</div><div class="line">    uintx CMSAbortablePrecleanMinWorkPerIteration   = 100                                 &#123;product&#125;(Temporary, subject to experimentation) Nominal minimum work per abortable preclean iteration</div><div class="line">     intx CMSAbortablePrecleanWaitMillis            = 100                                 &#123;manageable&#125;(Temporary, subject to experimentation) Time that we sleep between iterations when not given enough work per iteration</div><div class="line">    uintx CMSBitMapYieldQuantum                     = 10485760                            &#123;product&#125;Bitmap operations should process at most this many bits between yields</div><div class="line">    uintx CMSBootstrapOccupancy                     = 50                                  &#123;product&#125;Percentage CMS generation occupancy at which to initiate CMS collection for bootstrapping collection stats</div><div class="line">    uintx CMSCheckInterval                          = 1000                                &#123;develop&#125;Interval in milliseconds that CMS thread checks if it should start a collection cycle</div><div class="line">     bool CMSClassUnloadingEnabled                  = true                                &#123;product&#125;Whether class unloading enabled when using CMS GC</div><div class="line">    uintx CMSClassUnloadingMaxInterval              = 0                                   &#123;product&#125;When CMS class unloading is enabled, the maximum CMS cycle count for which classes may not be unloaded</div><div class="line">     bool CMSCleanOnEnter                           = true                                &#123;product&#125;Clean-on-enter optimization for reducing number of dirty cards</div><div class="line">     bool CMSCompactWhenClearAllSoftRefs            = true                                &#123;product&#125;Compact when asked to collect CMS gen with clear_all_soft_refs()</div><div class="line">    uintx CMSConcMarkMultiple                       = 32                                  &#123;product&#125;Size (in cards) of CMS concurrent MT marking task</div><div class="line">     bool CMSConcurrentMTEnabled                    = true                                &#123;product&#125;Whether multi-threaded concurrent work enabled (effective only if ParNewGC)</div><div class="line">    uintx CMSCoordinatorYieldSleepCount             = 10                                  &#123;product&#125;Number of times the coordinator GC thread will sleep while yielding before giving up and resuming GC</div><div class="line">     intx CMSDictionaryChoice                       = 0                                   &#123;develop&#125;Use BinaryTreeDictionary as default in the CMS generation</div><div class="line">     bool CMSDumpAtPromotionFailure                 = false                               &#123;product&#125;Dump useful information about the state of the CMS old generation upon a promotion failure</div><div class="line">     bool CMSEdenChunksRecordAlways                 = true                                &#123;product&#125;Always record eden chunks used for the parallel initial mark or remark of eden</div><div class="line">    uintx CMSExpAvgFactor                           = 50                                  &#123;product&#125;Percentage (0-100) used to weigh the current sample when computing exponential averages for CMS statistics</div><div class="line">     bool CMSExtrapolateSweep                       = false                               &#123;product&#125;CMS: cushion for block demand during sweep</div><div class="line">    uintx CMSFullGCsBeforeCompaction                = 0                                   &#123;product&#125;Number of CMS full collection done before compaction if &gt; 0</div><div class="line">    uintx CMSIncrementalDutyCycle                   = 10                                  &#123;product&#125;Percentage (0-100) of CMS incremental mode duty cycle. If CMSIncrementalPacing is enabled, then this is just the initial value.</div><div class="line">    uintx CMSIncrementalDutyCycleMin                = 0                                   &#123;product&#125;Minimum percentage (0-100) of the CMS incremental duty cycle used when CMSIncrementalPacing is enabled</div><div class="line">     bool CMSIncrementalMode                        = false                               &#123;product&#125;Whether CMS GC should operate in &quot;incremental&quot; mode</div><div class="line">    uintx CMSIncrementalOffset                      = 0                                   &#123;product&#125;Percentage (0-100) by which the CMS incremental mode duty cycle is shifted to the right within the period between young GCs</div><div class="line">     bool CMSIncrementalPacing                      = true                                &#123;product&#125;Whether the CMS incremental mode duty cycle should be automatically adjusted</div><div class="line">    uintx CMSIncrementalSafetyFactor                = 10                                  &#123;product&#125;Percentage (0-100) used to add conservatism when computing the duty cycle</div><div class="line">    uintx CMSIndexedFreeListReplenish               = 4                                   &#123;product&#125;Replenish an indexed free list with this number of chunks</div><div class="line">     intx CMSInitiatingOccupancyFraction            = -1                                  &#123;product&#125;Percentage CMS generation occupancy to start a CMS collection cycle. A negative value means that CMSTriggerRatio is used</div><div class="line">    uintx CMSIsTooFullPercentage                    = 98                                  &#123;product&#125;An absolute ceiling above which CMS will always consider the unloading of classes when class unloading is enabled</div><div class="line">   double CMSLargeCoalSurplusPercent                = 0.950000                            &#123;product&#125;CMS: the factor by which to inflate estimated demand of large block sizes to prevent coalescing with an adjoining block</div><div class="line">   double CMSLargeSplitSurplusPercent               = 1.000000                            &#123;product&#125;CMS: the factor by which to inflate estimated demand of large block sizes to prevent splitting to supply demand for smaller blocks</div><div class="line">     bool CMSLoopWarn                               = false                               &#123;product&#125;Warn in case of excessive CMS looping</div><div class="line">     bool CMSMarkStackOverflowALot                  = false                               &#123;notproduct&#125;Simulate frequent marking stack / work queue overflow</div><div class="line">    uintx CMSMarkStackOverflowInterval              = 1000                                &#123;notproduct&#125;An &quot;interval&quot; counter that determines how frequently to simulate overflow; a smaller number increases frequency</div><div class="line">    uintx CMSMaxAbortablePrecleanLoops              = 0                                   &#123;product&#125;(Temporary, subject to experimentation) Maximum number of abortable preclean iterations, if &gt; 0</div><div class="line">     intx CMSMaxAbortablePrecleanTime               = 5000                                &#123;product&#125;(Temporary, subject to experimentation) Maximum time in abortable preclean (in milliseconds)</div><div class="line">    uintx CMSOldPLABMax                             = 1024                                &#123;product&#125;Maximum size of CMS gen promotion LAB caches per worker per block size</div><div class="line">    uintx CMSOldPLABMin                             = 16                                  &#123;product&#125;Minimum size of CMS gen promotion LAB caches per worker per block size</div><div class="line">    uintx CMSOldPLABNumRefills                      = 4                                   &#123;product&#125;Nominal number of refills of CMS gen promotion LAB cache per worker per block size</div><div class="line">    uintx CMSOldPLABReactivityFactor                = 2                                   &#123;product&#125;The gain in the feedback loop for on-the-fly PLAB resizing during a scavenge</div><div class="line">     bool CMSOldPLABResizeQuicker                   = false                               &#123;product&#125;React on-the-fly during a scavenge to a sudden change in block demand rate</div><div class="line">    uintx CMSOldPLABToleranceFactor                 = 4                                   &#123;product&#125;The tolerance of the phase-change detector for on-the-fly PLAB resizing during a scavenge</div><div class="line">     bool CMSOverflowEarlyRestoration               = false                               &#123;develop&#125;Restore preserved marks early</div><div class="line">     bool CMSPLABRecordAlways                       = true                                &#123;product&#125;Always record survivor space PLAB boundaries (effective only if CMSParallelSurvivorRemarkEnabled)</div><div class="line">    uintx CMSParPromoteBlocksToClaim                = 16                                  &#123;product&#125;Number of blocks to attempt to claim when refilling CMS LAB&apos;s for parallel GC</div><div class="line">     bool CMSParallelInitialMarkEnabled             = true                                &#123;product&#125;Use the parallel initial mark.</div><div class="line">     bool CMSParallelRemarkEnabled                  = true                                &#123;product&#125;Whether parallel remark enabled (only if ParNewGC)</div><div class="line">     bool CMSParallelSurvivorRemarkEnabled          = true                                &#123;product&#125;Whether parallel remark of survivor space enabled (effective only if CMSParallelRemarkEnabled)</div><div class="line">    uintx CMSPrecleanDenominator                    = 3                                   &#123;product&#125;CMSPrecleanNumerator:CMSPrecleanDenominator yields convergence ratio</div><div class="line">    uintx CMSPrecleanIter                           = 3                                   &#123;product&#125;Maximum number of precleaning iteration passes</div><div class="line">    uintx CMSPrecleanNumerator                      = 2                                   &#123;product&#125;CMSPrecleanNumerator:CMSPrecleanDenominator yields convergence ratio</div><div class="line">     bool CMSPrecleanRefLists1                      = true                                &#123;product&#125;Preclean ref lists during (initial) preclean phase</div><div class="line">     bool CMSPrecleanRefLists2                      = false                               &#123;product&#125;Preclean ref lists during abortable preclean phase</div><div class="line">     bool CMSPrecleanSurvivors1                     = false                               &#123;product&#125;Preclean survivors during (initial) preclean phase</div><div class="line">     bool CMSPrecleanSurvivors2                     = true                                &#123;product&#125;Preclean survivors during abortable preclean phase</div><div class="line">    uintx CMSPrecleanThreshold                      = 1000                                &#123;product&#125;Do not iterate again if number of dirty cards is less than this</div><div class="line">     bool CMSPrecleaningEnabled                     = true                                &#123;product&#125;Whether concurrent precleaning enabled</div><div class="line">     bool CMSPrintChunksInDump                      = false                               &#123;product&#125;In a dump enabled by CMSDumpAtPromotionFailure, include more detailed information about the free chunks</div><div class="line">     bool CMSPrintEdenSurvivorChunks                = false                               &#123;product&#125;Print the eden and the survivor chunks used for the parallel initial mark or remark of the eden/survivor spaces</div><div class="line">     bool CMSPrintObjectsInDump                     = false                               &#123;product&#125;In a dump enabled by CMSDumpAtPromotionFailure, include more detailed information about the allocated objects</div><div class="line">    uintx CMSRemarkVerifyVariant                    = 1                                   &#123;product&#125;Choose variant (1,2) of verification following remark</div><div class="line">     bool CMSReplenishIntermediate                  = true                                &#123;product&#125;Replenish all intermediate free-list caches</div><div class="line">    uintx CMSRescanMultiple                         = 32                                  &#123;product&#125;Size (in cards) of CMS parallel rescan task</div><div class="line">    uintx CMSSamplingGrain                          = 16384                               &#123;product&#125;The minimum distance between eden samples for CMS (see above)</div><div class="line">     bool CMSScavengeBeforeRemark                   = false                               &#123;product&#125;Attempt scavenge before the CMS remark step</div><div class="line">    uintx CMSScheduleRemarkEdenPenetration          = 50                                  &#123;product&#125;The Eden occupancy percentage (0-100) at which to try and schedule remark pause</div><div class="line">    uintx CMSScheduleRemarkEdenSizeThreshold        = 2097152                             &#123;product&#125;If Eden size is below this, do not try to schedule remark</div><div class="line">    uintx CMSScheduleRemarkSamplingRatio            = 5                                   &#123;product&#125;Start sampling eden top at least before young gen occupancy reaches 1/&lt;ratio&gt; of the size at which we plan to schedule remark</div><div class="line">   double CMSSmallCoalSurplusPercent                = 1.050000                            &#123;product&#125;CMS: the factor by which to inflate estimated demand of small block sizes to prevent coalescing with an adjoining block</div><div class="line">   double CMSSmallSplitSurplusPercent               = 1.100000                            &#123;product&#125;CMS: the factor by which to inflate estimated demand of small block sizes to prevent splitting to supply demand for smaller blocks</div><div class="line">     bool CMSSplitIndexedFreeListBlocks             = true                                &#123;product&#125;When satisfying batched demand, split blocks from the IndexedFreeList whose size is a multiple of requested size</div><div class="line">     bool CMSTestInFreeList                         = false                               &#123;develop&#125;Check if the coalesced range is already in the free lists as claimed</div><div class="line">     bool CMSTraceIncrementalMode                   = false                               &#123;develop&#125;Trace CMS incremental mode</div><div class="line">     bool CMSTraceIncrementalPacing                 = false                               &#123;develop&#125;Trace CMS incremental mode pacing computation</div><div class="line">     bool CMSTraceSweeper                           = false                               &#123;develop&#125;Trace some actions of the CMS sweeper</div><div class="line">     bool CMSTraceThreadState                       = false                               &#123;develop&#125;Trace the CMS thread state (enable the trace_state() method)</div><div class="line">     intx CMSTriggerInterval                        = -1                                  &#123;manageable&#125;Commence a CMS collection cycle (at least) every so many milliseconds (0 permanently, -1 disabled)</div><div class="line">    uintx CMSTriggerRatio                           = 80                                  &#123;product&#125;Percentage of MinHeapFreeRatio in CMS generation that is allocated before a CMS collection cycle commences</div><div class="line">     bool CMSVerifyReturnedBytes                    = false                               &#123;notproduct&#125;Check that all the garbage collected was returned to the free lists</div><div class="line">     intx CMSWaitDuration                           = 2000                                &#123;manageable&#125;Time in milliseconds that CMS thread waits for young GC</div><div class="line">    uintx CMSWorkQueueDrainThreshold                = 10                                  &#123;product&#125;Don&apos;t drain below this size per parallel worker/thief</div><div class="line">     bool CMSYield                                  = true                                &#123;product&#125;Yield between steps of CMS</div><div class="line">    uintx CMSYieldSleepCount                        = 0                                   &#123;product&#125;Number of times a GC thread (minus the coordinator) will sleep while yielding before giving up and resuming GC</div><div class="line">    uintx CMSYoungGenPerWorker                      = 67108864                            &#123;pd product&#125;The maximum size of young gen chosen by default per GC worker thread available</div><div class="line">    uintx CMS_FLSPadding                            = 1                                   &#123;product&#125;The multiple of deviation from mean to use for buffering against volatility in free list demand</div><div class="line">    uintx CMS_FLSWeight                             = 75                                  &#123;product&#125;Percentage (0-100) used to weigh the current sample when computing exponentially decaying averages for CMS FLS statistics</div><div class="line">    uintx CMS_SweepPadding                          = 1                                   &#123;product&#125;The multiple of deviation from mean to use for buffering against volatility in inter-sweep duration</div><div class="line">    uintx CMS_SweepTimerThresholdMillis             = 10                                  &#123;product&#125;Skip block flux-rate sampling for an epoch unless inter-sweep duration exceeds this threshold in milliseconds</div><div class="line">    uintx CMS_SweepWeight                           = 75                                  &#123;product&#125;Percentage (0-100) used to weight the current sample when computing exponentially decaying average for inter-sweep duration</div><div class="line">    uintx CPUForCMSThread                           = 0                                   &#123;diagnostic&#125;When BindCMSThreadToCPU is true, the CPU to bind CMS thread to</div><div class="line">     bool CSEArrayLength                            = false                               &#123;C1 pd develop&#125;Create separate nodes for length in array accesses</div><div class="line">     bool CanonicalizeNodes                         = true                                &#123;C1 develop&#125;Canonicalize graph nodes</div><div class="line">     bool CheckAssertionStatusDirectives            = false                               &#123;notproduct&#125;Temporary - see javaClasses.cpp</div><div class="line">     bool CheckCompressedOops                       = true                                &#123;notproduct&#125;Generate checks in encoding/decoding code in debug VM</div><div class="line">     bool CheckEndorsedAndExtDirs                   = false                               &#123;product&#125;Verify the endorsed and extension directories are not used</div><div class="line">     bool CheckJNICalls                             = false                               &#123;product&#125;Verify all arguments to JNI calls</div><div class="line">     bool CheckMemoryInitialization                 = false                               &#123;notproduct&#125;Check memory initialization</div><div class="line">     bool CheckOopishValues                         = false                               &#123;notproduct&#125;Warn if value contains oop (requires ZapDeadLocals)</div><div class="line">     bool CheckUnhandledOops                        = false                               &#123;develop&#125;Check for unhandled oops in VM code</div><div class="line">     bool CheckZapUnusedHeapArea                    = false                               &#123;develop&#125;Check zapping of unused heap space</div><div class="line">     bool ClassUnloading                            = true                                &#123;product&#125;Do unloading of classes</div><div class="line">     bool ClassUnloadingWithConcurrentMark          = true                                &#123;product&#125;Do unloading of classes with a concurrent marking cycle</div><div class="line">     bool CleanChunkPoolAsync                       = true                                &#123;develop&#125;Clean the chunk pool asynchronously</div><div class="line">     intx ClearFPUAtPark                            = 0                                   &#123;product&#125;(Unsafe, Unstable)</div><div class="line">     bool ClearInterpreterLocals                    = false                               &#123;develop&#125;Always clear local variables of interpreter activations upon entry</div><div class="line">     bool ClipInlining                              = true                                &#123;product&#125;Clip inlining if aggregate method exceeds DesiredMethodLimit</div><div class="line">    uintx CodeCacheExpansionSize                    = 65536                               &#123;pd product&#125;Code cache expansion size (in bytes)</div><div class="line">    uintx CodeCacheMinBlockLength                   = 4                                   &#123;pd develop&#125;Minimum number of segments in a code cache block</div><div class="line">    uintx CodeCacheMinimumFreeSpace                 = 512000                              &#123;product&#125;When less than X space left, we stop compiling</div><div class="line">    uintx CodeCacheMinimumUseSpace                  = 409600                              &#123;pd develop&#125;Minimum code cache size (in bytes) required to start VM.</div><div class="line">    uintx CodeCacheSegmentSize                      = 64                                  &#123;develop&#125;Code cache segment size (in bytes) - smallest unit of allocation</div><div class="line">     intx CodeEntryAlignment                        = 32                                  &#123;pd develop&#125;Code entry alignment for generated code (in bytes)</div><div class="line">     bool CollectGen0First                          = false                               &#123;product&#125;Collect youngest generation before each full GC</div><div class="line">     bool CollectIndexSetStatistics                 = false                               &#123;notproduct&#125;Collect information about IndexSets</div><div class="line">     bool CommentedAssembly                         = true                                &#123;C1 develop&#125;Show extra info in PrintNMethods output</div><div class="line">     bool CompactFields                             = true                                &#123;product&#125;Allocate nonstatic fields in gaps between previous fields</div><div class="line">     intx CompilationPolicyChoice                   = 0                                   &#123;product&#125;which compilation policy (0/1)</div><div class="line">ccstrlist CompileCommand                            =                                     &#123;product&#125;Prepend to .hotspot_compiler; e.g. log,java/lang/String.&lt;init&gt;</div><div class="line">    ccstr CompileCommandFile                        =                                     &#123;product&#125;Read compiler commands from this file [.hotspot_compiler]</div><div class="line">ccstrlist CompileOnly                               =                                     &#123;product&#125;List of methods (pkg/class.name) to restrict compilation to</div><div class="line">     bool CompileTheWorld                           = false                               &#123;develop&#125;Compile all methods in all classes in bootstrap class path (stress test)</div><div class="line">     bool CompileTheWorldPreloadClasses             = true                                &#123;develop&#125;Preload all classes used by a class before start loading</div><div class="line">     intx CompileTheWorldSafepointInterval          = 100                                 &#123;notproduct&#125;Force a safepoint every n compiles so sweeper can keep up</div><div class="line">     intx CompileTheWorldStartAt                    = 1                                   &#123;notproduct&#125;First class to consider when using +CompileTheWorld</div><div class="line">     intx CompileTheWorldStopAt                     = 2147483647                          &#123;notproduct&#125;Last class to consider when using +CompileTheWorld</div><div class="line">     intx CompileThreshold                          = 10000                               &#123;pd product&#125;number of interpreted method invocations before (re-)compiling</div><div class="line">     intx CompileZapFirst                           = 0                                   &#123;C2 notproduct&#125;If +ZapDeadCompiledLocals, skip this many before compiling in zap calls</div><div class="line">     intx CompileZapLast                            = -1                                  &#123;C2 notproduct&#125;If +ZapDeadCompiledLocals, compile this many after skipping (incl. skip count, -1 = all)</div><div class="line">     bool CompilerThreadHintNoPreempt               = true                                &#123;product&#125;(Solaris only) Give compiler threads an extra quanta</div><div class="line">     intx CompilerThreadPriority                    = -1                                  &#123;product&#125;The native priority at which compiler threads should run (-1 means no change)</div><div class="line">     intx CompilerThreadStackSize                   = 0                                   &#123;pd product&#125;Compiler Thread Stack Size (in Kbytes)</div><div class="line">    uintx CompressedClassSpaceSize                  = 1073741824                          &#123;product&#125;Maximum size of class area in Metaspace when compressed class pointers are used</div><div class="line">     bool ComputeExactFPURegisterUsage              = true                                &#123;C1 develop&#125;Compute additional live set for fpu registers to simplify fpu stack merge (Intel only)</div><div class="line">    uintx ConcGCThreads                             = 0                                   &#123;product&#125;Number of threads concurrent gc will use</div><div class="line">     intx ConcGCYieldTimeout                        = 0                                   &#123;develop&#125;If non-zero, assert that GC threads yield within this number of milliseconds</div><div class="line">     intx ConditionalMoveLimit                      = 3                                   &#123;C2 pd product&#125;Limit of ops to make speculative when using CMOVE</div><div class="line">     intx ContendedPaddingWidth                     = 128                                 &#123;product&#125;How many bytes to pad the fields/classes marked @Contended with</div><div class="line">     bool ConvertCmpD2CmpF                          = true                                &#123;C2 develop&#125;Convert cmpD to cmpF when one input is constant in float range</div><div class="line">     bool ConvertFloat2IntClipping                  = true                                &#123;C2 develop&#125;Convert float2int clipping idiom to integer clipping</div><div class="line">     bool ConvertSleepToYield                       = true                                &#123;pd product&#125;Convert sleep(0) to thread yield (may be off for Solaris to improve GUI)</div><div class="line">     bool ConvertYieldToSleep                       = false                               &#123;product&#125;Convert yield to a sleep of MinSleepInterval to simulate Win32 behavior (Solaris only)</div><div class="line">     bool CountBytecodes                            = false                               &#123;develop&#125;Count number of bytecodes executed</div><div class="line">     bool CountCompiledCalls                        = false                               &#123;develop&#125;Count method invocations</div><div class="line">     bool CountJNICalls                             = false                               &#123;develop&#125;Count jni method invocations</div><div class="line">     bool CountJVMCalls                             = false                               &#123;notproduct&#125;Count jvm method invocations</div><div class="line">     bool CountLinearScan                           = false                               &#123;C1 develop&#125;collect statistic counters during LinearScan</div><div class="line">     bool CountRemovableExceptions                  = false                               &#123;notproduct&#125;Count exceptions that could be replaced by branches due to inlining</div><div class="line">     bool CountRuntimeCalls                         = false                               &#123;notproduct&#125;Count VM runtime calls</div><div class="line">     intx CounterDecayMinIntervalLength             = 500                                 &#123;develop&#125;The minimum interval (in milliseconds) between invocation of CounterDecay</div><div class="line">     intx CounterHalfLifeTime                       = 30                                  &#123;develop&#125;Half-life time of invocation counters (in seconds)</div><div class="line">     bool CrashGCForDumpingJavaThread               = false                               &#123;notproduct&#125;Manually make GC thread crash then dump java stack trace;  Test only</div><div class="line">     bool CrashOnOutOfMemoryError                   = false                               &#123;product&#125;JVM aborts, producing an error log and core/mini dump, on the first occurrence of an out-of-memory error</div><div class="line">     bool CreateMinidumpOnCrash                     = false                               &#123;product&#125;Create minidump on VM fatal error</div><div class="line">     bool CriticalJNINatives                        = true                                &#123;product&#125;Check for critical JNI entry points</div><div class="line">     bool DTraceAllocProbes                         = false                               &#123;product&#125;Enable dtrace probes for object allocation</div><div class="line">     bool DTraceMethodProbes                        = false                               &#123;product&#125;Enable dtrace probes for method-entry and method-exit</div><div class="line">     bool DTraceMonitorProbes                       = false                               &#123;product&#125;Enable dtrace probes for monitor events</div><div class="line">     bool DebugDeoptimization                       = false                               &#123;develop&#125;Tracing various information while debugging deoptimization</div><div class="line">     bool DebugInlinedCalls                         = true                                &#123;C2 diagnostic&#125;If false, restricts profiled locations to the root method only</div><div class="line">     bool DebugNonSafepoints                        = true                                &#123;diagnostic&#125;Generate extra debugging information for non-safepoints in nmethods</div><div class="line">     bool DebugVtables                              = false                               &#123;develop&#125;add debugging code to vtable dispatch</div><div class="line">     bool Debugging                                 = false                               &#123;product&#125;Set when executing debug methods in debug.cpp (to prevent triggering assertions)</div><div class="line">    uintx DefaultMaxRAMFraction                     = 4                                   &#123;product&#125;Maximum fraction (1/n) of real memory used for maximum heap size; deprecated: to be renamed to MaxRAMFraction</div><div class="line">     intx DefaultThreadPriority                     = -1                                  &#123;product&#125;The native priority at which threads run if not elsewhere specified (-1 means no change)</div><div class="line">     bool DeferInitialCardMark                      = false                               &#123;diagnostic&#125;When +ReduceInitialCardMarks, explicitly defer any that may arise from new_pre_store_barrier</div><div class="line">     intx DeferPollingPageLoopCount                 = -1                                  &#123;product&#125;(Unsafe,Unstable) Number of iterations in safepoint loop before changing safepoint polling page to RO </div><div class="line">     intx DeferThrSuspendLoopCount                  = 4000                                &#123;product&#125;(Unstable) Number of times to iterate in safepoint loop before blocking VM threads </div><div class="line">     bool DelayCompilationDuringStartup             = true                                &#123;develop&#125;Delay invoking the compiler until main application class is loaded</div><div class="line">     bool DeoptC1                                   = true                                &#123;C1 develop&#125;Use deoptimization in C1</div><div class="line">     bool DeoptimizeALot                            = false                               &#123;develop&#125;Deoptimize at every exit from the runtime system</div><div class="line">     intx DeoptimizeALotInterval                    = 5                                   &#123;notproduct&#125;Number of exits until DeoptimizeALot kicks in</div><div class="line">ccstrlist DeoptimizeOnlyAt                          =                                     &#123;notproduct&#125;A comma separated list of bcis to deoptimize at</div><div class="line">     bool DeoptimizeRandom                          = false                               &#123;product&#125;Deoptimize random frames on random exit from the runtime system</div><div class="line">     intx DesiredMethodLimit                        = 8000                                &#123;develop&#125;The desired maximum method size (in bytecodes) after inlining</div><div class="line">     bool DieOnSafepointTimeout                     = false                               &#123;develop&#125;Die upon failure to reach safepoint (see SafepointTimeout)</div><div class="line">     bool DisableAttachMechanism                    = false                               &#123;product&#125;Disable mechanism that allows tools to attach to this VM</div><div class="line">     bool DisableExplicitGC                         = false                               &#123;product&#125;Ignore calls to System.gc()</div><div class="line">ccstrlist DisableIntrinsic                          =                                     &#123;C2 diagnostic&#125;do not expand intrinsics whose (internal) names appear here</div><div class="line">     bool DisableStartThread                        = false                               &#123;develop&#125;Disable starting of additional Java threads (for debugging only)</div><div class="line">     bool DisplayVMOutput                           = true                                &#123;diagnostic&#125;Display all VM output on the tty, independently of LogVMOutput</div><div class="line">     bool DisplayVMOutputToStderr                   = false                               &#123;product&#125;If DisplayVMOutput is true, display all VM output to stderr</div><div class="line">     bool DisplayVMOutputToStdout                   = false                               &#123;product&#125;If DisplayVMOutput is true, display all VM output to stdout</div><div class="line">     bool DoCEE                                     = true                                &#123;C1 develop&#125;Do Conditional Expression Elimination to simplify CFG</div><div class="line">     bool DoEscapeAnalysis                          = true                                &#123;C2 product&#125;Perform escape analysis</div><div class="line">     intx DominatorSearchLimit                      = 1000                                &#123;C2 diagnostic&#125;Iterations limit in Node::dominates</div><div class="line">     bool DontCompileHugeMethods                    = true                                &#123;product&#125;Do not compile methods &gt; HugeMethodLimit</div><div class="line">     bool DontYieldALot                             = false                               &#123;pd product&#125;Throw away obvious excess yield calls (for Solaris only)</div><div class="line">     intx DontYieldALotInterval                     = 10                                  &#123;develop&#125;Interval between which yields will be dropped (milliseconds)</div><div class="line">    ccstr DumpLoadedClassList                       =                                     &#123;product&#125;Dump the names all loaded classes, that could be stored into the CDS archive, in the specified file</div><div class="line">     bool DumpReplayDataOnError                     = true                                &#123;product&#125;Record replay data for crashing compiler threads</div><div class="line">     bool DumpSharedSpaces                          = false                               &#123;product&#125;Special mode: JVM reads a class list, loads classes, builds shared spaces, and dumps the shared spaces to a file to be used in future JVM runs</div><div class="line">     bool EagerInitialization                       = false                               &#123;develop&#125;Eagerly initialize classes if possible</div><div class="line">     bool EagerXrunInit                             = false                               &#123;product&#125;Eagerly initialize -Xrun libraries; allows startup profiling, but not all -Xrun libraries may support the state of the VM at this time</div><div class="line">     intx EliminateAllocationArraySizeLimit         = 64                                  &#123;C2 product&#125;Array size (number of elements) limit for scalar replacement</div><div class="line">     bool EliminateAllocations                      = true                                &#123;C2 product&#125;Use escape analysis to eliminate allocations</div><div class="line">     bool EliminateAutoBox                          = true                                &#123;C2 product&#125;Control optimizations for autobox elimination</div><div class="line">     bool EliminateBlocks                           = true                                &#123;C1 develop&#125;Eliminate unneccessary basic blocks</div><div class="line">     bool EliminateFieldAccess                      = true                                &#123;C1 develop&#125;Optimize field loads and stores</div><div class="line">     bool EliminateLocks                            = true                                &#123;C2 product&#125;Coarsen locks when possible</div><div class="line">     bool EliminateNestedLocks                      = true                                &#123;C2 product&#125;Eliminate nested locks of the same object when possible</div><div class="line">     bool EliminateNullChecks                       = true                                &#123;C1 develop&#125;Eliminate unneccessary null checks</div><div class="line">     intx EmitSync                                  = 0                                   &#123;product&#125;(Unsafe, Unstable) Control emission of inline sync fast-path code</div><div class="line">     bool EnableContended                           = true                                &#123;product&#125;Enable @Contended annotation support</div><div class="line">     bool EnableInvokeDynamic                       = true                                &#123;diagnostic&#125;support JSR 292 (method handles, invokedynamic, anonymous classes</div><div class="line">     bool EnableTracing                             = false                               &#123;product&#125;Enable event-based tracing</div><div class="line">    uintx ErgoHeapSizeLimit                         = 0                                   &#123;product&#125;Maximum ergonomically set heap size (in bytes); zero means use MaxRAM / MaxRAMFraction</div><div class="line">    ccstr ErrorFile                                 =                                     &#123;product&#125;If an error occurs, save the error data to this file [default: ./hs_err_pid%p.log] (%p replaced with pid)</div><div class="line">    uintx ErrorHandlerTest                          = 0                                   &#123;notproduct&#125;If &gt; 0, provokes an error after VM initialization; the value determines which error to provoke. See test_error_handler() in debug.cpp.</div><div class="line">    ccstr ErrorReportServer                         =                                     &#123;product&#125;Override built-in error report server address</div><div class="line">   double EscapeAnalysisTimeout                     = 60.000000                           &#123;C2 product&#125;Abort EA when it reaches time limit (in sec)</div><div class="line">     bool EstimateArgEscape                         = true                                &#123;product&#125;Analyze bytecodes to estimate escape state of arguments</div><div class="line">     bool ExecuteInternalVMTests                    = false                               &#123;notproduct&#125;Enable execution of internal VM tests</div><div class="line">     bool ExitEscapeAnalysisOnTimeout               = true                                &#123;C2 develop&#125;Exit or throw assert in EA when it reaches time limit</div><div class="line">     bool ExitOnFullCodeCache                       = false                               &#123;notproduct&#125;Exit the VM if we fill the code cache</div><div class="line">     bool ExitOnOutOfMemoryError                    = false                               &#123;product&#125;JVM exits on the first occurrence of an out-of-memory error</div><div class="line">     bool ExitVMOnVerifyError                       = false                               &#123;notproduct&#125;standard exit from VM if bytecode verify error (only in debug mode)</div><div class="line">     bool ExplicitGCInvokesConcurrent               = false                               &#123;product&#125;A System.gc() request invokes a concurrent collection; (effective only when UseConcMarkSweepGC)</div><div class="line">     bool ExplicitGCInvokesConcurrentAndUnloadsClasses  = false                               &#123;product&#125;A System.gc() request invokes a concurrent collection and also unloads classes during such a concurrent gc cycle (effective only when UseConcMarkSweepGC)</div><div class="line">     bool ExtendedDTraceProbes                      = false                               &#123;product&#125;Enable performance-impacting dtrace probes</div><div class="line">    ccstr ExtraSharedClassListFile                  =                                     &#123;product&#125;Extra classlist for building the CDS archive file</div><div class="line">     intx FLOATPRESSURE                             = 6                                   &#123;C2 pd develop&#125;Number of float LRG&apos;s that constitute high register pressure</div><div class="line">     bool FLSAlwaysCoalesceLarge                    = false                               &#123;product&#125;CMS: larger free blocks are always available for coalescing</div><div class="line">    uintx FLSCoalescePolicy                         = 2                                   &#123;product&#125;CMS: aggressiveness level for coalescing, increasing from 0 to 4</div><div class="line">   double FLSLargestBlockCoalesceProximity          = 0.990000                            &#123;product&#125;CMS: the smaller the percentage the greater the coalescing force</div><div class="line">     bool FLSVerifyAllHeapReferences                = false                               &#123;diagnostic&#125;Verify that all references across the FLS boundary are to valid objects</div><div class="line">     bool FLSVerifyDictionary                       = false                               &#123;develop&#125;Do lots of (expensive) FLS dictionary verification</div><div class="line">     bool FLSVerifyIndexTable                       = false                               &#123;diagnostic&#125;Do lots of (expensive) FLS index table verification</div><div class="line">     bool FLSVerifyLists                            = false                               &#123;diagnostic&#125;Do lots of (expensive) FreeListSpace verification</div><div class="line">     bool FailOverToOldVerifier                     = true                                &#123;product&#125;Fail over to old verifier when split verifier fails</div><div class="line">     intx FastAllocateSizeLimit                     = 131072                              &#123;develop&#125;Inline allocations larger than this in doublewords must go slow</div><div class="line">     intx FastSuperclassLimit                       = 8                                   &#123;develop&#125;Depth of hardwired instanceof accelerator array</div><div class="line">     bool FastTLABRefill                            = true                                &#123;product&#125;Use fast TLAB refill code</div><div class="line">     intx FenceInstruction                          = 0                                   &#123;ARCH product&#125;(Unsafe,Unstable) Experimental</div><div class="line">     intx FieldsAllocationStyle                     = 1                                   &#123;product&#125;0 - type based with oops first, 1 - with oops last, 2 - oops in super and sub classes are together</div><div class="line">     bool FillDelaySlots                            = true                                &#123;develop&#125;Fill delay slots (on SPARC only)</div><div class="line">     bool FilterSpuriousWakeups                     = true                                &#123;product&#125;Prevent spurious or premature wakeups from object.wait (Solaris only)</div><div class="line">     bool FoldStableValues                          = true                                &#123;diagnostic&#125;Optimize loads from stable fields (marked w/ @Stable)</div><div class="line">     bool ForceDynamicNumberOfGCThreads             = false                               &#123;diagnostic&#125;Force dynamic selection of the number of parallel threads parallel gc will use to aid debugging</div><div class="line">     bool ForceFloatExceptions                      = true                                &#123;develop&#125;Force exceptions on FP stack under/overflow</div><div class="line">     bool ForceNUMA                                 = false                               &#123;product&#125;Force NUMA optimizations on single-node/UMA systems</div><div class="line">     bool ForceTimeHighResolution                   = false                               &#123;product&#125;Using high time resolution (for Win32 only)</div><div class="line">     bool ForceUnreachable                          = false                               &#123;diagnostic&#125;Make all non code cache addresses to be unreachable by forcing use of 64bit literal fixups</div><div class="line">     intx FreqCountInvocations                      = 1                                   &#123;C2 develop&#125;Scaling factor for branch frequencies (deprecated)</div><div class="line">     intx FreqInlineSize                            = 325                                 &#123;pd product&#125;The maximum bytecode size of a frequent method to be inlined</div><div class="line">     bool FullGCALot                                = false                               &#123;develop&#125;Force full gc at every Nth exit from the runtime system (N=FullGCALotInterval)</div><div class="line">     intx FullGCALotDummies                         = 32768                               &#123;notproduct&#125;Dummy object allocated with +FullGCALot, forcing all objects to move</div><div class="line">     intx FullGCALotInterval                        = 1                                   &#123;notproduct&#125;Interval between which full gc will occur with +FullGCALot</div><div class="line">     intx FullGCALotStart                           = 0                                   &#123;notproduct&#125;For which invocation to start FullGCAlot</div><div class="line">    uintx G1ConcMarkForceOverflow                   = 0                                   &#123;develop&#125;The number of times we&apos;ll force an overflow during concurrent marking</div><div class="line">   double G1ConcMarkStepDurationMillis              = 10.000000                           &#123;product&#125;Target duration of individual concurrent marking steps in milliseconds.</div><div class="line">    uintx G1ConcRSHotCardLimit                      = 4                                   &#123;product&#125;The threshold that defines (&gt;=) a hot card.</div><div class="line">    uintx G1ConcRSLogCacheSize                      = 10                                  &#123;product&#125;Log base 2 of the length of conc RS hot-card cache.</div><div class="line">     intx G1ConcRefinementGreenZone                 = 0                                   &#123;product&#125;The number of update buffers that are left in the queue by the concurrent processing threads. Will be selected ergonomically by default.</div><div class="line">     intx G1ConcRefinementRedZone                   = 0                                   &#123;product&#125;Maximum number of enqueued update buffers before mutator threads start processing new ones instead of enqueueing them. Will be selected ergonomically by default. Zero will disable concurrent processing.</div><div class="line">     intx G1ConcRefinementServiceIntervalMillis     = 300                                 &#123;product&#125;The last concurrent refinement thread wakes up every specified number of milliseconds to do miscellaneous work.</div><div class="line">    uintx G1ConcRefinementThreads                   = 0                                   &#123;product&#125;If non-0 is the number of parallel rem set update threads, otherwise the value is determined ergonomically.</div><div class="line">     intx G1ConcRefinementThresholdStep             = 0                                   &#123;product&#125;Each time the rset update queue increases by this amount activate the next refinement thread if available. Will be selected ergonomically by default.</div><div class="line">     intx G1ConcRefinementYellowZone                = 0                                   &#123;product&#125;Number of enqueued update buffers that will trigger concurrent processing. Will be selected ergonomically by default.</div><div class="line">     bool G1ConcRegionFreeingVerbose                = false                               &#123;develop&#125;Enables verboseness during concurrent region freeing</div><div class="line">    uintx G1ConfidencePercent                       = 50                                  &#123;product&#125;Confidence level for MMU/pause predictions</div><div class="line">    uintx G1DummyRegionsPerGC                       = 0                                   &#123;develop&#125;The number of dummy regions G1 will allocate at the end of each evacuation pause in order to artificially fill up the heap and stress the marking implementation.</div><div class="line">     bool G1EvacuationFailureALot                   = false                               &#123;notproduct&#125;Force use of evacuation failure handling during certain evacuation pauses</div><div class="line">    uintx G1EvacuationFailureALotCount              = 1000                                &#123;develop&#125;Number of successful evacuations between evacuation failures occurring at object copying</div><div class="line">     bool G1EvacuationFailureALotDuringConcMark     = true                                &#123;develop&#125;Force use of evacuation failure handling during evacuation pauses when marking is in progress</div><div class="line">     bool G1EvacuationFailureALotDuringInitialMark  = true                                &#123;develop&#125;Force use of evacuation failure handling during initial mark evacuation pauses</div><div class="line">     bool G1EvacuationFailureALotDuringMixedGC      = true                                &#123;develop&#125;Force use of evacuation failure handling during mixed evacuation pauses</div><div class="line">     bool G1EvacuationFailureALotDuringYoungGC      = true                                &#123;develop&#125;Force use of evacuation failure handling during young evacuation pauses</div><div class="line">    uintx G1EvacuationFailureALotInterval           = 5                                   &#123;develop&#125;Total collections between forced triggering of evacuation failures</div><div class="line">     bool G1ExitOnExpansionFailure                  = false                               &#123;develop&#125;Raise a fatal VM exit out of memory failure in the event  that heap expansion fails due to running out of swap.</div><div class="line">     bool G1FailOnFPError                           = false                               &#123;develop&#125;When set, G1 will fail when it encounters an FP &apos;error&apos;, so as to allow debugging</div><div class="line">     bool G1HRRSFlushLogBuffersOnVerify             = false                               &#123;develop&#125;Forces flushing of log buffers before verification.</div><div class="line">     bool G1HRRSUseSparseTable                      = true                                &#123;develop&#125;When true, use sparse table to save space.</div><div class="line">    uintx G1HeapRegionSize                          = 0                                   &#123;product&#125;Size of the G1 regions.</div><div class="line">    uintx G1HeapWastePercent                        = 5                                   &#123;product&#125;Amount of space, expressed as a percentage of the heap size, that G1 is willing not to collect to avoid expensive GCs.</div><div class="line">     intx G1MarkingOverheadPercent                  = 0                                   &#123;develop&#125;Overhead of concurrent marking</div><div class="line">     intx G1MarkingVerboseLevel                     = 0                                   &#123;develop&#125;Level (0-4) of verboseness of the marking code</div><div class="line">     intx G1MaxVerifyFailures                       = -1                                  &#123;develop&#125;The maximum number of verification failrues to print.  -1 means print all.</div><div class="line">    uintx G1MixedGCCountTarget                      = 8                                   &#123;product&#125;The target number of mixed GCs after a marking cycle.</div><div class="line">     bool G1PrintHeapRegions                        = false                               &#123;diagnostic&#125;If set G1 will print information on which regions are being allocated and which are reclaimed.</div><div class="line">     bool G1PrintReachableAtInitialMark             = false                               &#123;develop&#125;Reachable object dump at the initial mark pause</div><div class="line">    ccstr G1PrintReachableBaseFile                  =                                     &#123;develop&#125;The base file name for the reachable object dumps</div><div class="line">     bool G1PrintRegionLivenessInfo                 = false                               &#123;diagnostic&#125;Prints the liveness information for all regions in the heap at the end of a marking cycle.</div><div class="line">     bool G1RSBarrierRegionFilter                   = true                                &#123;develop&#125;If true, generate region filtering code in RS barrier</div><div class="line">     bool G1RSLogCheckCardTable                     = false                               &#123;develop&#125;If true, verify that no dirty cards remain after RS log processing.</div><div class="line">     bool G1RSScrubVerbose                          = false                               &#123;develop&#125;When true, do RS scrubbing with verbose output.</div><div class="line">     intx G1RSetRegionEntries                       = 0                                   &#123;product&#125;Max number of regions for which we keep bitmaps.Will be set ergonomically by default</div><div class="line">     intx G1RSetRegionEntriesBase                   = 256                                 &#123;develop&#125;Max number of regions in a fine-grain table per MB.</div><div class="line">    uintx G1RSetScanBlockSize                       = 64                                  &#123;product&#125;Size of a work unit of cards claimed by a worker threadduring RSet scanning.</div><div class="line">     intx G1RSetSparseRegionEntries                 = 0                                   &#123;product&#125;Max number of entries per region in a sparse table.Will be set ergonomically by default.</div><div class="line">     intx G1RSetSparseRegionEntriesBase             = 4                                   &#123;develop&#125;Max number of entries per region in a sparse table per MB.</div><div class="line">     intx G1RSetUpdatingPauseTimePercent            = 10                                  &#123;product&#125;A target percentage of time that is allowed to be spend on process RS update buffers during the collection pause.</div><div class="line">     bool G1RecordHRRSEvents                        = false                               &#123;develop&#125;When true, record recent calls to rem set operations.</div><div class="line">     bool G1RecordHRRSOops                          = false                               &#123;develop&#125;When true, record recent calls to rem set operations.</div><div class="line">     intx G1RefProcDrainInterval                    = 10                                  &#123;product&#125;The number of discovered reference objects to process before draining concurrent marking work queues.</div><div class="line">    uintx G1ReservePercent                          = 10                                  &#123;product&#125;It determines the minimum reserve we should have in the heap to minimize the probability of promotion failure.</div><div class="line">    uintx G1SATBBufferEnqueueingThresholdPercent    = 60                                  &#123;product&#125;Before enqueueing them, each mutator thread tries to do some filtering on the SATB buffers it generates. If post-filtering the percentage of retained entries is over this threshold the buffer will be enqueued for processing. A value of 0 specifies that mutator threads should not do such filtering.</div><div class="line">     intx G1SATBBufferSize                          = 1024                                &#123;product&#125;Number of entries in an SATB log buffer.</div><div class="line">     bool G1SATBPrintStubs                          = false                               &#123;develop&#125;If true, print generated stubs for the SATB barrier</div><div class="line">     intx G1SATBProcessCompletedThreshold           = 20                                  &#123;develop&#125;Number of completed buffers that triggers log processing.</div><div class="line">     bool G1ScrubRemSets                            = true                                &#123;develop&#125;When true, do RS scrubbing after cleanup.</div><div class="line">    uintx G1SecondaryFreeListAppendLength           = 5                                   &#123;develop&#125;The number of regions we will add to the secondary free list at every append operation</div><div class="line">     bool G1StressConcRegionFreeing                 = false                               &#123;develop&#125;It stresses the concurrent region freeing operation</div><div class="line">    uintx G1StressConcRegionFreeingDelayMillis      = 0                                   &#123;develop&#125;Artificial delay during concurrent region freeing</div><div class="line">     bool G1SummarizeConcMark                       = false                               &#123;diagnostic&#125;Summarize concurrent mark info</div><div class="line">     bool G1SummarizeRSetStats                      = false                               &#123;diagnostic&#125;Summarize remembered set processing info</div><div class="line">     intx G1SummarizeRSetStatsPeriod                = 0                                   &#123;diagnostic&#125;The period (in number of GCs) at which we will generate update buffer processing info (0 means do not periodically generate this info); it also requires -XX:+G1SummarizeRSetStats</div><div class="line">     bool G1TraceConcRefinement                     = false                               &#123;diagnostic&#125;Trace G1 concurrent refinement</div><div class="line">     bool G1TraceHeapRegionRememberedSet            = false                               &#123;develop&#125;Enables heap region remembered set debug logs</div><div class="line">     bool G1TraceMarkStackOverflow                  = false                               &#123;develop&#125;If true, extra debugging code for CM restart for ovflw.</div><div class="line">     intx G1UpdateBufferSize                        = 256                                 &#123;product&#125;Size of an update buffer</div><div class="line">     bool G1UseAdaptiveConcRefinement               = true                                &#123;product&#125;Select green, yellow and red zones adaptively to meet the the pause requirements.</div><div class="line">     bool G1VerifyBitmaps                           = false                               &#123;develop&#125;Verifies the consistency of the marking bitmaps</div><div class="line">     bool G1VerifyCTCleanup                         = false                               &#123;develop&#125;Verify card table cleanup.</div><div class="line">     bool G1VerifyDuringGCPrintReachable            = false                               &#123;develop&#125;If conc mark verification fails, dump reachable objects</div><div class="line">     bool G1VerifyHeapRegionCodeRoots               = false                               &#123;diagnostic&#125;Verify the code root lists attached to each heap region.</div><div class="line">     bool G1VerifyRSetsDuringFullGC                 = false                               &#123;diagnostic&#125;If true, perform verification of each heap region&apos;s remembered set when verifying the heap during a full GC.</div><div class="line">     intx G1YoungSurvRateNumRegionsSummary          = 0                                   &#123;develop&#125;the number of regions for which we&apos;ll print a surv rate summary.</div><div class="line">     bool G1YoungSurvRateVerbose                    = false                               &#123;develop&#125;print out the survival rate of young regions according to age.</div><div class="line">     bool GCALotAtAllSafepoints                     = false                               &#123;notproduct&#125;Enforce ScavengeALot/GCALot at all potential safepoints</div><div class="line">    uintx GCDrainStackTargetSize                    = 64                                  &#123;product&#125;Number of entries we will try to leave on the stack during parallel gc</div><div class="line">    uintx GCExpandToAllocateDelayMillis             = 0                                   &#123;develop&#125;Delay between expansion and allocation (in milliseconds)</div><div class="line">    uintx GCHeapFreeLimit                           = 2                                   &#123;product&#125;Minimum percentage of free space after a full GC before an OutOfMemoryError is thrown (used with GCTimeLimit)</div><div class="line">    uintx GCLockerEdenExpansionPercent              = 5                                   &#123;product&#125;How much the GC can expand the eden by while the GC locker is active (as a percentage)</div><div class="line">     bool GCLockerInvokesConcurrent                 = false                               &#123;product&#125;The exit of a JNI critical section necessitating a scavenge, also kicks off a background concurrent collection</div><div class="line">    uintx GCLockerRetryAllocationCount              = 2                                   &#123;diagnostic&#125;Number of times to retry allocations when blocked by the GC locker</div><div class="line">    uintx GCLogFileSize                             = 8192                                &#123;product&#125;GC log file size, requires UseGCLogFileRotation. Set to 0 to only trigger rotation via jcmd</div><div class="line">     bool GCParallelVerificationEnabled             = true                                &#123;diagnostic&#125;Enable parallel memory system verification</div><div class="line">    uintx GCPauseIntervalMillis                     = 0                                   &#123;product&#125;Time slice for MMU specification</div><div class="line">    uintx GCTaskTimeStampEntries                    = 200                                 &#123;product&#125;Number of time stamp entries per gc worker thread</div><div class="line">    uintx GCTimeLimit                               = 98                                  &#123;product&#125;Limit of the proportion of time spent in GC before an OutOfMemoryError is thrown (used with GCHeapFreeLimit)</div><div class="line">    uintx GCTimeRatio                               = 99                                  &#123;product&#125;Adaptive size policy application time to GC time ratio</div><div class="line">    uintx GCWorkerDelayMillis                       = 0                                   &#123;develop&#125;Delay in scheduling GC workers (in milliseconds)</div><div class="line">     bool GenerateArrayStoreCheck                   = true                                &#123;C1 develop&#125;Generates code for array store checks</div><div class="line">     bool GenerateCompilerNullChecks                = true                                &#123;develop&#125;Generate explicit null checks for loads/stores/calls</div><div class="line">     bool GenerateRangeChecks                       = true                                &#123;develop&#125;Generate range checks for array accesses</div><div class="line">     bool GenerateSynchronizationCode               = true                                &#123;develop&#125;generate locking/unlocking code for synchronized methods and monitors</div><div class="line">     intx GuaranteedSafepointInterval               = 1000                                &#123;diagnostic&#125;Guarantee a safepoint (at least) every so many milliseconds (0 means none)</div><div class="line">    uintx HandleAllocationLimit                     = 1024                                &#123;notproduct&#125;Threshold for HandleMark allocation when +TraceHandleAllocation is used</div><div class="line">    uintx HeapBaseMinAddress                        = 2147483648                          &#123;pd product&#125;OS specific low limit for heap base address</div><div class="line">     bool HeapDumpAfterFullGC                       = false                               &#123;manageable&#125;Dump heap to file after any major stop-the-world GC</div><div class="line">     bool HeapDumpBeforeFullGC                      = false                               &#123;manageable&#125;Dump heap to file before any major stop-the-world GC</div><div class="line">     bool HeapDumpOnOutOfMemoryError                = false                               &#123;manageable&#125;Dump heap to file when java.lang.OutOfMemoryError is thrown</div><div class="line">    ccstr HeapDumpPath                              =                                     &#123;manageable&#125;When HeapDumpOnOutOfMemoryError is on, the path (filename or directory) of the dump file (defaults to java_pid&lt;pid&gt;.hprof in the working directory)</div><div class="line">    uintx HeapDumpSegmentSize                       = 1073741824                          &#123;develop&#125;Approximate segment size when generating a segmented heap dump</div><div class="line">    uintx HeapFirstMaximumCompactionCount           = 3                                   &#123;product&#125;The collection count for the first maximum compaction</div><div class="line">    uintx HeapMaximumCompactionInterval             = 20                                  &#123;product&#125;How often should we maximally compact the heap (not allowing any dead space)</div><div class="line">    uintx HeapSizePerGCThread                       = 87241520                            &#123;product&#125;Size of heap (bytes) per GC thread used in calculating the number of GC threads</div><div class="line">     intx HotCallCountThreshold                     = 999999                              &#123;C2 develop&#125;large numbers of calls (per method invocation) force hotness</div><div class="line">     intx HotCallProfitThreshold                    = 999999                              &#123;C2 develop&#125;highly profitable inlining opportunities force hotness</div><div class="line">     intx HotCallTrivialSize                        = -1                                  &#123;C2 develop&#125;trivial methods (no larger than this) force calls to be hot</div><div class="line">     intx HotCallTrivialWork                        = -1                                  &#123;C2 develop&#125;trivial execution time (no larger than this) forces hotness</div><div class="line">     intx HugeMethodLimit                           = 8000                                &#123;develop&#125;Don&apos;t compile methods larger than this if +DontCompileHugeMethods</div><div class="line">     bool ICMissHistogram                           = false                               &#123;notproduct&#125;Produce histogram of IC misses</div><div class="line">     bool IEEEPrecision                             = true                                &#123;ARCH develop&#125;Enables IEEE precision (for INTEL only)</div><div class="line">     intx INTPRESSURE                               = 13                                  &#123;C2 pd develop&#125;Number of integer LRG&apos;s that constitute high register pressure</div><div class="line">     bool IdealizedNumerics                         = false                               &#123;C2 develop&#125;Check performance difference allowing FP associativity and commutativity...</div><div class="line">     bool IgnoreEmptyClassPaths                     = false                               &#123;product&#125;Ignore empty path elements in -classpath</div><div class="line">     bool IgnoreLibthreadGPFault                    = false                               &#123;develop&#125;Suppress workaround for libthread GP fault</div><div class="line">     bool IgnoreLockingAssertions                   = false                               &#123;notproduct&#125;disable locking assertions (for speed)</div><div class="line">     bool IgnoreRewrites                            = false                               &#123;develop&#125;Suppress rewrites of bytecodes in the oopmap generator. This is unsafe!</div><div class="line">     bool IgnoreUnrecognizedVMOptions               = false                               &#123;product&#125;Ignore unrecognized VM options</div><div class="line">     bool IgnoreUnverifiableClassesDuringDump       = false                               &#123;diagnostic&#125;Do not quit -Xshare:dump even if we encounter unverifiable classes. Just exclude them from the shared dictionary.</div><div class="line">     bool ImplicitDiv0Checks                        = true                                &#123;C1 develop&#125;Use implicit division by zero checks</div><div class="line">     intx ImplicitNullCheckThreshold                = 3                                   &#123;C2 develop&#125;Don&apos;t do implicit null checks if NPE&apos;s in a method exceeds limit</div><div class="line">     bool ImplicitNullChecks                        = true                                &#123;pd develop&#125;Generate code for implicit null checks</div><div class="line">    uintx IncreaseFirstTierCompileThresholdAt       = 50                                  &#123;product&#125;Increase the compile threshold for C1 compilation if the code cache is filled by the specified percentage</div><div class="line">     bool IncrementalInline                         = true                                &#123;C2 product&#125;do post parse inlining</div><div class="line">     intx IndexSetWatch                             = 0                                   &#123;C2 notproduct&#125;Trace all operations on this IndexSet (-1 means all, 0 none)</div><div class="line">    uintx InitialBootClassLoaderMetaspaceSize       = 4194304                             &#123;product&#125;Initial size of the boot class loader data metaspace</div><div class="line">    uintx InitialCodeCacheSize                      = 2555904                             &#123;pd product&#125;Initial code cache size (in bytes)</div><div class="line">    uintx InitialHeapSize                           = 0                                   &#123;product&#125;Initial heap size (in bytes); zero means use ergonomics</div><div class="line">    uintx InitialRAMFraction                        = 64                                  &#123;product&#125;Fraction (1/n) of real memory used for initial heap size</div><div class="line">    uintx InitialSurvivorRatio                      = 8                                   &#123;product&#125;Initial ratio of young generation/survivor space size</div><div class="line">    uintx InitialTenuringThreshold                  = 7                                   &#123;product&#125;Initial value for tenuring threshold</div><div class="line">    uintx InitiatingHeapOccupancyPercent            = 45                                  &#123;product&#125;Percentage of the (entire) heap occupancy to start a concurrent GC cycle. It is used by GCs that trigger a concurrent GC cycle based on the occupancy of the entire heap, not just one of the generations (e.g., G1). A value of 0 denotes &apos;do constant GC cycles&apos;.</div><div class="line">     bool Inline                                    = true                                &#123;product&#125;Enable inlining</div><div class="line">     bool InlineAccessors                           = true                                &#123;C2 develop&#125;inline accessor methods (get/set)</div><div class="line">     bool InlineArrayCopy                           = true                                &#123;develop&#125;Inline arraycopy native that is known to be part of base library DLL</div><div class="line">     bool InlineClassNatives                        = true                                &#123;develop&#125;Inline Class.isInstance, etc</div><div class="line">    ccstr InlineDataFile                            =                                     &#123;product&#125;File containing inlining replay information[default: ./inline_pid%p.log] (%p replaced with pid)</div><div class="line">     intx InlineFrequencyCount                      = 100                                 &#123;pd develop&#125;Count of call site execution necessary to trigger frequent inlining</div><div class="line">     intx InlineFrequencyRatio                      = 20                                  &#123;develop&#125;Ratio of call site execution to caller method invocation</div><div class="line">     bool InlineIntrinsics                          = true                                &#123;pd develop&#125;Inline intrinsics that can be statically resolved</div><div class="line">     bool InlineMathNatives                         = true                                &#123;develop&#125;Inline SinD, CosD, etc.</div><div class="line">     bool InlineMethodsWithExceptionHandlers        = true                                &#123;C1 develop&#125;Inline methods containing exception handlers (NOTE: does not work with current backend)</div><div class="line">     bool InlineNIOCheckIndex                       = true                                &#123;C1 develop&#125;Intrinsify java.nio.Buffer.checkIndex</div><div class="line">     bool InlineNatives                             = true                                &#123;develop&#125;Inline natives that are known to be part of base library DLL</div><div class="line">     bool InlineObjectCopy                          = true                                &#123;C2 develop&#125;inline Object.clone and Arrays.copyOf[Range] intrinsics</div><div class="line">     bool InlineObjectHash                          = true                                &#123;develop&#125;Inline Object::hashCode() native that is known to be part of base library DLL</div><div class="line">     bool InlineReflectionGetCallerClass            = true                                &#123;C2 develop&#125;inline sun.reflect.Reflection.getCallerClass(), known to be part of base library DLL</div><div class="line">     intx InlineSmallCode                           = 1000                                &#123;pd product&#125;Only inline already compiled methods if their code size is less than this</div><div class="line">     bool InlineSynchronizedMethods                 = true                                &#123;C1 product&#125;Inline synchronized methods</div><div class="line">     bool InlineThreadNatives                       = true                                &#123;develop&#125;Inline Thread.currentThread, etc</div><div class="line">     intx InlineThrowCount                          = 50                                  &#123;develop&#125;Force inlining of interpreted methods that throw this often</div><div class="line">     intx InlineThrowMaxSize                        = 200                                 &#123;develop&#125;Force inlining of throwing methods smaller than this</div><div class="line">     bool InlineUnsafeOps                           = true                                &#123;develop&#125;Inline memory ops (native methods) from sun.misc.Unsafe</div><div class="line">     bool InlineWarmCalls                           = false                               &#123;C2 develop&#125;Use a heat-based priority queue to govern inlining</div><div class="line">     bool InsertMemBarAfterArraycopy                = true                                &#123;C2 product&#125;Insert memory barrier after arraycopy call</div><div class="line">     bool InstallMethods                            = true                                &#123;C1 develop&#125;Install methods at the end of successful compilations</div><div class="line">     intx InstructionCountCutoff                    = 37000                               &#123;C1 develop&#125;If GraphBuilder adds this many instructions, bails out</div><div class="line">     bool InterceptOSException                      = false                               &#123;develop&#125;Start debugger when an implicit OS (e.g. NULL) exception happens</div><div class="line">     intx InteriorEntryAlignment                    = 16                                  &#123;C2 pd product&#125;Code alignment for interior entry points in generated code (in bytes)</div><div class="line">     intx InterpreterProfilePercentage              = 33                                  &#123;product&#125;NON_TIERED number of method invocations/branches (expressed as % of CompileThreshold) before profiling in the interpreter</div><div class="line">     bool JNIDetachReleasesMonitors                 = true                                &#123;product&#125;JNI DetachCurrentThread releases monitors owned by thread</div><div class="line">    uintx JVMInvokeMethodSlack                      = 8192                                &#123;pd develop&#125;Stack space (bytes) required for JVM_InvokeMethod to complete</div><div class="line">     bool JavaMonitorsInStackTrace                  = true                                &#123;product&#125;Print information about Java monitor locks when the stacks aredumped</div><div class="line">     intx JavaPriority10_To_OSPriority              = -1                                  &#123;product&#125;Map Java priorities to OS priorities</div><div class="line">     intx JavaPriority1_To_OSPriority               = -1                                  &#123;product&#125;Map Java priorities to OS priorities</div><div class="line">     intx JavaPriority2_To_OSPriority               = -1                                  &#123;product&#125;Map Java priorities to OS priorities</div><div class="line">     intx JavaPriority3_To_OSPriority               = -1                                  &#123;product&#125;Map Java priorities to OS priorities</div><div class="line">     intx JavaPriority4_To_OSPriority               = -1                                  &#123;product&#125;Map Java priorities to OS priorities</div><div class="line">     intx JavaPriority5_To_OSPriority               = -1                                  &#123;product&#125;Map Java priorities to OS priorities</div><div class="line">     intx JavaPriority6_To_OSPriority               = -1                                  &#123;product&#125;Map Java priorities to OS priorities</div><div class="line">     intx JavaPriority7_To_OSPriority               = -1                                  &#123;product&#125;Map Java priorities to OS priorities</div><div class="line">     intx JavaPriority8_To_OSPriority               = -1                                  &#123;product&#125;Map Java priorities to OS priorities</div><div class="line">     intx JavaPriority9_To_OSPriority               = -1                                  &#123;product&#125;Map Java priorities to OS priorities</div><div class="line">     bool LIRFillDelaySlots                         = false                               &#123;C1 pd product&#125;fill delays on on SPARC with LIR</div><div class="line">     bool LIRTraceExecution                         = false                               &#123;C1 develop&#125;add LIR code which logs the execution of blocks</div><div class="line">     bool LIRTracePeephole                          = false                               &#123;C1 develop&#125;Trace peephole optimizer</div><div class="line">    uintx LargePageHeapSizeThreshold                = 134217728                           &#123;product&#125;Use large pages if maximum heap is at least this big</div><div class="line">    uintx LargePageSizeInBytes                      = 0                                   &#123;product&#125;Large page size (0 to let VM choose the page size)</div><div class="line">     bool LargePagesIndividualAllocationInjectError  = false                               &#123;develop&#125;Fail large pages individual allocation</div><div class="line">     bool LazyBootClassLoader                       = true                                &#123;product&#125;Enable/disable lazy opening of boot class path entries</div><div class="line">     intx LiveNodeCountInliningCutoff               = 40000                               &#123;C2 product&#125;max number of live nodes in a method</div><div class="line">     bool LoadExecStackDllInVMThread                = true                                &#123;product&#125;Load DLLs with executable-stack attribute in the VM Thread</div><div class="line">     bool LoadLineNumberTables                      = true                                &#123;develop&#125;Tell whether the class file parser loads line number tables</div><div class="line">     bool LoadLocalVariableTables                   = true                                &#123;develop&#125;Tell whether the class file parser loads local variable tables</div><div class="line">     bool LoadLocalVariableTypeTables               = true                                &#123;develop&#125;Tell whether the class file parser loads local variable typetables</div><div class="line">     bool LogCompilation                            = false                               &#123;diagnostic&#125;Log compilation activity in detail to LogFile</div><div class="line">     bool LogEvents                                 = true                                &#123;diagnostic&#125;Enable the various ring buffer event logs</div><div class="line">    uintx LogEventsBufferEntries                    = 10                                  &#123;diagnostic&#125;Number of ring buffer event logs</div><div class="line">    ccstr LogFile                                   =                                     &#123;diagnostic&#125;If LogVMOutput or LogCompilation is on, save VM output to this file [default: ./hotspot_pid%p.log] (%p replaced with pid)</div><div class="line">     bool LogSweeper                                = false                               &#123;notproduct&#125;Keep a ring buffer of sweeper activity</div><div class="line">     bool LogVMOutput                               = false                               &#123;diagnostic&#125;Save VM output to LogFile</div><div class="line">     intx LongCompileThreshold                      = 50                                  &#123;develop&#125;Used with +TraceLongCompiles</div><div class="line">     bool LoopLimitCheck                            = true                                &#123;C2 diagnostic&#125;Generate a loop limits check for overflow</div><div class="line">     intx LoopMaxUnroll                             = 16                                  &#123;C2 product&#125;Maximum number of unrolls for main loop</div><div class="line">     intx LoopOptsCount                             = 43                                  &#123;C2 product&#125;Set level of loop optimization for tier 1 compiles</div><div class="line">     intx LoopUnrollLimit                           = 60                                  &#123;C2 pd product&#125;Unroll loop bodies with node count less than this</div><div class="line">     intx LoopUnrollMin                             = 4                                   &#123;C2 product&#125;Minimum number of unroll loop bodies before checking progressof rounds of unroll,optimize,..</div><div class="line">     bool LoopUnswitching                           = true                                &#123;C2 product&#125;Enable loop unswitching (a form of invariant test hoisting)</div><div class="line">     intx MallocCatchPtr                            = -1                                  &#123;develop&#125;Hit breakpoint when mallocing/freeing this pointer</div><div class="line">    uintx MallocMaxTestWords                        = 0                                   &#123;diagnostic&#125;If non-zero, maximum number of words that malloc/realloc can allocate (for testing only)</div><div class="line">     intx MallocVerifyInterval                      = 0                                   &#123;diagnostic&#125;If non-zero, verify C heap after every N calls to malloc/realloc/free</div><div class="line">     intx MallocVerifyStart                         = 0                                   &#123;diagnostic&#125;If non-zero, start verifying C heap after Nth call to malloc/realloc/free</div><div class="line">     bool ManagementServer                          = false                               &#123;product&#125;Create JMX Management Server</div><div class="line">    uintx MarkStackSize                             = 4194304                             &#123;product&#125;Size of marking stack</div><div class="line">    uintx MarkStackSizeMax                          = 536870912                           &#123;product&#125;Maximum size of marking stack</div><div class="line">    uintx MarkSweepAlwaysCompactCount               = 4                                   &#123;product&#125;How often should we fully compact the heap (ignoring the dead space parameters)</div><div class="line">    uintx MarkSweepDeadRatio                        = 5                                   &#123;product&#125;Percentage (0-100) of the old gen allowed as dead wood. Serial mark sweep treats this as both the minimum and maximum value. CMS uses this value only if it falls back to mark sweep. Par compact uses a variable scale based on the density of the generation and treats this as the maximum value when the heap is either completely full or completely empty.  Par compact also has a smaller default value; see arguments.cpp.</div><div class="line">     intx MaxBCEAEstimateLevel                      = 5                                   &#123;product&#125;Maximum number of nested calls that are analyzed by BC EA</div><div class="line">     intx MaxBCEAEstimateSize                       = 150                                 &#123;product&#125;Maximum bytecode size of a method to be analyzed by BC EA</div><div class="line">    uintx MaxDirectMemorySize                       = 0                                   &#123;product&#125;Maximum total size of NIO direct-buffer allocations</div><div class="line">     intx MaxElementPrintSize                       = 256                                 &#123;notproduct&#125;maximum number of elements to print</div><div class="line">     bool MaxFDLimit                                = true                                &#123;product&#125;Bump the number of file descriptors to maximum in Solaris</div><div class="line">     intx MaxForceInlineLevel                       = 100                                 &#123;develop&#125;maximum number of nested calls that are forced for inlining (using CompilerOracle or marked w/ @ForceInline)</div><div class="line">    uintx MaxGCMinorPauseMillis                     = 18446744073709551615                    &#123;product&#125;Adaptive size policy maximum GC minor pause time goal in millisecond</div><div class="line">    uintx MaxGCPauseMillis                          = 18446744073709551615                    &#123;product&#125;Adaptive size policy maximum GC pause time goal in millisecond, or (G1 Only) the maximum GC time per MMU time slice</div><div class="line">    uintx MaxHeapFreeRatio                          = 70                                  &#123;manageable&#125;The maximum percentage of heap free after GC to avoid shrinking. For most GCs this applies to the old generation. In G1 and ParallelGC it applies to the whole heap.</div><div class="line">    uintx MaxHeapSize                               = 130862280                           &#123;product&#125;Maximum heap size (in bytes)</div><div class="line">     intx MaxInlineLevel                            = 9                                   &#123;product&#125;maximum number of nested calls that are inlined</div><div class="line">     intx MaxInlineSize                             = 35                                  &#123;product&#125;The maximum bytecode size of a method to be inlined</div><div class="line">     intx MaxInterpretedSearchLength                = 3                                   &#123;develop&#125;The maximum number of interpreted frames to skip when searching for recompilee</div><div class="line">     intx MaxJNILocalCapacity                       = 65536                               &#123;product&#125;Maximum allowable local JNI handle capacity to EnsureLocalCapacity() and PushLocalFrame(), where &lt;= 0 is unlimited, default: 65536</div><div class="line">     intx MaxJavaStackTraceDepth                    = 1024                                &#123;product&#125;The maximum number of lines in the stack trace for Java exceptions (0 means all)</div><div class="line">     intx MaxJumpTableSize                          = 65000                               &#123;C2 product&#125;Maximum number of targets in a generated jump table</div><div class="line">     intx MaxJumpTableSparseness                    = 5                                   &#123;C2 product&#125;Maximum sparseness for jumptables</div><div class="line">     intx MaxLabelRootDepth                         = 1100                                &#123;C2 product&#125;Maximum times call Label_Root to prevent stack overflow</div><div class="line">     intx MaxLoopPad                                = 15                                  &#123;C2 product&#125;Align a loop if padding size in bytes is less or equal to this value</div><div class="line">    uintx MaxMetaspaceExpansion                     = 5452592                             &#123;product&#125;The maximum expansion of Metaspace without full GC (in bytes)</div><div class="line">    uintx MaxMetaspaceFreeRatio                     = 70                                  &#123;product&#125;The maximum percentage of Metaspace free after GC to avoid shrinking</div><div class="line">    uintx MaxMetaspaceSize                          = 18446744073709551615                    &#123;product&#125;Maximum size of Metaspaces (in bytes)</div><div class="line">    uintx MaxNewSize                                = 18446744073709551615                    &#123;product&#125;Maximum new generation size (in bytes), max_uintx means set ergonomically</div><div class="line">     intx MaxNodeLimit                              = 80000                               &#123;C2 product&#125;Maximum number of nodes</div><div class="line"> uint64_t MaxRAM                                    = 137438953472                        &#123;pd product&#125;Real memory size (in bytes) used to set maximum heap size</div><div class="line">    uintx MaxRAMFraction                            = 4                                   &#123;product&#125;Maximum fraction (1/n) of real memory used for maximum heap size</div><div class="line">     intx MaxRecompilationSearchLength              = 10                                  &#123;develop&#125;The maximum number of frames to inspect when searching for recompilee</div><div class="line">     intx MaxRecursiveInlineLevel                   = 1                                   &#123;product&#125;maximum number of nested recursive calls that are inlined</div><div class="line">     intx MaxSubklassPrintSize                      = 4                                   &#123;notproduct&#125;maximum number of subklasses to print when printing klass</div><div class="line">    uintx MaxTenuringThreshold                      = 15                                  &#123;product&#125;Maximum value for tenuring threshold</div><div class="line">     intx MaxTrivialSize                            = 6                                   &#123;product&#125;The maximum bytecode size of a trivial method to be inlined</div><div class="line">     intx MaxVectorSize                             = 32                                  &#123;C2 product&#125;Max vector size in bytes, actual size could be less depending on elements type</div><div class="line">    uintx MaxVirtMemFraction                        = 2                                   &#123;develop&#125;Maximum fraction (1/n) of virtual memory used for ergonomically determining maximum heap size</div><div class="line">     bool MemProfiling                              = false                               &#123;develop&#125;Write memory usage profiling to log file</div><div class="line">     intx MemProfilingInterval                      = 500                                 &#123;notproduct&#125;Time between each invocation of the MemProfiler</div><div class="line">     bool MetadataAllocationFailALot                = false                               &#123;develop&#125;Fail metadata allocations at intervals controlled by MetadataAllocationFailALotInterval</div><div class="line">    uintx MetadataAllocationFailALotInterval        = 1000                                &#123;develop&#125;Metadata allocation failure a lot interval</div><div class="line">    uintx MetaspaceSize                             = 21810376                            &#123;pd product&#125;Initial size of Metaspaces (in bytes)</div><div class="line">     bool MethodFlushing                            = true                                &#123;product&#125;Reclamation of zombie and not-entrant methods</div><div class="line">     intx MethodHistogramCutoff                     = 100                                 &#123;develop&#125;The cutoff value for method invocation histogram (+CountCalls)</div><div class="line">    uintx MinHeapDeltaBytes                         = 170392                              &#123;product&#125;The minimum change in heap space due to GC (in bytes)</div><div class="line">    uintx MinHeapFreeRatio                          = 40                                  &#123;manageable&#125;The minimum percentage of heap free after GC to avoid expansion. For most GCs this applies to the old generation. In G1 and ParallelGC it applies to the whole heap.</div><div class="line">     intx MinInliningThreshold                      = 250                                 &#123;product&#125;The minimum invocation count a method needs to have to be inlined</div><div class="line">     intx MinJumpTableSize                          = 10                                  &#123;C2 pd product&#125;Minimum number of targets in a generated jump table</div><div class="line">    uintx MinMetaspaceExpansion                     = 340784                              &#123;product&#125;The minimum expansion of Metaspace (in bytes)</div><div class="line">    uintx MinMetaspaceFreeRatio                     = 40                                  &#123;product&#125;The minimum percentage of Metaspace free after GC to avoid expansion</div><div class="line">     intx MinOopMapAllocation                       = 8                                   &#123;develop&#125;Minimum number of OopMap entries in an OopMapSet</div><div class="line">    uintx MinRAMFraction                            = 2                                   &#123;product&#125;Minimum fraction (1/n) of real memory used for maxmimum heap size on systems with small physical memory size</div><div class="line">     intx MinSleepInterval                          = 1                                   &#123;develop&#125;Minimum sleep() interval (milliseconds) when ConvertSleepToYield is off (used for Solaris)</div><div class="line">    uintx MinSurvivorRatio                          = 3                                   &#123;product&#125;Minimum ratio of young generation/survivor space size</div><div class="line">    uintx MinTLABSize                               = 2048                                &#123;product&#125;Minimum allowed TLAB size (in bytes)</div><div class="line">     intx MonitorBound                              = 0                                   &#123;product&#125;Bound Monitor population</div><div class="line">     bool MonitorInUseLists                         = false                               &#123;product&#125;Track Monitors for Deflation</div><div class="line">     bool MonomorphicArrayCheck                     = true                                &#123;C2 develop&#125;Uncommon-trap array store checks that require full type check</div><div class="line">     intx MultiArrayExpandLimit                     = 6                                   &#123;C2 product&#125;Maximum number of individual allocations in an inline-expanded multianewarray instruction</div><div class="line">     bool MustCallLoadClassInternal                 = false                               &#123;product&#125;Call loadClassInternal() rather than loadClass()</div><div class="line">     intx NMethodSizeLimit                          = 524288                              &#123;C1 develop&#125;Maximum size of a compiled method.</div><div class="line">    uintx NUMAChunkResizeWeight                     = 20                                  &#123;product&#125;Percentage (0-100) used to weigh the current sample when computing exponentially decaying average for AdaptiveNUMAChunkSizing</div><div class="line">    uintx NUMAInterleaveGranularity                 = 2097152                             &#123;product&#125;Granularity to use for NUMA interleaving on Windows OS</div><div class="line">    uintx NUMAPageScanRate                          = 256                                 &#123;product&#125;Maximum number of pages to include in the page scan procedure</div><div class="line">    uintx NUMASpaceResizeRate                       = 1073741824                          &#123;product&#125;Do not reallocate more than this amount per collection</div><div class="line">     bool NUMAStats                                 = false                               &#123;product&#125;Print NUMA stats in detailed heap information</div><div class="line">    ccstr NativeMemoryTracking                      = off                                 &#123;product&#125;Native memory tracking options</div><div class="line">     bool NeedsDeoptSuspend                         = false                               &#123;pd product&#125;True for register window machines (sparc/ia64)</div><div class="line">     intx NestedInliningSizeRatio                   = 90                                  &#123;C1 develop&#125;Percentage of prev. allowed inline size in recursive inlining</div><div class="line">     bool NeverActAsServerClassMachine              = false                               &#123;pd product&#125;Never act like a server-class machine</div><div class="line">     bool NeverTenure                               = false                               &#123;product&#125;Never tenure objects in eden, may tenure on overflow (ParallelGC only)</div><div class="line">     intx NewCodeParameter                          = 0                                   &#123;develop&#125;Testing Only: Create a dedicated integer parameter before putback</div><div class="line">    uintx NewRatio                                  = 2                                   &#123;product&#125;Ratio of old/new generation sizes</div><div class="line">    uintx NewSize                                   = 1363144                             &#123;product&#125;Initial new generation size (in bytes)</div><div class="line">    uintx NewSizeThreadIncrease                     = 5320                                &#123;pd product&#125;Additional size added to desired new generation size per non-daemon thread (in bytes)</div><div class="line">     intx NmethodSweepActivity                      = 10                                  &#123;product&#125;Removes cold nmethods from code cache if &gt; 0. Higher values result in more aggressive sweeping</div><div class="line">     intx NmethodSweepCheckInterval                 = 5                                   &#123;product&#125;Compilers wake up every n seconds to possibly sweep nmethods</div><div class="line">     intx NmethodSweepFraction                      = 16                                  &#123;product&#125;Number of invocations of sweeper to cover all nmethods</div><div class="line">     bool NoYieldsInMicrolock                       = false                               &#123;develop&#125;Disable yields in microlock</div><div class="line">     intx NodeCountInliningCutoff                   = 18000                               &#123;C2 develop&#125;If parser node generation exceeds limit stop inlining</div><div class="line">     intx NodeCountInliningStep                     = 1000                                &#123;C2 develop&#125;Target size of warm calls inlined between optimization passes</div><div class="line">     intx NodeLimitFudgeFactor                      = 2000                                &#123;C2 product&#125;Fudge Factor for certain optimizations</div><div class="line">    uintx NumberOfGCLogFiles                        = 0                                   &#123;product&#125;Number of gclog files in rotation (default: 0, no rotation)</div><div class="line">     intx NumberOfLoopInstrToAlign                  = 4                                   &#123;C2 product&#125;Number of first instructions in a loop to align</div><div class="line">     intx OSROnlyBCI                                = -1                                  &#123;develop&#125;OSR only at this bci.  Negative values mean exclude that bci</div><div class="line">    uintx ObjArrayMarkingStride                     = 512                                 &#123;develop&#125;Number of object array elements to push onto the marking stack before pushing a continuation entry</div><div class="line">     intx ObjectAlignmentInBytes                    = 8                                   &#123;lp64_product&#125;Default object alignment in bytes, 8 is minimum</div><div class="line">    uintx OldPLABSize                               = 1024                                &#123;product&#125;Size of old gen promotion LAB&apos;s (in HeapWords)</div><div class="line">    uintx OldPLABWeight                             = 50                                  &#123;product&#125;Percentage (0-100) used to weight the current sample when computing exponentially decaying average for resizing CMSParPromoteBlocksToClaim</div><div class="line">    uintx OldSize                                   = 5452592                             &#123;product&#125;Initial tenured generation size (in bytes)</div><div class="line">     bool OmitStackTraceInFastThrow                 = true                                &#123;product&#125;Omit backtraces for some &apos;hot&apos; exceptions in optimized code</div><div class="line">ccstrlist OnError                                   =                                     &#123;product&#125;Run user-defined commands on fatal error; see VMError.cpp for examples</div><div class="line">ccstrlist OnOutOfMemoryError                        =                                     &#123;product&#125;Run user-defined commands on first java.lang.OutOfMemoryError</div><div class="line">     intx OnStackReplacePercentage                  = 140                                 &#123;pd product&#125;NON_TIERED number of method invocations/branches (expressed as % of CompileThreshold) before (re-)compiling OSR code</div><div class="line">     bool OptimizeExpensiveOps                      = true                                &#123;C2 diagnostic&#125;Find best control for expensive operations</div><div class="line">     bool OptimizeFill                              = true                                &#123;C2 product&#125;convert fill/copy loops into intrinsic</div><div class="line">     bool OptimizeIfOps                             = true                                &#123;C1 develop&#125;Optimize multiple IfOps</div><div class="line">     bool OptimizePtrCompare                        = true                                &#123;C2 product&#125;Use escape analysis to optimize pointers compare</div><div class="line">     bool OptimizeStringConcat                      = true                                &#123;C2 product&#125;Optimize the construction of Strings by StringBuilder</div><div class="line">     bool OptimizeUnsafes                           = true                                &#123;C1 develop&#125;Optimize raw unsafe ops</div><div class="line">     intx OptoBlockListSize                         = 8                                   &#123;C2 develop&#125;Starting allocation size of Block_List data structures</div><div class="line">     bool OptoBreakpoint                            = false                               &#123;C2 develop&#125;insert breakpoint at method entry</div><div class="line">     bool OptoBreakpointC2R                         = false                               &#123;C2 notproduct&#125;insert breakpoint at runtime stub entry</div><div class="line">     bool OptoBreakpointOSR                         = false                               &#123;C2 notproduct&#125;insert breakpoint at osr method entry</div><div class="line">     bool OptoBundling                              = false                               &#123;C2 pd product&#125;Generate nops to fill i-cache lines</div><div class="line">     bool OptoCoalesce                              = true                                &#123;C2 develop&#125;Use Conservative Copy Coalescing in the Register Allocator</div><div class="line">     intx OptoLoopAlignment                         = 16                                  &#123;pd product&#125;Align inner loops to zero relative to this modulus</div><div class="line">     bool OptoNoExecute                             = false                               &#123;C2 notproduct&#125;Attempt to parse and compile but do not execute generated code</div><div class="line">     intx OptoNodeListSize                          = 4                                   &#123;C2 develop&#125;Starting allocation size of Node_List data structures</div><div class="line">     bool OptoPeephole                              = true                                &#123;C2 pd develop&#125;Apply peephole optimizations after register allocation</div><div class="line">     intx OptoPeepholeAt                            = -1                                  &#123;C2 develop&#125;Apply peephole optimizations to this peephole rule</div><div class="line">     intx OptoPrologueNops                          = 0                                   &#123;C2 develop&#125;Insert this many extra nop instructions in the prologue of every nmethod</div><div class="line">     bool OptoRemoveUseless                         = true                                &#123;C2 develop&#125;Remove useless nodes after parsing</div><div class="line">     bool OptoScheduling                            = false                               &#123;C2 pd product&#125;Instruction Scheduling after register allocation</div><div class="line">    uintx PLABWeight                                = 75                                  &#123;product&#125;Percentage (0-100) used to weigh the current sample when computing exponentially decaying average for ResizePLAB</div><div class="line">     intx PSAdaptiveSizePolicyResizeVirtualSpaceAlot  = -1                                  &#123;develop&#125;Resize the virtual spaces of the young or old generations</div><div class="line">     bool PSAdjustTenuredGenForMinorPause           = false                               &#123;develop&#125;Adjust tenured generation to achieve a minor pause goal</div><div class="line">     bool PSAdjustYoungGenForMajorPause             = false                               &#123;develop&#125;Adjust young generation to achieve a major pause goal</div><div class="line">     bool PSChunkLargeArrays                        = true                                &#123;product&#125;Process large arrays in chunks</div><div class="line">     intx ParGCArrayScanChunk                       = 50                                  &#123;product&#125;Scan a subset of object array and push remainder, if array is bigger than this</div><div class="line">     intx ParGCCardsPerStrideChunk                  = 256                                 &#123;diagnostic&#125;The number of cards in each chunk of the parallel chunks used during card table scanning</div><div class="line">    uintx ParGCDesiredObjsFromOverflowList          = 20                                  &#123;product&#125;The desired number of objects to claim from the overflow list</div><div class="line">    uintx ParGCStridesPerThread                     = 2                                   &#123;diagnostic&#125;The number of strides per worker thread that we divide up the card table scanning work into</div><div class="line">     bool ParGCTrimOverflow                         = true                                &#123;product&#125;Eagerly trim the local overflow lists (when ParGCUseLocalOverflow)</div><div class="line">     bool ParGCUseLocalOverflow                     = false                               &#123;product&#125;Instead of a global overflow list, use local overflow stacks</div><div class="line">     bool ParGCWorkQueueOverflowALot                = false                               &#123;notproduct&#125;Simulate work queue overflow in ParNew</div><div class="line">    uintx ParGCWorkQueueOverflowInterval            = 1000                                &#123;notproduct&#125;An `interval&apos; counter that determines how frequently we simulate overflow; a smaller number increases frequency</div><div class="line">    uintx ParallelGCBufferWastePct                  = 10                                  &#123;product&#125;Wasted fraction of parallel allocation buffer</div><div class="line">     bool ParallelGCRetainPLAB                      = false                               &#123;diagnostic&#125;Retain parallel allocation buffers across scavenges; it is disabled because this currently conflicts with parallel card scanning under certain conditions.</div><div class="line">    uintx ParallelGCThreads                         = 0                                   &#123;product&#125;Number of parallel threads parallel gc will use</div><div class="line">     bool ParallelGCVerbose                         = false                               &#123;product&#125;Verbose output for parallel gc</div><div class="line">    uintx ParallelOldDeadWoodLimiterMean            = 50                                  &#123;product&#125;The mean used by the parallel compact dead wood limiter (a number between 0-100)</div><div class="line">    uintx ParallelOldDeadWoodLimiterStdDev          = 80                                  &#123;product&#125;The standard deviation used by the parallel compact dead wood limiter (a number between 0-100)</div><div class="line">     bool ParallelOldGCSplitALot                    = false                               &#123;develop&#125;Provoke splitting (copying data from a young gen space to multiple destination spaces)</div><div class="line">    uintx ParallelOldGCSplitInterval                = 3                                   &#123;develop&#125;How often to provoke splitting a young gen space</div><div class="line">     bool ParallelRefProcBalancingEnabled           = true                                &#123;product&#125;Enable balancing of reference processing queues</div><div class="line">     bool ParallelRefProcEnabled                    = false                               &#123;product&#125;Enable parallel reference processing whenever possible</div><div class="line">     bool PartialPeelAtUnsignedTests                = true                                &#123;C2 product&#125;Partial peel at unsigned tests if no signed test exists</div><div class="line">     bool PartialPeelLoop                           = true                                &#123;C2 product&#125;Partial peel (rotate) loops</div><div class="line">     intx PartialPeelNewPhiDelta                    = 0                                   &#123;C2 product&#125;Additional phis that can be created by partial peeling</div><div class="line">     bool PatchALot                                 = false                               &#123;C1 develop&#125;Marks all fields as having unloaded classes</div><div class="line">     bool PauseAtExit                               = false                               &#123;diagnostic&#125;Pause and wait for keypress on exit if a debugger is attached</div><div class="line">     bool PauseAtStartup                            = false                               &#123;diagnostic&#125;Causes the VM to pause at startup time and wait for the pause file to be removed (default: ./vm.paused.&lt;pid&gt;)</div><div class="line">    ccstr PauseAtStartupFile                        =                                     &#123;diagnostic&#125;The file to create and for whose removal to await when pausing at startup. (default: ./vm.paused.&lt;pid&gt;)</div><div class="line">    uintx PausePadding                              = 1                                   &#123;product&#125;How much buffer to keep for pause time</div><div class="line">     intx PerBytecodeRecompilationCutoff            = 200                                 &#123;product&#125;Per-BCI limit on repeated recompilation (-1=&gt;&apos;Inf&apos;)</div><div class="line">     intx PerBytecodeTrapLimit                      = 4                                   &#123;product&#125;Limit on traps (of one kind) at a particular BCI</div><div class="line">     intx PerMethodRecompilationCutoff              = 400                                 &#123;product&#125;After recompiling N times, stay in the interpreter (-1=&gt;&apos;Inf&apos;)</div><div class="line">     intx PerMethodTrapLimit                        = 100                                 &#123;product&#125;Limit on traps (of one kind) in a method (includes inlines)</div><div class="line">     bool PerfAllowAtExitRegistration               = false                               &#123;product&#125;Allow registration of atexit() methods</div><div class="line">     bool PerfBypassFileSystemCheck                 = false                               &#123;product&#125;Bypass Win32 file system criteria checks (Windows Only)</div><div class="line">     intx PerfDataMemorySize                        = 32768                               &#123;product&#125;Size of performance data memory region. Will be rounded up to a multiple of the native os page size.</div><div class="line">     intx PerfDataSamplingInterval                  = 50                                  &#123;product&#125;Data sampling interval (in milliseconds)</div><div class="line">    ccstr PerfDataSaveFile                          =                                     &#123;product&#125;Save PerfData memory to the specified absolute pathname. The string %p in the file name (if present) will be replaced by pid</div><div class="line">     bool PerfDataSaveToFile                        = false                               &#123;product&#125;Save PerfData memory to hsperfdata_&lt;pid&gt; file on exit</div><div class="line">     bool PerfDisableSharedMem                      = false                               &#123;product&#125;Store performance data in standard memory</div><div class="line">     intx PerfMaxStringConstLength                  = 1024                                &#123;product&#125;Maximum PerfStringConstant string length before truncation</div><div class="line">     bool PerfTraceDataCreation                     = false                               &#123;develop&#125;Trace creation of Performance Data Entries</div><div class="line">     bool PerfTraceMemOps                           = false                               &#123;develop&#125;Trace PerfMemory create/attach/detach calls</div><div class="line">     bool PinAllInstructions                        = false                               &#123;C1 develop&#125;All instructions are pinned</div><div class="line">     bool PoisonOSREntry                            = true                                &#123;C2 develop&#125;Detect abnormal calls to OSR code</div><div class="line">     intx PreInflateSpin                            = 10                                  &#123;pd product&#125;Number of times to spin wait before inflation</div><div class="line">    uintx PreallocatedOutOfMemoryErrorCount         = 4                                   &#123;develop&#125;Number of OutOfMemoryErrors preallocated with backtrace</div><div class="line">     bool PreferInterpreterNativeStubs              = false                               &#123;pd product&#125;Use always interpreter stubs for native methods invoked via interpreter</div><div class="line">     intx PrefetchCopyIntervalInBytes               = -1                                  &#123;product&#125;How far ahead to prefetch destination area (&lt;= 0 means off)</div><div class="line">     intx PrefetchFieldsAhead                       = -1                                  &#123;product&#125;How many fields ahead to prefetch in oop scan (&lt;= 0 means off)</div><div class="line">     intx PrefetchScanIntervalInBytes               = -1                                  &#123;product&#125;How far ahead to prefetch scan area (&lt;= 0 means off)</div><div class="line">     bool PreserveAllAnnotations                    = false                               &#123;product&#125;Preserve RuntimeInvisibleAnnotations as well as RuntimeVisibleAnnotations</div><div class="line">     bool PreserveFramePointer                      = false                               &#123;pd product&#125;Use the FP register for holding the frame pointer and not as a general purpose register.</div><div class="line">    uintx PretenureSizeThreshold                    = 0                                   &#123;product&#125;Maximum size in bytes of objects allocated in DefNew generation; zero means no maximum</div><div class="line">     bool PrintAdapterHandlers                      = false                               &#123;diagnostic&#125;Print code generated for i2c/c2i adapters</div><div class="line">     bool PrintAdaptiveSizePolicy                   = false                               &#123;product&#125;Print information about AdaptiveSizePolicy</div><div class="line">     bool PrintAssembly                             = false                               &#123;diagnostic&#125;Print assembly code (using external disassembler.so)</div><div class="line">    ccstr PrintAssemblyOptions                      =                                     &#123;diagnostic&#125;Print options string passed to disassembler.so</div><div class="line">     bool PrintBailouts                             = false                               &#123;C1 develop&#125;Print bailout and its reason</div><div class="line">     bool PrintBiasedLockingStatistics              = false                               &#123;diagnostic&#125;Print statistics of biased locking in JVM</div><div class="line">     bool PrintBlockElimination                     = false                               &#123;C1 develop&#125;Print basic block elimination</div><div class="line">     bool PrintBytecodeHistogram                    = false                               &#123;develop&#125;Print histogram of the executed bytecodes</div><div class="line">     bool PrintBytecodePairHistogram                = false                               &#123;develop&#125;Print histogram of the executed bytecode pairs</div><div class="line">     bool PrintC1Statistics                         = false                               &#123;C1 notproduct&#125;Print Compiler1 statistics</div><div class="line">     bool PrintCEE                                  = false                               &#123;C1 develop&#125;Print Conditional Expression Elimination</div><div class="line">     bool PrintCFG                                  = false                               &#123;C1 notproduct&#125;Print control flow graph after each change</div><div class="line">     bool PrintCFG0                                 = false                               &#123;C1 notproduct&#125;Print control flow graph after construction</div><div class="line">     bool PrintCFG1                                 = false                               &#123;C1 notproduct&#125;Print control flow graph after optimizations</div><div class="line">     bool PrintCFG2                                 = false                               &#123;C1 notproduct&#125;Print control flow graph before code generation</div><div class="line">     bool PrintCFGBlockFreq                         = false                               &#123;C2 develop&#125;Print CFG block freqencies</div><div class="line">     bool PrintCFGToFile                            = false                               &#123;C1 develop&#125;print control flow graph to a separate file during compilation</div><div class="line">     bool PrintCMSInitiationStatistics              = false                               &#123;product&#125;Statistics for initiating a CMS collection</div><div class="line">     intx PrintCMSStatistics                        = 0                                   &#123;product&#125;Statistics for CMS</div><div class="line">     bool PrintCanonicalization                     = false                               &#123;C1 develop&#125;Print graph node canonicalization</div><div class="line">     bool PrintClassHistogram                       = false                               &#123;manageable&#125;Print a histogram of class instances</div><div class="line">     bool PrintClassHistogramAfterFullGC            = false                               &#123;manageable&#125;Print a class histogram after any major stop-world GC</div><div class="line">     bool PrintClassHistogramBeforeFullGC           = false                               &#123;manageable&#125;Print a class histogram before any major stop-world GC</div><div class="line">     bool PrintClassStatistics                      = false                               &#123;notproduct&#125;Print class statistics at end of run</div><div class="line">     bool PrintCodeCache                            = false                               &#123;product&#125;Print the code cache memory usage when exiting</div><div class="line">     bool PrintCodeCache2                           = false                               &#123;develop&#125;Print detailed usage information on the code cache when exiting</div><div class="line">     bool PrintCodeCacheExtension                   = false                               &#123;develop&#125;Print extension of code cache</div><div class="line">     bool PrintCodeCacheOnCompilation               = false                               &#123;product&#125;Print the code cache memory usage each time a method is compiled</div><div class="line">     bool PrintCommandLineFlags                     = false                               &#123;product&#125;Print flags specified on command line or set by ergonomics</div><div class="line">     bool PrintCompilation                          = false                               &#123;product&#125;Print compilations</div><div class="line">     bool PrintCompilation2                         = false                               &#123;diagnostic&#125;Print additional statistics per compilation</div><div class="line">     bool PrintCompressedOopsMode                   = false                               &#123;diagnostic&#125;Print compressed oops base address and encoding mode</div><div class="line">     bool PrintConcurrentLocks                      = false                               &#123;manageable&#125;Print java.util.concurrent locks in thread dump</div><div class="line">     bool PrintDTraceDOF                            = false                               &#123;diagnostic&#125;Print the DTrace DOF passed to the system for JSDT probes</div><div class="line">     bool PrintDebugInfo                            = false                               &#123;develop&#125;Print debug information for all nmethods when generated</div><div class="line">     bool PrintDependencies                         = false                               &#123;develop&#125;Print dependency information for all nmethods when generated</div><div class="line">     bool PrintDominators                           = false                               &#123;C2 develop&#125;Print out dominator trees for GVN</div><div class="line">     bool PrintEliminateAllocations                 = false                               &#123;C2 notproduct&#125;Print out when allocations are eliminated</div><div class="line">     bool PrintEliminateLocks                       = false                               &#123;C2 notproduct&#125;Print out when locks are eliminated</div><div class="line">     bool PrintEscapeAnalysis                       = false                               &#123;C2 notproduct&#125;Print the results of escape analysis</div><div class="line">     bool PrintExceptionHandlers                    = false                               &#123;develop&#125;Print exception handler tables for all nmethods when generated</div><div class="line">     intx PrintFLSCensus                            = 0                                   &#123;product&#125;Census for CMS&apos; FreeListSpace</div><div class="line">     intx PrintFLSStatistics                        = 0                                   &#123;product&#125;Statistics for CMS&apos; FreeListSpace</div><div class="line">     bool PrintFieldLayout                          = false                               &#123;notproduct&#125;Print field layout for each class</div><div class="line">     bool PrintFlagsFinal                           = false                               &#123;product&#125;Print all VM flags after argument and ergonomic processing</div><div class="line">     bool PrintFlagsInitial                         = false                               &#123;product&#125;Print all VM flags before argument processing and exit VM</div><div class="line">     bool PrintFlagsWithComments                    = false                               &#123;notproduct&#125;Print all VM flags with default values and descriptions and exit</div><div class="line">     bool PrintFrameConverterAssembly               = false                               &#123;C2 notproduct&#125;Print New compiler assembly output for frame converters</div><div class="line">     bool PrintGC                                   = false                               &#123;manageable&#125;Print message at garbage collection</div><div class="line">     bool PrintGCApplicationConcurrentTime          = false                               &#123;product&#125;Print the time the application has been running</div><div class="line">     bool PrintGCApplicationStoppedTime             = false                               &#123;product&#125;Print the time the application has been stopped</div><div class="line">     bool PrintGCCause                              = true                                &#123;product&#125;Include GC cause in GC logging</div><div class="line">     bool PrintGCDateStamps                         = false                               &#123;manageable&#125;Print date stamps at garbage collection</div><div class="line">     bool PrintGCDetails                            = false                               &#123;manageable&#125;Print more details at garbage collection</div><div class="line">     bool PrintGCID                                 = false                               &#123;manageable&#125;Print an identifier for each garbage collection</div><div class="line">     bool PrintGCTaskTimeStamps                     = false                               &#123;product&#125;Print timestamps for individual gc worker thread tasks</div><div class="line">     bool PrintGCTimeStamps                         = false                               &#123;manageable&#125;Print timestamps at garbage collection</div><div class="line">     bool PrintHeapAtGC                             = false                               &#123;product rw&#125;Print heap layout before and after each GC</div><div class="line">     bool PrintHeapAtGCExtended                     = false                               &#123;product rw&#125;Print extended information about the layout of the heap when -XX:+PrintHeapAtGC is set</div><div class="line">     bool PrintHeapAtSIGBREAK                       = true                                &#123;product&#125;Print heap layout in response to SIGBREAK</div><div class="line">     bool PrintIR                                   = false                               &#123;C1 notproduct&#125;Print full intermediate representation after each change</div><div class="line">     bool PrintIR0                                  = false                               &#123;C1 notproduct&#125;Print full intermediate representation after construction</div><div class="line">     bool PrintIR1                                  = false                               &#123;C1 notproduct&#125;Print full intermediate representation after optimizations</div><div class="line">     bool PrintIR2                                  = false                               &#123;C1 notproduct&#125;Print full intermediate representation before code generation</div><div class="line">     bool PrintIRDuringConstruction                 = false                               &#123;C1 notproduct&#125;Print IR as it&apos;s being constructed (helpful for debugging frontend)</div><div class="line">     bool PrintIRWithLIR                            = false                               &#123;C1 notproduct&#125;Print IR instructions with generated LIR</div><div class="line">     bool PrintIdeal                                = false                               &#123;C2 notproduct&#125;Print ideal graph before code generation</div><div class="line">    ccstr PrintIdealGraphAddress                    = 127.0.0.1                           &#123;C2 notproduct&#125;IP address to connect to visualizer</div><div class="line">    ccstr PrintIdealGraphFile                       =                                     &#123;C2 notproduct&#125;File to dump ideal graph to.  If set overrides the use of the network</div><div class="line">     intx PrintIdealGraphLevel                      = 0                                   &#123;C2 develop&#125;Print ideal graph to XML file / network interface. By default attempts to connect to the visualizer on a socket.</div><div class="line">     intx PrintIdealGraphPort                       = 4444                                &#123;C2 develop&#125;Ideal graph printer to network port</div><div class="line">     bool PrintIdealNodeCount                       = false                               &#123;C2 notproduct&#125;Print liveness counts of ideal nodes</div><div class="line">     bool PrintInitialBlockList                     = false                               &#123;C1 notproduct&#125;Print block list of BlockListBuilder</div><div class="line">     bool PrintInlining                             = false                               &#123;diagnostic&#125;Print inlining optimizations</div><div class="line">     bool PrintInterpreter                          = false                               &#123;diagnostic&#125;Print the generated interpreter code</div><div class="line">     bool PrintIntrinsics                           = false                               &#123;C2 diagnostic&#125;prints attempted and successful inlining of intrinsics</div><div class="line">     bool PrintJNIGCStalls                          = false                               &#123;product&#125;Print diagnostic message when GC is stalled by JNI critical section</div><div class="line">     bool PrintJNIResolving                         = false                               &#123;product&#125;Used to implement -v:jni</div><div class="line">     bool PrintJVMWarnings                          = false                               &#123;develop&#125;Print warnings for unimplemented JVM functions</div><div class="line">     bool PrintLIR                                  = false                               &#123;C1 develop&#125;print low-level IR</div><div class="line">     bool PrintLIRWithAssembly                      = false                               &#123;C1 notproduct&#125;Show LIR instruction with generated assembly</div><div class="line">     bool PrintLockStatistics                       = false                               &#123;C2 notproduct&#125;Print precise statistics on the dynamic lock usage</div><div class="line">     bool PrintMalloc                               = false                               &#123;develop&#125;Print all malloc/free calls</div><div class="line">     bool PrintMallocFree                           = false                               &#123;notproduct&#125;Trace calls to C heap malloc/free allocation</div><div class="line">     bool PrintMallocStatistics                     = false                               &#123;develop&#125;Print malloc/free statistics</div><div class="line">     bool PrintMethodData                           = false                               &#123;develop&#125;Print the results of +ProfileInterpreter at end of run</div><div class="line">     bool PrintMethodFlushing                       = false                               &#123;develop&#125;Print the nmethods being flushed</div><div class="line">     bool PrintMethodFlushingStatistics             = false                               &#123;diagnostic&#125;print statistics about method flushing</div><div class="line">     bool PrintMethodHandleStubs                    = false                               &#123;diagnostic&#125;Print generated stub code for method handles</div><div class="line">     bool PrintMethodStatistics                     = false                               &#123;notproduct&#125;Print method statistics at end of run</div><div class="line">     bool PrintMiscellaneous                        = false                               &#123;develop&#125;Print uncategorized debugging information (requires +Verbose)</div><div class="line">     bool PrintNMTStatistics                        = false                               &#123;diagnostic&#125;Print native memory tracking summary data if it is on</div><div class="line">     bool PrintNMethods                             = false                               &#123;diagnostic&#125;Print assembly code for nmethods when generated</div><div class="line">     bool PrintNativeNMethods                       = false                               &#123;diagnostic&#125;Print assembly code for native nmethods when generated</div><div class="line">     bool PrintNotLoaded                            = false                               &#123;C1 develop&#125;Prints where classes are not loaded during code generation</div><div class="line">     bool PrintNullCheckElimination                 = false                               &#123;C1 develop&#125;Print null check elimination</div><div class="line">     bool PrintOldPLAB                              = false                               &#123;product&#125;Print (old gen) promotion LAB&apos;s sizing decisions</div><div class="line">     bool PrintOopAddress                           = false                               &#123;product&#125;Always print the location of the oop</div><div class="line">     bool PrintOptimizePtrCompare                   = false                               &#123;C2 notproduct&#125;Print information about optimized pointers compare</div><div class="line">     bool PrintOptimizeStringConcat                 = false                               &#123;C2 notproduct&#125;Print information about transformations performed on Strings</div><div class="line">     bool PrintOpto                                 = false                               &#123;C2 notproduct&#125;Print compiler2 attempts</div><div class="line">     bool PrintOptoAssembly                         = false                               &#123;C2 notproduct&#125;Print New compiler assembly output</div><div class="line">     bool PrintOptoInlining                         = false                               &#123;C2 notproduct&#125;Print compiler2 inlining decisions</div><div class="line">     bool PrintOptoPeephole                         = false                               &#123;C2 notproduct&#125;Print New compiler peephole replacements</div><div class="line">     bool PrintOptoStatistics                       = false                               &#123;C2 notproduct&#125;Print New compiler statistics</div><div class="line">     bool PrintPLAB                                 = false                               &#123;product&#125;Print (survivor space) promotion LAB&apos;s sizing decisions</div><div class="line">     bool PrintParallelOldGCPhaseTimes              = false                               &#123;product&#125;Print the time taken by each phase in ParallelOldGC (PrintGCDetails must also be enabled)</div><div class="line">     bool PrintParseStatistics                      = false                               &#123;C2 notproduct&#125;Print nodes, transforms and new values made per bytecode parsed</div><div class="line">     bool PrintPhiFunctions                         = false                               &#123;C1 notproduct&#125;Print phi functions when they are created and simplified</div><div class="line">     bool PrintPreciseBiasedLockingStatistics       = false                               &#123;C2 diagnostic&#125;Print per-lock-site statistics of biased locking in JVM</div><div class="line">     bool PrintPreciseRTMLockingStatistics          = false                               &#123;C2 diagnostic&#125;Print per-lock-site statistics of rtm locking in JVM</div><div class="line">     bool PrintPromotionFailure                     = false                               &#123;product&#125;Print additional diagnostic information following promotion failure</div><div class="line">     bool PrintReferenceGC                          = false                               &#123;product&#125;Print times spent handling reference objects during GC (enabled only when PrintGCDetails)</div><div class="line">     bool PrintRelocations                          = false                               &#123;develop&#125;Print relocation information for all nmethods when generated</div><div class="line">     bool PrintRewrites                             = false                               &#123;notproduct&#125;Print methods that are being rewritten</div><div class="line">     bool PrintSafepointStatistics                  = false                               &#123;product&#125;Print statistics about safepoint synchronization</div><div class="line">     intx PrintSafepointStatisticsCount             = 300                                 &#123;product&#125;Total number of safepoint statistics collected before printing them out</div><div class="line">     intx PrintSafepointStatisticsTimeout           = -1                                  &#123;product&#125;Print safepoint statistics only when safepoint takes more than PrintSafepointSatisticsTimeout in millis</div><div class="line">     bool PrintSharedArchiveAndExit                 = false                               &#123;product&#125;Print shared archive file contents</div><div class="line">     bool PrintSharedDictionary                     = false                               &#123;product&#125;If PrintSharedArchiveAndExit is true, also print the shared dictionary</div><div class="line">     bool PrintSharedSpaces                         = false                               &#123;product&#125;Print usage of shared spaces</div><div class="line">     bool PrintSignatureHandlers                    = false                               &#123;diagnostic&#125;Print code generated for native method signature handlers</div><div class="line">     bool PrintSimpleStubs                          = false                               &#123;C1 notproduct&#125;Print SimpleStubs</div><div class="line">     bool PrintStringDeduplicationStatistics        = false                               &#123;product&#125;Print string deduplication statistics</div><div class="line">     bool PrintStringTableStatistics                = false                               &#123;product&#125;print statistics about the StringTable and SymbolTable</div><div class="line">     bool PrintStubCode                             = false                               &#123;diagnostic&#125;Print generated stub code</div><div class="line">     bool PrintSymbolTableSizeHistogram             = false                               &#123;notproduct&#125;print histogram of the symbol table</div><div class="line">     bool PrintSystemDictionaryAtExit               = false                               &#123;notproduct&#125;Print the system dictionary at exit</div><div class="line">     bool PrintTLAB                                 = false                               &#123;product&#125;Print various TLAB related information</div><div class="line">     bool PrintTenuringDistribution                 = false                               &#123;product&#125;Print tenuring age information</div><div class="line">     bool PrintTieredEvents                         = false                               &#123;product&#125;Print tiered events notifications</div><div class="line">     bool PrintUnsafeOptimization                   = false                               &#123;C1 develop&#125;Print optimization of raw unsafe ops</div><div class="line">     bool PrintVMMessages                           = true                                &#123;develop&#125;Print VM messages on console</div><div class="line">     bool PrintVMOptions                            = false                               &#123;product&#125;Print flags that appeared on the command line</div><div class="line">     bool PrintVMQWaitTime                          = false                               &#123;product&#125;Print out the waiting time in VM operation queue</div><div class="line">     bool PrintValueNumbering                       = false                               &#123;C1 develop&#125;Print Value Numbering</div><div class="line">     bool PrintVtableStats                          = false                               &#123;notproduct&#125;print vtables stats at end of run</div><div class="line">     bool PrintVtables                              = false                               &#123;develop&#125;print vtables when printing klass</div><div class="line">     bool PrintWarnings                             = true                                &#123;product&#125;Print JVM warnings to output stream</div><div class="line">    uintx ProcessDistributionStride                 = 4                                   &#123;product&#125;Stride through processors when distributing processes</div><div class="line">     bool ProfileDynamicTypes                       = true                                &#123;C2 diagnostic&#125;do extra type profiling and use it more aggressively</div><div class="line">     bool ProfileInterpreter                        = true                                &#123;pd product&#125;Profile at the bytecode level during interpretation</div><div class="line">     bool ProfileIntervals                          = false                               &#123;product&#125;Print profiles for each interval (see ProfileIntervalsTicks)</div><div class="line">     intx ProfileIntervalsTicks                     = 100                                 &#123;product&#125;Number of ticks between printing of interval profile (+ProfileIntervals)</div><div class="line">     intx ProfileMaturityPercentage                 = 20                                  &#123;product&#125;number of method invocations/branches (expressed as % of CompileThreshold) before using the method&apos;s profile</div><div class="line">     bool ProfileTraps                              = true                                &#123;pd develop&#125;Profile deoptimization traps at the bytecode level</div><div class="line">     bool ProfileVM                                 = false                               &#123;product&#125;Profile ticks that fall within VM (either in the VM Thread or VM code called through stubs)</div><div class="line">     bool ProfilerCheckIntervals                    = false                               &#123;notproduct&#125;Collect and print information on spacing of profiler ticks</div><div class="line">     intx ProfilerNodeSize                          = 1024                                &#123;develop&#125;Size in K to allocate for the Profile Nodes of each thread</div><div class="line">     intx ProfilerNumberOfCompiledMethods           = 25                                  &#123;develop&#125;Number of compiled methods to show in profile</div><div class="line">     intx ProfilerNumberOfInterpretedMethods        = 25                                  &#123;develop&#125;Number of interpreted methods to show in profile</div><div class="line">     intx ProfilerNumberOfRuntimeStubNodes          = 25                                  &#123;develop&#125;Number of runtime stub nodes to show in profile</div><div class="line">     intx ProfilerNumberOfStubMethods               = 25                                  &#123;develop&#125;Number of stub methods to show in profile</div><div class="line">     intx ProfilerPCTickThreshold                   = 15                                  &#123;develop&#125;Number of ticks in a PC buckets to be a hotspot</div><div class="line">     bool ProfilerPrintByteCodeStatistics           = false                               &#123;product&#125;Print bytecode statistics when dumping profiler output</div><div class="line">     bool ProfilerRecordPC                          = false                               &#123;product&#125;Collect ticks for each 16 byte interval of compiled code</div><div class="line">    uintx PromotedPadding                           = 3                                   &#123;product&#125;How much buffer to keep for promotion failure</div><div class="line">     bool PromotionFailureALot                      = false                               &#123;notproduct&#125;Use promotion failure handling on every youngest generation collection</div><div class="line">    uintx PromotionFailureALotCount                 = 1000                                &#123;develop&#125;Number of promotion failures occurring at ParGCAllocBuffer refill attempts (ParNew) or promotion attempts (other young collectors)</div><div class="line">    uintx PromotionFailureALotInterval              = 5                                   &#123;develop&#125;Total collections between promotion failures alot</div><div class="line">     bool ProtectionDomainVerification              = true                                &#123;develop&#125;Verify protection domain before resolution in system dictionary</div><div class="line">    uintx QueuedAllocationWarningCount              = 0                                   &#123;product&#125;Number of times an allocation that queues behind a GC will retry before printing a warning</div><div class="line">    uintx RTMRetryCount                             = 5                                   &#123;ARCH product&#125;Number of RTM retries on lock abort or busy</div><div class="line">     bool RangeCheckElimination                     = true                                &#123;product&#125;Eliminate range checks</div><div class="line">     bool RangeLimitCheck                           = true                                &#123;C2 diagnostic&#125;Additional overflow checks during range check elimination</div><div class="line">     intx ReadPrefetchInstr                         = 0                                   &#123;ARCH product&#125;Prefetch instruction to prefetch ahead</div><div class="line">     bool ReassociateInvariants                     = true                                &#123;C2 product&#125;Enable reassociation of expressions with loop invariants.</div><div class="line">     bool ReduceBulkZeroing                         = true                                &#123;C2 product&#125;When bulk-initializing, try to avoid needless zeroing</div><div class="line">     bool ReduceFieldZeroing                        = true                                &#123;C2 product&#125;When initializing fields, try to avoid needless zeroing</div><div class="line">     bool ReduceInitialCardMarks                    = true                                &#123;C2 product&#125;When initializing fields, try to avoid needless card marks</div><div class="line">     bool ReduceSignalUsage                         = false                               &#123;product&#125;Reduce the use of OS signals in Java and/or the VM</div><div class="line">     intx RefDiscoveryPolicy                        = 0                                   &#123;product&#125;Select type of reference discovery policy: reference-based(0) or referent-based(1)</div><div class="line">     bool ReflectionWrapResolutionErrors            = true                                &#123;product&#125;Temporary flag for transition to AbstractMethodError wrapped in InvocationTargetException. See 6531596</div><div class="line">     intx RegisterCostAreaRatio                     = 16000                               &#123;C2 pd develop&#125;Spill selection in reg allocator: scale area by (X/64K) before adding cost</div><div class="line">     bool RegisterFinalizersAtInit                  = true                                &#123;product&#125;Register finalizable objects at end of Object.&lt;init&gt; or after allocation</div><div class="line">     bool RegisterReferences                        = true                                &#123;develop&#125;Tell whether the VM should register soft/weak/final/phantom references</div><div class="line">     bool RelaxAccessControlCheck                   = false                               &#123;product&#125;Relax the access control checks in the verifier</div><div class="line">     bool RenumberLiveNodes                         = true                                &#123;C2 develop&#125;Renumber live nodes</div><div class="line">     bool ReplayCompiles                            = false                               &#123;develop&#125;Enable replay of compilations from ReplayDataFile</div><div class="line">    ccstr ReplayDataFile                            =                                     &#123;product&#125;File containing compilation replay information[default: ./replay_pid%p.log] (%p replaced with pid)</div><div class="line">     bool ReplayIgnoreInitErrors                    = false                               &#123;develop&#125;Ignore exceptions thrown during initialization for replay</div><div class="line">     intx ReplaySuppressInitializers                = 2                                   &#123;develop&#125;Control handling of class initialization during replay: 0 - don&apos;t do anything special; 1 - treat all class initializers as empty; 2 - treat class initializers for application classes as empty; 3 - allow all class initializers to run during bootstrap but     pretend they are empty after starting replay</div><div class="line">     bool RequireSharedSpaces                       = false                               &#123;product&#125;Require shared spaces for metadata</div><div class="line">    uintx ReservedCodeCacheSize                     = 50331648                            &#123;pd product&#125;Reserved code cache size (in bytes) - maximum code cache size</div><div class="line">     bool ResizeOldPLAB                             = true                                &#123;product&#125;Dynamically resize (old gen) promotion LAB&apos;s</div><div class="line">     bool ResizePLAB                                = true                                &#123;product&#125;Dynamically resize (survivor space) promotion LAB&apos;s</div><div class="line">     bool ResizeTLAB                                = true                                &#123;pd product&#125;Dynamically resize TLAB size for threads</div><div class="line">     bool RestoreMXCSROnJNICalls                    = false                               &#123;product&#125;Restore MXCSR when returning from JNI calls</div><div class="line">     bool RestrictContended                         = true                                &#123;product&#125;Restrict @Contended to trusted classes</div><div class="line">     bool RewriteBytecodes                          = true                                &#123;pd product&#125;Allow rewriting of bytecodes (bytecodes are not immutable)</div><div class="line">     bool RewriteFrequentPairs                      = true                                &#123;pd product&#125;Rewrite frequently used bytecode pairs into a single bytecode</div><div class="line">     bool RotateCMSCollectionTypes                  = false                               &#123;develop&#125;Rotate the CMS collections among concurrent and STW</div><div class="line">     bool RoundFPResults                            = true                                &#123;C1 pd develop&#125;Indicates whether rounding is needed for floating point results</div><div class="line">     bool SafepointALot                             = false                               &#123;develop&#125;Generate a lot of safepoints. This works with GuaranteedSafepointInterval</div><div class="line">     intx SafepointPollOffset                       = 256                                 &#123;C1 pd product&#125;Offset added to polling address (Intel only)</div><div class="line">     intx SafepointSpinBeforeYield                  = 2000                                &#123;product&#125;(Unstable)</div><div class="line">     bool SafepointTimeout                          = false                               &#123;product&#125;Time out and warn or fail after SafepointTimeoutDelay milliseconds if failed to reach safepoint</div><div class="line">     intx SafepointTimeoutDelay                     = 10000                               &#123;product&#125;Delay in milliseconds for option SafepointTimeout</div><div class="line">     bool ScavengeALot                              = false                               &#123;notproduct&#125;Force scavenge at every Nth exit from the runtime system (N=ScavengeALotInterval)</div><div class="line">     intx ScavengeALotInterval                      = 1                                   &#123;notproduct&#125;Interval between which scavenge will occur with +ScavengeALot</div><div class="line">     bool ScavengeBeforeFullGC                      = true                                &#123;product&#125;Scavenge youngest generation before each full GC, used with UseParallelGC</div><div class="line">     intx ScavengeRootsInCode                       = 2                                   &#123;diagnostic&#125;0: do not allow scavengable oops in the code cache; 1: allow scavenging from the code cache; 2: emit as many constants as the compiler can see</div><div class="line">     bool ScavengeWithObjectsInToSpace              = false                               &#123;develop&#125;Allow scavenges to occur when to-space contains objects</div><div class="line">    uintx SegmentedHeapDumpThreshold                = 2147483648                          &#123;develop&#125;Generate a segmented heap dump (JAVA PROFILE 1.0.2 format) when the heap usage is larger than this</div><div class="line">     bool SelectivePhiFunctions                     = true                                &#123;C1 develop&#125;create phi functions at loop headers only when necessary</div><div class="line">     intx SelfDestructTimer                         = 0                                   &#123;product&#125;Will cause VM to terminate after a given time (in minutes) (0 means off)</div><div class="line">     bool SerializeVMOutput                         = true                                &#123;diagnostic&#125;Use a mutex to serialize output to tty and LogFile</div><div class="line">     bool ShareVtableStubs                          = true                                &#123;pd develop&#125;Share vtable stubs (smaller code but worse branch prediction</div><div class="line">    ccstr SharedArchiveFile                         =                                     &#123;diagnostic&#125;Override the default location of the CDS archive file</div><div class="line">    uintx SharedBaseAddress                         = 34359738368                         &#123;product&#125;Address to allocate shared memory region for class data</div><div class="line">    ccstr SharedClassListFile                       =                                     &#123;product&#125;Override the default CDS class list</div><div class="line">    uintx SharedMiscCodeSize                        = 122880                              &#123;product&#125;Size of the shared miscellaneous code area (in bytes)</div><div class="line">    uintx SharedMiscDataSize                        = 4194304                             &#123;product&#125;Size of the shared miscellaneous data area (in bytes)</div><div class="line">    uintx SharedReadOnlySize                        = 16777216                            &#123;product&#125;Size of read-only space for metadata (in bytes)</div><div class="line">    uintx SharedReadWriteSize                       = 16777216                            &#123;product&#125;Size of read-write space for metadata (in bytes)</div><div class="line">     bool ShowHiddenFrames                          = false                               &#123;diagnostic&#125;show method handle implementation frames (usually hidden)</div><div class="line">     bool ShowMessageBoxOnError                     = false                               &#123;product&#125;Keep process alive on VM fatal error</div><div class="line">     bool ShowSafepointMsgs                         = false                               &#123;develop&#125;Show message about safepoint synchronization</div><div class="line">     bool SoftMatchFailure                          = false                               &#123;C2 develop&#125;If the DFA fails to match a node, print a message and bail out</div><div class="line">     intx SoftRefLRUPolicyMSPerMB                   = 1000                                &#123;product&#125;Number of milliseconds per MB of free space in the heap</div><div class="line">     bool SparcV9RegsHiBitsZero                     = true                                &#123;C2 develop&#125;Assume Sparc V9 I&amp;L registers on V8+ systems are zero-extended</div><div class="line">     bool SpecialArraysEquals                       = true                                &#123;C2 develop&#125;special version of Arrays.equals(char[],char[])</div><div class="line">     bool SpecialEncodeISOArray                     = true                                &#123;C2 product&#125;special version of ISO_8859_1$Encoder.encodeISOArray</div><div class="line">     bool SpecialStringCompareTo                    = true                                &#123;C2 develop&#125;special version of string compareTo</div><div class="line">     bool SpecialStringEquals                       = true                                &#123;C2 develop&#125;special version of string equals</div><div class="line">     bool SpecialStringIndexOf                      = true                                &#123;C2 develop&#125;special version of string indexOf</div><div class="line">     bool SplitIfBlocks                             = true                                &#123;C2 product&#125;Clone compares and control flow through merge points to fold some branches</div><div class="line">     intx StackPrintLimit                           = 100                                 &#123;develop&#125;number of stack frames to print in VM-level stack dump</div><div class="line">     intx StackRedPages                             = 1                                   &#123;pd product&#125;Number of red zone (unrecoverable overflows) pages</div><div class="line">     intx StackShadowPages                          = 22                                  &#123;pd product&#125;Number of shadow zone (for overflow checking) pages this should exceed the depth of the VM and native call stack</div><div class="line">     bool StackTraceInThrowable                     = true                                &#123;product&#125;Collect backtrace in throwable when exception happens</div><div class="line">     intx StackYellowPages                          = 2                                   &#123;pd product&#125;Number of yellow zone (recoverable overflows) pages</div><div class="line">     bool StartAttachListener                       = false                               &#123;product&#125;Always start Attach Listener at VM startup</div><div class="line">     intx StarvationMonitorInterval                 = 200                                 &#123;product&#125;Pause between each check (in milliseconds)</div><div class="line">     intx StopInterpreterAt                         = 0                                   &#123;develop&#125;Stop interpreter execution at specified bytecode number</div><div class="line">     bool StressCodeBuffers                         = false                               &#123;develop&#125;Exercise code buffer expansion and other rare state changes</div><div class="line">     bool StressCompiledExceptionHandlers           = false                               &#123;develop&#125;Exercise compiled exception handlers</div><div class="line">     bool StressCriticalJNINatives                  = false                               &#123;notproduct&#125;Exercise register saving code in critical natives</div><div class="line">     bool StressDerivedPointers                     = false                               &#123;notproduct&#125;Force scavenge when a derived pointer is detected on stack after rtm call</div><div class="line">     bool StressGCM                                 = false                               &#123;C2 develop&#125;Randomize instruction scheduling in GCM</div><div class="line">     bool StressLCM                                 = false                               &#123;C2 develop&#125;Randomize instruction scheduling in LCM</div><div class="line">     bool StressLdcRewrite                          = false                               &#123;product&#125;Force ldc -&gt; ldc_w rewrite during RedefineClasses</div><div class="line">     bool StressLinearScan                          = false                               &#123;C1 develop&#125;scramble block order used by LinearScan (stress test)</div><div class="line">     bool StressLoopInvariantCodeMotion             = false                               &#123;C1 develop&#125;stress loop invariant code motion</div><div class="line">     bool StressMethodComparator                    = false                               &#123;develop&#125;Run the MethodComparator on all loaded methods</div><div class="line">     bool StressRangeCheckElimination               = false                               &#123;C1 develop&#125;stress Range Check Elimination</div><div class="line">     bool StressRecompilation                       = false                               &#123;C2 develop&#125;Recompile each compiled method without subsuming loads or escape analysis.</div><div class="line">     bool StressReflectiveCode                      = false                               &#123;C2 develop&#125;Use inexact types at allocations, etc., to test reflection</div><div class="line">     bool StressRewriter                            = false                               &#123;develop&#125;Stress linktime bytecode rewriting</div><div class="line">     bool StrictSafepointChecks                     = true                                &#123;notproduct&#125;Enable strict checks that safepoints cannot happen for threads that use No_Safepoint_Verifier</div><div class="line">    uintx StringDeduplicationAgeThreshold           = 3                                   &#123;product&#125;A string must reach this age (or be promoted to an old region) to be considered for deduplication</div><div class="line">     bool StringDeduplicationRehashALot             = false                               &#123;diagnostic&#125;Force table rehash every time the table is scanned</div><div class="line">     bool StringDeduplicationResizeALot             = false                               &#123;diagnostic&#125;Force table resize every time the table is scanned</div><div class="line">    uintx StringTableSize                           = 60013                               &#123;product&#125;Number of buckets in the interned String table</div><div class="line">     bool SubsumeLoads                              = true                                &#123;C2 develop&#125;Attempt to compile while subsuming loads into machine instructions.</div><div class="line">     bool SuperWordRTDepCheck                       = false                               &#123;C2 develop&#125;Enable runtime dependency checks.</div><div class="line">ccstrlist SuppressErrorAt                           =                                     &#123;notproduct&#125;List of assertions (file:line) to muzzle</div><div class="line">     bool SuppressFatalErrorMessage                 = false                               &#123;product&#125;Report NO fatal error message (avoid deadlock)</div><div class="line">    uintx SurvivorPadding                           = 3                                   &#123;product&#125;How much buffer to keep for survivor overflow</div><div class="line">    uintx SurvivorRatio                             = 8                                   &#123;product&#125;Ratio of eden/survivor space size</div><div class="line">     intx SuspendRetryCount                         = 50                                  &#123;product&#125;Maximum retry count for an external suspend request</div><div class="line">     intx SuspendRetryDelay                         = 5                                   &#123;product&#125;Milliseconds to delay per retry (* current_retry_count)</div><div class="line">     intx SweeperLogEntries                         = 1024                                &#123;notproduct&#125;Number of records in the ring buffer of sweeper activity</div><div class="line">     intx SyncFlags                                 = 0                                   &#123;product&#125;(Unsafe, Unstable) Experimental Sync flags</div><div class="line">    ccstr SyncKnobs                                 =                                     &#123;product&#125;(Unstable) Various monitor synchronization tunables</div><div class="line">     intx SyncVerbose                               = 0                                   &#123;product&#125;(Unstable)</div><div class="line">    uintx TLABAllocationWeight                      = 35                                  &#123;product&#125;Allocation averaging weight</div><div class="line">    uintx TLABRefillWasteFraction                   = 64                                  &#123;product&#125;Maximum TLAB waste at a refill (internal fragmentation)</div><div class="line">    uintx TLABSize                                  = 0                                   &#123;product&#125;Starting TLAB size (in bytes); zero means set ergonomically</div><div class="line">     bool TLABStats                                 = true                                &#123;product&#125;Provide more detailed and expensive TLAB statistics (with PrintTLAB)</div><div class="line">    uintx TLABWasteIncrement                        = 4                                   &#123;product&#125;Increment allowed waste at slow allocation</div><div class="line">    uintx TLABWasteTargetPercent                    = 1                                   &#123;product&#125;Percentage of Eden that can be wasted</div><div class="line">    uintx TargetPLABWastePct                        = 10                                  &#123;product&#125;Target wasted space in last buffer as percent of overall allocation</div><div class="line">    uintx TargetSurvivorRatio                       = 50                                  &#123;product&#125;Desired percentage of survivor space used after scavenge</div><div class="line">    uintx TenuredGenerationSizeIncrement            = 20                                  &#123;product&#125;Adaptive size percentage change in tenured generation</div><div class="line">    uintx TenuredGenerationSizeSupplement           = 80                                  &#123;product&#125;Supplement to TenuredGenerationSizeIncrement used at startup</div><div class="line">    uintx TenuredGenerationSizeSupplementDecay      = 2                                   &#123;product&#125;Decay factor to TenuredGenerationSizeIncrement</div><div class="line">     intx ThreadPriorityPolicy                      = 0                                   &#123;product&#125;0 : Normal.                                                         VM chooses priorities that are appropriate for normal           applications. On Solaris NORM_PRIORITY and above are mapped     to normal native priority. Java priorities below     NORM_PRIORITY map to lower native priority values. On           Windows applications are allowed to use higher native           priorities. However, with ThreadPriorityPolicy=0, VM will       not use the highest possible native priority,                   THREAD_PRIORITY_TIME_CRITICAL, as it may interfere with         system threads. On Linux thread priorities are ignored          because the OS does not support static priority in              SCHED_OTHER scheduling class which is the only choice for       non-root, non-realtime applications.                        1 : Aggressive.                                                     Java thread priorities map over to the entire range of          native thread priorities. Higher Java thread priorities map     to higher native thread priorities. This policy should be       used with care, as sometimes it can cause performance           degradation in the application and/or the entire system. On     Linux this policy requires root privilege.</div><div class="line">     bool ThreadPriorityVerbose                     = false                               &#123;product&#125;Print priority changes</div><div class="line">    uintx ThreadSafetyMargin                        = 52428800                            &#123;product&#125;Thread safety margin is used on fixed-stack LinuxThreads (on Linux/x86 only) to prevent heap-stack collision. Set to 0 to disable this feature</div><div class="line">     intx ThreadStackSize                           = 1024                                &#123;pd product&#125;Thread Stack Size (in Kbytes)</div><div class="line">    uintx ThresholdTolerance                        = 10                                  &#123;product&#125;Allowed collection cost difference between generations</div><div class="line">     intx Tier0BackedgeNotifyFreqLog                = 10                                  &#123;product&#125;Interpreter (tier 0) invocation notification frequency</div><div class="line">     intx Tier0InvokeNotifyFreqLog                  = 7                                   &#123;product&#125;Interpreter (tier 0) invocation notification frequency</div><div class="line">     intx Tier0ProfilingStartPercentage             = 200                                 &#123;product&#125;Start profiling in interpreter if the counters exceed tier 3 thresholds by the specified percentage</div><div class="line">     intx Tier23InlineeNotifyFreqLog                = 20                                  &#123;product&#125;Inlinee invocation (tiers 2 and 3) notification frequency</div><div class="line">     intx Tier2BackEdgeThreshold                    = 0                                   &#123;product&#125;Back edge threshold at which tier 2 compilation is invoked</div><div class="line">     intx Tier2BackedgeNotifyFreqLog                = 14                                  &#123;product&#125;C1 without MDO (tier 2) invocation notification frequency</div><div class="line">     intx Tier2CompileThreshold                     = 0                                   &#123;product&#125;threshold at which tier 2 compilation is invoked</div><div class="line">     intx Tier2InvokeNotifyFreqLog                  = 11                                  &#123;product&#125;C1 without MDO (tier 2) invocation notification frequency</div><div class="line">     intx Tier3BackEdgeThreshold                    = 60000                               &#123;product&#125;Back edge threshold at which tier 3 OSR compilation is invoked</div><div class="line">     intx Tier3BackedgeNotifyFreqLog                = 13                                  &#123;product&#125;C1 with MDO profiling (tier 3) invocation notification frequency</div><div class="line">     intx Tier3CompileThreshold                     = 2000                                &#123;product&#125;Threshold at which tier 3 compilation is invoked (invocation minimum must be satisfied</div><div class="line">     intx Tier3DelayOff                             = 2                                   &#123;product&#125;If C2 queue size is less than this amount per compiler thread allow methods compiled at tier 2 transition to tier 3</div><div class="line">     intx Tier3DelayOn                              = 5                                   &#123;product&#125;If C2 queue size grows over this amount per compiler thread stop compiling at tier 3 and start compiling at tier 2</div><div class="line">     intx Tier3InvocationThreshold                  = 200                                 &#123;product&#125;Compile if number of method invocations crosses this threshold</div><div class="line">     intx Tier3InvokeNotifyFreqLog                  = 10                                  &#123;product&#125;C1 with MDO profiling (tier 3) invocation notification frequency</div><div class="line">     intx Tier3LoadFeedback                         = 5                                   &#123;product&#125;Tier 3 thresholds will increase twofold when C1 queue size reaches this amount per compiler thread</div><div class="line">     intx Tier3MinInvocationThreshold               = 100                                 &#123;product&#125;Minimum invocation to compile at tier 3</div><div class="line">     intx Tier4BackEdgeThreshold                    = 40000                               &#123;product&#125;Back edge threshold at which tier 4 OSR compilation is invoked</div><div class="line">     intx Tier4CompileThreshold                     = 15000                               &#123;product&#125;Threshold at which tier 4 compilation is invoked (invocation minimum must be satisfied</div><div class="line">     intx Tier4InvocationThreshold                  = 5000                                &#123;product&#125;Compile if number of method invocations crosses this threshold</div><div class="line">     intx Tier4LoadFeedback                         = 3                                   &#123;product&#125;Tier 4 thresholds will increase twofold when C2 queue size reaches this amount per compiler thread</div><div class="line">     intx Tier4MinInvocationThreshold               = 600                                 &#123;product&#125;Minimum invocation to compile at tier 4</div><div class="line">     bool TieredCompilation                         = true                                &#123;pd product&#125;Enable tiered compilation</div><div class="line">     intx TieredCompileTaskTimeout                  = 50                                  &#123;product&#125;Kill compile task if method was not used within given timeout in milliseconds</div><div class="line">     intx TieredRateUpdateMaxTime                   = 25                                  &#123;product&#125;Maximum rate sampling interval (in milliseconds)</div><div class="line">     intx TieredRateUpdateMinTime                   = 1                                   &#123;product&#125;Minimum rate sampling interval (in milliseconds)</div><div class="line">     intx TieredStopAtLevel                         = 4                                   &#123;product&#125;Stop at given compilation level</div><div class="line">     bool TimeCompilationPolicy                     = false                               &#123;develop&#125;Time the compilation policy</div><div class="line">     bool TimeCompiler                              = false                               &#123;notproduct&#125;Time the compiler</div><div class="line">     bool TimeCompiler2                             = false                               &#123;C2 notproduct&#125;detailed time the compiler (requires +TimeCompiler)</div><div class="line">     bool TimeEachLinearScan                        = false                               &#123;C1 develop&#125;print detailed timing of each LinearScan run</div><div class="line">     bool TimeLinearScan                            = false                               &#123;C1 product&#125;detailed timing of LinearScan phases</div><div class="line">     bool TimeLivenessAnalysis                      = false                               &#123;develop&#125;Time computation of bytecode liveness analysis</div><div class="line">     bool TimeOopMap                                = false                               &#123;develop&#125;Time calls to GenerateOopMap::compute_map() in sum</div><div class="line">     bool TimeOopMap2                               = false                               &#123;develop&#125;Time calls to GenerateOopMap::compute_map() individually</div><div class="line">    uintx TotalHandleAllocationLimit                = 1024                                &#123;develop&#125;Threshold for total handle allocation when +TraceHandleAllocation is used</div><div class="line">     bool TraceAdaptiveGCBoundary                   = false                               &#123;develop&#125;Trace young-old boundary moves</div><div class="line">     bool TraceBiasedLocking                        = false                               &#123;product&#125;Trace biased locking in JVM</div><div class="line">     bool TraceBlockOffsetTable                     = false                               &#123;develop&#125;Print BlockOffsetTable maps</div><div class="line">     bool TraceBytecodes                            = false                               &#123;develop&#125;Trace bytecode execution</div><div class="line">     intx TraceBytecodesAt                          = 0                                   &#123;develop&#125;Trace bytecodes starting with specified bytecode number</div><div class="line">     bool TraceCISCSpill                            = false                               &#123;C2 notproduct&#125;Trace allocators use of cisc spillable instructions</div><div class="line">     bool TraceCMSState                             = false                               &#123;develop&#125;Trace the state of the CMS collection</div><div class="line">     bool TraceCallFixup                            = false                               &#123;develop&#125;Trace all call fixups</div><div class="line">     bool TraceCardTableModRefBS                    = false                               &#123;develop&#125;Print CardTableModRefBS maps</div><div class="line">     bool TraceClassInitialization                  = false                               &#123;develop&#125;Trace class initialization</div><div class="line">     bool TraceClassLoaderData                      = false                               &#123;develop&#125;Trace class loader loader_data lifetime</div><div class="line">     bool TraceClassLoading                         = false                               &#123;product rw&#125;Trace all classes loaded</div><div class="line">     bool TraceClassLoadingPreorder                 = false                               &#123;product&#125;Trace all classes loaded in order referenced (not loaded)</div><div class="line">     bool TraceClassPaths                           = false                               &#123;product&#125;Trace processing of class paths</div><div class="line">     bool TraceClassResolution                      = false                               &#123;product&#125;Trace all constant pool resolutions (for debugging)</div><div class="line">     bool TraceClassUnloading                       = false                               &#123;product rw&#125;Trace unloading of classes</div><div class="line">     bool TraceClearedExceptions                    = false                               &#123;develop&#125;Print when an exception is forcibly cleared</div><div class="line">     bool TraceCodeBlobStacks                       = false                               &#123;notproduct&#125;Trace stack-walk of codeblobs</div><div class="line">     bool TraceCompilationPolicy                    = false                               &#123;develop&#125;Trace compilation policy</div><div class="line">     bool TraceCompiledIC                           = false                               &#123;develop&#125;Trace changes of compiled IC</div><div class="line">     bool TraceCreateZombies                        = false                               &#123;develop&#125;trace creation of zombie nmethods</div><div class="line">     bool TraceDefaultMethods                       = false                               &#123;develop&#125;Trace the default method processing steps</div><div class="line">     bool TraceDeoptimization                       = false                               &#123;develop&#125;Trace deoptimization</div><div class="line">     bool TraceDependencies                         = false                               &#123;develop&#125;Trace dependencies</div><div class="line">     bool TraceDerivedPointers                      = false                               &#123;develop&#125;Trace traversal of derived pointers on stack</div><div class="line">     bool TraceDynamicGCThreads                     = false                               &#123;product&#125;Trace the dynamic GC thread usage</div><div class="line">     bool TraceExceptions                           = false                               &#123;develop&#125;Trace exceptions</div><div class="line">     bool TraceFPURegisterUsage                     = false                               &#123;C1 develop&#125;Trace usage of FPU registers at start of blocks (intel only)</div><div class="line">     bool TraceFPUStack                             = false                               &#123;C1 develop&#125;Trace emulation of the FPU stack (intel only)</div><div class="line">     bool TraceFinalizerRegistration                = false                               &#123;develop&#125;Trace registration of final references</div><div class="line">     bool TraceFrequencyInlining                    = false                               &#123;develop&#125;Trace frequency based inlining</div><div class="line">     bool TraceGCTaskManager                        = false                               &#123;develop&#125;Trace actions of the GC task manager</div><div class="line">     bool TraceGCTaskQueue                          = false                               &#123;develop&#125;Trace actions of the GC task queues</div><div class="line">     bool TraceGCTaskThread                         = false                               &#123;diagnostic&#125;Trace actions of the GC task threads</div><div class="line">     bool TraceGen0Time                             = false                               &#123;product&#125;Trace accumulated time for Gen 0 collection</div><div class="line">     bool TraceGen1Time                             = false                               &#123;product&#125;Trace accumulated time for Gen 1 collection</div><div class="line">     bool TraceHandleAllocation                     = false                               &#123;develop&#125;Print out warnings when suspiciously many handles are allocated</div><div class="line">     bool TraceICBuffer                             = false                               &#123;develop&#125;Trace usage of IC buffer</div><div class="line">     bool TraceICs                                  = false                               &#123;develop&#125;Trace inline cache changes</div><div class="line">     bool TraceInlineCacheClearing                  = false                               &#123;develop&#125;Trace clearing of inline caches in nmethods</div><div class="line">     bool TraceInvocationCounterOverflow            = false                               &#123;notproduct&#125;Trace method invocation counter overflow</div><div class="line">     bool TraceInvokeDynamic                        = false                               &#123;develop&#125;trace internal invoke dynamic operations</div><div class="line">     bool TraceItables                              = false                               &#123;develop&#125;Trace initialization and use of itables</div><div class="line">     bool TraceIterativeGVN                         = false                               &#123;C2 develop&#125;Print progress during Iterative Global Value Numbering</div><div class="line">     bool TraceJNICalls                             = false                               &#123;develop&#125;Trace JNI calls</div><div class="line">     bool TraceJNIHandleAllocation                  = false                               &#123;develop&#125;Trace allocation/deallocation of JNI handle blocks</div><div class="line">     bool TraceJVMCalls                             = false                               &#123;notproduct&#125;Trace JVM calls</div><div class="line">    ccstr TraceJVMTI                                =                                     &#123;product&#125;Trace flags for JVMTI functions and events</div><div class="line">     bool TraceJVMTIObjectTagging                   = false                               &#123;diagnostic&#125;Trace JVMTI object tagging calls</div><div class="line">     bool TraceJavaAssertions                       = false                               &#123;develop&#125;Trace java language assertions</div><div class="line">     bool TraceJumps                                = false                               &#123;develop&#125;Trace assembly jumps in thread ring buffer</div><div class="line">     intx TraceLinearScanLevel                      = 0                                   &#123;C1 develop&#125;Debug levels for the linear scan allocator</div><div class="line">     bool TraceLivenessGen                          = false                               &#123;develop&#125;Trace the generation of liveness analysis information</div><div class="line">     bool TraceLivenessQuery                        = false                               &#123;notproduct&#125;Trace queries of liveness analysis information</div><div class="line">     bool TraceLoaderConstraints                    = false                               &#123;product rw&#125;Trace loader constraints</div><div class="line">     bool TraceLongCompiles                         = false                               &#123;develop&#125;Print out every time compilation is longer than a given threshold</div><div class="line">     bool TraceLoopLimitCheck                       = false                               &#123;C2 develop&#125;Trace generation of loop limits checks</div><div class="line">     bool TraceLoopOpts                             = false                               &#123;C2 develop&#125;Trace executed loop optimizations</div><div class="line">     bool TraceLoopPredicate                        = false                               &#123;C2 develop&#125;Trace generation of loop predicates</div><div class="line">     bool TraceLoopUnswitching                      = false                               &#123;C2 notproduct&#125;Trace loop unswitching</div><div class="line">     bool TraceMarkSweep                            = false                               &#123;notproduct&#125;Trace mark sweep</div><div class="line">     bool TraceMetadataChunkAllocation              = false                               &#123;develop&#125;Trace chunk metadata allocations</div><div class="line">     bool TraceMetadataHumongousAllocation          = false                               &#123;product&#125;Trace humongous metadata allocations</div><div class="line">     bool TraceMetavirtualspaceAllocation           = false                               &#123;develop&#125;Trace virtual space metadata allocations</div><div class="line">     bool TraceMethodHandles                        = false                               &#123;develop&#125;trace internal method handle operations</div><div class="line">     bool TraceMethodReplacement                    = false                               &#123;develop&#125;Print when methods are replaced do to recompilation</div><div class="line">     bool TraceMonitorInflation                     = false                               &#123;product&#125;Trace monitor inflation in JVM</div><div class="line">     bool TraceMonitorMismatch                      = false                               &#123;develop&#125;Trace monitor matching failures during OopMapGeneration</div><div class="line">     bool TraceNMethodInstalls                      = false                               &#123;diagnostic&#125;Trace nmethod installation</div><div class="line">     bool TraceNewOopMapGeneration                  = false                               &#123;develop&#125;Trace OopMapGeneration</div><div class="line">     bool TraceNewOopMapGenerationDetailed          = false                               &#123;develop&#125;Trace OopMapGeneration: print detailed cell states</div><div class="line">     bool TraceNewVectors                           = false                               &#123;C2 notproduct&#125;Trace creation of Vector nodes</div><div class="line">     bool TraceOnStackReplacement                   = false                               &#123;notproduct&#125;Trace on stack replacement</div><div class="line">     bool TraceOopMapGeneration                     = false                               &#123;develop&#125;Show OopMapGeneration</div><div class="line">     bool TraceOopMapRewrites                       = false                               &#123;develop&#125;Trace rewriting of method oops during oop map generation</div><div class="line">     bool TraceOptimizeFill                         = false                               &#123;C2 develop&#125;print detailed information about fill conversion</div><div class="line">     bool TraceOptoOutput                           = false                               &#123;C2 notproduct&#125;Trace pipelining information</div><div class="line">     bool TraceOptoParse                            = false                               &#123;C2 develop&#125;Trace bytecode parse and control-flow merge</div><div class="line">     bool TraceOptoPipelining                       = false                               &#123;C2 notproduct&#125;Trace pipelining information</div><div class="line">     bool TracePageSizes                            = false                               &#123;develop&#125;Trace page size selection and usage</div><div class="line">     bool TraceParallelOldGCCompactionPhase         = false                               &#123;develop&#125;Trace compaction phase in ParallelOldGC</div><div class="line">     bool TraceParallelOldGCDensePrefix             = false                               &#123;develop&#125;Trace dense prefix computation for ParallelOldGC</div><div class="line">     bool TraceParallelOldGCMarkingPhase            = false                               &#123;develop&#125;Trace marking phase in ParallelOldGC</div><div class="line">     bool TraceParallelOldGCSummaryPhase            = false                               &#123;develop&#125;Trace summary phase in ParallelOldGC</div><div class="line">     bool TraceParallelOldGCTasks                   = false                               &#123;product&#125;Trace multithreaded GC activity</div><div class="line">     bool TracePartialPeeling                       = false                               &#123;C2 notproduct&#125;Trace partial peeling (loop rotation) information</div><div class="line">     bool TracePatching                             = false                               &#123;C1 develop&#125;Trace patching of field access on uninitialized classes</div><div class="line">     bool TracePcPatching                           = false                               &#123;develop&#125;Trace usage of frame::patch_pc</div><div class="line">     bool TracePhaseCCP                             = false                               &#123;C2 notproduct&#125;Print progress during Conditional Constant Propagation</div><div class="line">     bool TracePostallocExpand                      = false                               &#123;C2 develop&#125;Trace expanding nodes after register allocation.</div><div class="line">     bool TracePredicateFailedTraps                 = false                               &#123;C1 develop&#125;trace runtime traps caused by predicate failure</div><div class="line">     bool TraceProfileInterpreter                   = false                               &#123;develop&#125;Trace profiling at the bytecode level during interpretation. This outputs the profiling information collected to improve jit compilation.</div><div class="line">     bool TraceProfileTripCount                     = false                               &#123;C2 notproduct&#125;Trace profile loop trip count information</div><div class="line">     bool TraceProtectionDomainVerification         = false                               &#123;develop&#125;Trace protection domain verification</div><div class="line">     bool TraceRangeCheckElimination                = false                               &#123;C1 develop&#125;Trace Range Check Elimination</div><div class="line">     bool TraceRangeLimitCheck                      = false                               &#123;C2 develop&#125;Trace additional overflow checks in RCE</div><div class="line">     intx TraceRedefineClasses                      = 0                                   &#123;product&#125;Trace level for JVMTI RedefineClasses</div><div class="line">     bool TraceReferenceGC                          = false                               &#123;develop&#125;Trace handling of soft/weak/final/phantom references</div><div class="line">     bool TraceRelocator                            = false                               &#123;develop&#125;Trace the bytecode relocator</div><div class="line">     bool TraceRuntimeCalls                         = false                               &#123;notproduct&#125;Trace run-time calls</div><div class="line">     bool TraceSafepoint                            = false                               &#123;develop&#125;Trace safepoint operations</div><div class="line">     bool TraceSafepointCleanupTime                 = false                               &#123;product&#125;Print the break down of clean up tasks performed during safepoint</div><div class="line">     bool TraceScavenge                             = false                               &#123;notproduct&#125;Trace scavenge</div><div class="line">     bool TraceSpilling                             = false                               &#123;C2 notproduct&#125;Trace spilling</div><div class="line">     bool TraceStartupTime                          = false                               &#123;develop&#125;Trace setup time</div><div class="line">     bool TraceSuperWord                            = false                               &#123;C2 notproduct&#125;Trace superword transforms</div><div class="line">     bool TraceSuspendWaitFailures                  = false                               &#123;product&#125;Trace external suspend wait failures</div><div class="line">     bool TraceThreadEvents                         = false                               &#123;develop&#125;Trace all thread events</div><div class="line">     bool TraceTypeProfile                          = false                               &#123;C2 diagnostic&#125;Trace type profile</div><div class="line">     bool TraceVMOperation                          = false                               &#123;develop&#125;Trace VM operations</div><div class="line">     bool TraceWorkGang                             = false                               &#123;develop&#125;Trace activities of work gangs</div><div class="line">     bool TraceZapDeadLocals                        = false                               &#123;notproduct&#125;Trace zapping dead locals</div><div class="line">     bool TraceZapUnusedHeapArea                    = false                               &#123;develop&#125;Trace zapping of unused heap space</div><div class="line">     intx TrackedInitializationLimit                = 50                                  &#123;C2 product&#125;When initializing fields, track up to this many words</div><div class="line">     bool TransmitErrorReport                       = false                               &#123;product&#125;Enable error report transmission on erroneous termination</div><div class="line">     bool TrapBasedNullChecks                       = false                               &#123;pd product&#125;Generate code for null checks that uses a cmp and trap instruction raising SIGTRAP.  This is only used if an access tonull (+offset) will not raise a SIGSEGV, i.e.,ImplicitNullChecks don&apos;t work (PPC64).</div><div class="line">     bool TrapBasedRangeChecks                      = false                               &#123;C2 pd product&#125;Generate code for range checks that uses a cmp and trap instruction raising SIGTRAP. Used on PPC64.</div><div class="line">     bool TwoOperandLIRForm                         = true                                &#123;C1 pd develop&#125;true if LIR requires src1 and dst to match in binary LIR ops</div><div class="line">     intx TypeProfileArgsLimit                      = 2                                   &#123;product&#125;max number of call arguments to consider for type profiling</div><div class="line">     bool TypeProfileCasts                          = true                                &#123;develop&#125;treat casts like calls for purposes of type profiling</div><div class="line">    uintx TypeProfileLevel                          = 111                                 &#123;pd product&#125;=XYZ, with Z: Type profiling of arguments at call; Y: Type profiling of return value at call; X: Type profiling of parameters to methods; X, Y and Z in 0=off ; 1=jsr292 only; 2=all methods</div><div class="line">     intx TypeProfileMajorReceiverPercent           = 90                                  &#123;C2 product&#125;% of major receiver type to all profiled receivers</div><div class="line">     intx TypeProfileParmsLimit                     = 2                                   &#123;product&#125;max number of incoming parameters to consider for type profiling, -1 for all</div><div class="line">     intx TypeProfileWidth                          = 2                                   &#123;product&#125;Number of receiver types to record in call/cast profile</div><div class="line">     bool UncommonNullCast                          = true                                &#123;pd develop&#125;track occurrences of null in casts; adjust compiler tactics</div><div class="line">     intx UnguardOnExecutionViolation               = 0                                   &#123;product&#125;Unguard page and retry on no-execute fault (Win32 only) 0=off, 1=conservative, 2=aggressive</div><div class="line">     bool UnlinkSymbolsALot                         = false                               &#123;product&#125;Unlink unreferenced symbols from the symbol table at safepoints</div><div class="line">     bool UnlockDiagnosticVMOptions                 = true                                &#123;diagnostic&#125;Enable normal processing of flags relating to field diagnostics</div><div class="line">     bool UnrollLimitCheck                          = true                                &#123;C2 diagnostic&#125;Additional overflow checks during loop unroll</div><div class="line">     intx UnrollLimitForProfileCheck                = 1                                   &#123;C2 develop&#125;Don&apos;t use profile_trip_cnt() to restrict unrolling until unrolling would push the number of unrolled iterations above UnrollLimitForProfileCheck. A higher value allows more unrolling. Zero acts as a very large value.</div><div class="line">     bool UnsyncloadClass                           = false                               &#123;diagnostic&#125;Unstable: VM calls loadClass unsynchronized. Custom class loader must call VM synchronized for findClass and defineClass.</div><div class="line">     bool Use24BitFP                                = true                                &#123;C2 develop&#125;use FP instructions that produce 24-bit precise results</div><div class="line">     bool Use24BitFPMode                            = true                                &#123;C2 develop&#125;Set 24-bit FPU mode on a per-compile basis </div><div class="line">     bool Use486InstrsOnly                          = false                               &#123;ARCH product&#125;Use 80486 Compliant instruction subset</div><div class="line">     bool UseAES                                    = false                               &#123;product&#125;Control whether AES instructions can be used on x86/x64</div><div class="line">     bool UseAESIntrinsics                          = false                               &#123;product&#125;Use intrinsics for AES versions of crypto</div><div class="line">     intx UseAVX                                    = 99                                  &#123;ARCH product&#125;Highest supported AVX instructions set on x86/x64</div><div class="line">     bool UseAdaptiveGCBoundary                     = false                               &#123;product&#125;Allow young-old boundary to move</div><div class="line">     bool UseAdaptiveGenerationSizePolicyAtMajorCollection  = true                                &#123;product&#125;Use adaptive young-old sizing policies at major collections</div><div class="line">     bool UseAdaptiveGenerationSizePolicyAtMinorCollection  = true                                &#123;product&#125;Use adaptive young-old sizing policies at minor collections</div><div class="line">     bool UseAdaptiveNUMAChunkSizing                = true                                &#123;product&#125;Enable adaptive chunk sizing for NUMA</div><div class="line">     bool UseAdaptiveSizeDecayMajorGCCost           = true                                &#123;product&#125;Adaptive size decays the major cost for long major intervals</div><div class="line">     bool UseAdaptiveSizePolicy                     = true                                &#123;product&#125;Use adaptive generation sizing policies</div><div class="line">     bool UseAdaptiveSizePolicyFootprintGoal        = true                                &#123;product&#125;Use adaptive minimum footprint as a goal</div><div class="line">     bool UseAdaptiveSizePolicyWithSystemGC         = false                               &#123;product&#125;Include statistics from System.gc() for adaptive size policy</div><div class="line">     bool UseAddressNop                             = false                               &#123;ARCH product&#125;Use &apos;0F 1F [addr]&apos; NOP instructions on x86 cpus</div><div class="line">     bool UseAltSigs                                = false                               &#123;product&#125;Use alternate signals instead of SIGUSR1 &amp; SIGUSR2 for VM internal signals (Solaris only)</div><div class="line">     bool UseAsyncConcMarkSweepGC                   = true                                &#123;develop&#125;Use Asynchronous Concurrent Mark-Sweep GC in the old generation</div><div class="line">     bool UseAutoGCSelectPolicy                     = false                               &#123;product&#125;Use automatic collection selection policy</div><div class="line">     bool UseBMI1Instructions                       = false                               &#123;ARCH product&#125;Use BMI1 instructions</div><div class="line">     bool UseBMI2Instructions                       = false                               &#123;ARCH product&#125;Use BMI2 instructions</div><div class="line">     bool UseBiasedLocking                          = true                                &#123;product&#125;Enable biased locking in JVM</div><div class="line">     bool UseBimorphicInlining                      = true                                &#123;C2 product&#125;Profiling based inlining for two receivers</div><div class="line">     bool UseBoundThreads                           = true                                &#123;product&#125;Bind user level threads to kernel threads (for Solaris only)</div><div class="line">     bool UseC1Optimizations                        = true                                &#123;C1 develop&#125;Turn on C1 optimizations</div><div class="line">     bool UseCHA                                    = true                                &#123;develop&#125;Enable CHA</div><div class="line">     bool UseCISCSpill                              = true                                &#123;C2 pd develop&#125;Use ADLC supplied cisc instructions during allocation</div><div class="line">     bool UseCLMUL                                  = false                               &#123;ARCH product&#125;Control whether CLMUL instructions can be used on x86/x64</div><div class="line">     bool UseCMSAdaptiveFreeLists                   = true                                &#123;develop&#125;Use adaptive free lists in the CMS generation</div><div class="line">     bool UseCMSBestFit                             = true                                &#123;product&#125;Use CMS best fit allocation strategy</div><div class="line">     bool UseCMSCollectionPassing                   = true                                &#123;product&#125;Use passing of collection from background to foreground</div><div class="line">     bool UseCMSCompactAtFullCollection             = true                                &#123;product&#125;Use Mark-Sweep-Compact algorithm at full collections</div><div class="line">     bool UseCMSInitiatingOccupancyOnly             = false                               &#123;product&#125;Only use occupancy as a criterion for starting a CMS collection</div><div class="line">     bool UseCRC32Intrinsics                        = false                               &#123;product&#125;use intrinsics for java.util.zip.CRC32</div><div class="line">     bool UseCodeCacheFlushing                      = true                                &#123;product&#125;Remove cold/old nmethods from the code cache</div><div class="line">     bool UseCompiler                               = true                                &#123;product&#125;Use Just-In-Time compilation</div><div class="line">     bool UseCompilerSafepoints                     = true                                &#123;product&#125;Stop at safepoints in compiled code</div><div class="line">     bool UseCompressedClassPointers                = false                               &#123;lp64_product&#125;Use 32-bit class pointers in 64-bit VM. lp64_product means flag is always constant in 32 bit VM</div><div class="line">     bool UseCompressedOops                         = false                               &#123;lp64_product&#125;Use 32-bit object references in 64-bit VM. lp64_product means flag is always constant in 32 bit VM</div><div class="line">     bool UseConcMarkSweepGC                        = false                               &#123;product&#125;Use Concurrent Mark-Sweep GC in the old generation</div><div class="line">     bool UseCondCardMark                           = false                               &#123;C2 product&#125;Check for already marked card before updating card table</div><div class="line">     bool UseCountLeadingZerosInstruction           = false                               &#123;ARCH product&#125;Use count leading zeros instruction</div><div class="line">     bool UseCountTrailingZerosInstruction          = false                               &#123;ARCH product&#125;Use count trailing zeros instruction</div><div class="line">     bool UseCountedLoopSafepoints                  = false                               &#123;C2 product&#125;Force counted loops to keep a safepoint</div><div class="line">     bool UseCounterDecay                           = true                                &#123;product&#125;Adjust recompilation counters</div><div class="line">     bool UseDetachedThreads                        = true                                &#123;develop&#125;Use detached threads that are recycled upon termination (for Solaris only)</div><div class="line">     bool UseDivMod                                 = true                                &#123;C2 product&#125;Use combined DivMod instruction if available</div><div class="line">     bool UseDynamicNumberOfGCThreads               = false                               &#123;product&#125;Dynamically choose the number of parallel threads parallel gc will use</div><div class="line">     bool UseExactTypes                             = true                                &#123;C2 develop&#125;Use exact types to eliminate array store checks and v-calls</div><div class="line">     bool UseFPUForSpilling                         = false                               &#123;C2 product&#125;Spill integer registers to FPU instead of stack when possible</div><div class="line">     bool UseFakeTimers                             = false                               &#123;develop&#125;Tell whether the VM should use system time or a fake timer</div><div class="line">     bool UseFastAccessorMethods                    = true                                &#123;product&#125;Use fast method entry code for accessor methods</div><div class="line">     bool UseFastEmptyMethods                       = true                                &#123;product&#125;Use fast method entry code for empty methods</div><div class="line">     bool UseFastJNIAccessors                       = true                                &#123;product&#125;Use optimized versions of Get&lt;Primitive&gt;Field</div><div class="line">     bool UseFastLocking                            = true                                &#123;C1 develop&#125;Use fast inlined locking code</div><div class="line">     bool UseFastNewInstance                        = true                                &#123;C1 develop&#125;Use fast inlined instance allocation</div><div class="line">     bool UseFastNewObjectArray                     = true                                &#123;C1 develop&#125;Use fast inlined object array allocation</div><div class="line">     bool UseFastNewTypeArray                       = true                                &#123;C1 develop&#125;Use fast inlined type array allocation</div><div class="line">     bool UseFastSignatureHandlers                  = true                                &#123;develop&#125;Use fast signature handlers for native calls</div><div class="line">     bool UseFastStosb                              = false                               &#123;ARCH product&#125;Use fast-string operation for zeroing: rep stosb</div><div class="line">     bool UseG1GC                                   = false                               &#123;product&#125;Use the Garbage-First garbage collector</div><div class="line">     bool UseGCLogFileRotation                      = false                               &#123;product&#125;Rotate gclog files (for long running applications). It requires -Xloggc:&lt;filename&gt;</div><div class="line">     bool UseGCOverheadLimit                        = true                                &#123;product&#125;Use policy to limit of proportion of time spent in GC before an OutOfMemory error is thrown</div><div class="line">     bool UseGCTaskAffinity                         = false                               &#123;product&#125;Use worker affinity when asking for GCTasks</div><div class="line">     bool UseGlobalValueNumbering                   = true                                &#123;C1 develop&#125;Use Global Value Numbering (separate phase)</div><div class="line">     bool UseHeavyMonitors                          = false                               &#123;product&#125;use heavyweight instead of lightweight Java monitors</div><div class="line">     bool UseHugeTLBFS                              = false                               &#123;product&#125;Use MAP_HUGETLB for large pages</div><div class="line">     bool UseImplicitStableValues                   = true                                &#123;C2 diagnostic&#125;Mark well-known stable fields as such (e.g. String.value)</div><div class="line">     bool UseIncDec                                 = true                                &#123;ARCH diagnostic&#125;Use INC, DEC instructions on x86</div><div class="line">     bool UseInlineCaches                           = true                                &#123;product&#125;Use Inline Caches for virtual calls </div><div class="line">     bool UseInlineDepthForSpeculativeTypes         = true                                &#123;C2 diagnostic&#125;Carry inline depth of profile point with speculative type and give priority to profiling from lower inline depth</div><div class="line">     bool UseInterpreter                            = true                                &#123;product&#125;Use interpreter for non-compiled methods</div><div class="line">     bool UseJumpTables                             = true                                &#123;C2 product&#125;Use JumpTables instead of a binary search tree for switches</div><div class="line">     bool UseLWPSynchronization                     = true                                &#123;product&#125;Use LWP-based instead of libthread-based synchronization (SPARC only)</div><div class="line">     bool UseLargePages                             = false                               &#123;pd product&#125;Use large page memory</div><div class="line">     bool UseLargePagesInMetaspace                  = false                               &#123;product&#125;Use large page memory in metaspace. Only used if UseLargePages is enabled.</div><div class="line">     bool UseLargePagesIndividualAllocation         = false                               &#123;pd product&#125;Allocate large pages individually for better affinity</div><div class="line">     bool UseLinuxPosixThreadCPUClocks              = true                                &#123;product&#125;enable fast Linux Posix clocks where available</div><div class="line">     bool UseLocalValueNumbering                    = true                                &#123;C1 develop&#125;Use Local Value Numbering (embedded in GraphBuilder)</div><div class="line">     bool UseLockedTracing                          = false                               &#123;product&#125;Use locked-tracing when doing event-based tracing</div><div class="line">     bool UseLoopCounter                            = true                                &#123;product&#125;Increment invocation counter on backward branch</div><div class="line">     bool UseLoopInvariantCodeMotion                = true                                &#123;C1 product&#125;Simple loop invariant code motion for short loops during GVN</div><div class="line">     bool UseLoopPredicate                          = true                                &#123;C2 product&#125;Generate a predicate to select fast/slow loop versions</div><div class="line">     bool UseLoopSafepoints                         = true                                &#123;develop&#125;Generate Safepoint nodes in every loop</div><div class="line">     bool UseMallocOnly                             = false                               &#123;develop&#125;Use only malloc/free for allocation (no resource area/arena)</div><div class="line">     bool UseMathExactIntrinsics                    = true                                &#123;C2 product&#125;Enables intrinsification of various java.lang.Math functions</div><div class="line">     bool UseMaximumCompactionOnSystemGC            = true                                &#123;product&#125;Use maximum compaction in the Parallel Old garbage collector for a system GC</div><div class="line">     bool UseMembar                                 = false                               &#123;pd product&#125;(Unstable) Issues membars on thread state transitions</div><div class="line">     bool UseMontgomeryMultiplyIntrinsic            = false                               &#123;C2 product&#125;Enables intrinsification of BigInteger.montgomeryMultiply()</div><div class="line">     bool UseMontgomerySquareIntrinsic              = false                               &#123;C2 product&#125;Enables intrinsification of BigInteger.montgomerySquare()</div><div class="line">     bool UseMulAddIntrinsic                        = false                               &#123;C2 product&#125;Enables intrinsification of BigInteger.mulAdd()</div><div class="line">     bool UseMultiplyToLenIntrinsic                 = false                               &#123;C2 product&#125;Enables intrinsification of BigInteger.multiplyToLen()</div><div class="line">     bool UseNUMA                                   = false                               &#123;product&#125;Use NUMA if available</div><div class="line">     bool UseNUMAInterleaving                       = false                               &#123;product&#125;Interleave memory across NUMA nodes if available</div><div class="line">     bool UseNewCode                                = false                               &#123;diagnostic&#125;Testing Only: Use the new version while testing</div><div class="line">     bool UseNewCode2                               = false                               &#123;diagnostic&#125;Testing Only: Use the new version while testing</div><div class="line">     bool UseNewCode3                               = false                               &#123;diagnostic&#125;Testing Only: Use the new version while testing</div><div class="line">     bool UseNewLongLShift                          = false                               &#123;ARCH product&#125;Use optimized bitwise shift left</div><div class="line">     bool UseNewReflection                          = true                                &#123;develop&#125;Temporary flag for transition to reflection based on dynamic bytecode generation in 1.4; can no longer be turned off in 1.4 JDK, and is unneeded in 1.3 JDK, but marks most places VM changes were needed</div><div class="line">     bool UseOSErrorReporting                       = false                               &#123;pd product&#125;Let VM fatal error propagate to the OS (ie. WER on Windows)</div><div class="line">     bool UseOldInlining                            = true                                &#123;C2 product&#125;Enable the 1.3 inlining strategy</div><div class="line">     bool UseOnStackReplacement                     = true                                &#123;pd product&#125;Use on stack replacement, calls runtime if invoc. counter overflows in loop</div><div class="line">     bool UseOnlyInlinedBimorphic                   = true                                &#123;C2 product&#125;Don&apos;t use BimorphicInlining if can&apos;t inline a second method</div><div class="line">     bool UseOprofile                               = false                               &#123;product&#125;enable support for Oprofile profiler</div><div class="line">     bool UseOptoBiasInlining                       = true                                &#123;C2 product&#125;Generate biased locking code in C2 ideal graph</div><div class="line">     bool UsePSAdaptiveSurvivorSizePolicy           = true                                &#123;product&#125;Use adaptive survivor sizing policies</div><div class="line">     bool UseParNewGC                               = false                               &#123;product&#125;Use parallel threads in the new generation</div><div class="line">     bool UseParallelGC                             = false                               &#123;product&#125;Use the Parallel Scavenge garbage collector</div><div class="line">     bool UseParallelOldGC                          = false                               &#123;product&#125;Use the Parallel Old garbage collector</div><div class="line">     bool UsePerfData                               = true                                &#123;product&#125;Flag to disable jvmstat instrumentation for performance testing and problem isolation purposes</div><div class="line">     bool UsePopCountInstruction                    = false                               &#123;product&#125;Use population count instruction</div><div class="line">     bool UsePrivilegedStack                        = true                                &#123;develop&#125;Enable the security JVM functions</div><div class="line">     bool UsePthreads                               = false                               &#123;develop&#125;Use pthread-based instead of libthread-based synchronization (SPARC only)</div><div class="line">     bool UseRDPCForConstantTableBase               = false                               &#123;C2 product&#125;Use Sparc RDPC instruction for the constant table base.</div><div class="line">     bool UseRTMDeopt                               = false                               &#123;ARCH product&#125;Perform deopt and recompilation based on RTM abort ratio</div><div class="line">     bool UseRTMLocking                             = false                               &#123;ARCH product&#125;Enable RTM lock eliding for inflated locks in compiled code</div><div class="line">     bool UseRelocIndex                             = false                               &#123;develop&#125;Use an index to speed random access to relocations</div><div class="line">     bool UseSHA                                    = false                               &#123;product&#125;Control whether SHA instructions can be used on SPARC</div><div class="line">     bool UseSHA1Intrinsics                         = false                               &#123;product&#125;Use intrinsics for SHA-1 crypto hash function</div><div class="line">     bool UseSHA256Intrinsics                       = false                               &#123;product&#125;Use intrinsics for SHA-224 and SHA-256 crypto hash functions</div><div class="line">     bool UseSHA512Intrinsics                       = false                               &#123;product&#125;Use intrinsics for SHA-384 and SHA-512 crypto hash functions</div><div class="line">     bool UseSHM                                    = false                               &#123;product&#125;Use SYSV shared memory for large pages</div><div class="line">     intx UseSSE                                    = 99                                  &#123;product&#125;Highest supported SSE instructions set on x86/x64</div><div class="line">     bool UseSSE42Intrinsics                        = false                               &#123;product&#125;SSE4.2 versions of intrinsics</div><div class="line">     bool UseSerialGC                               = false                               &#123;product&#125;Use the Serial garbage collector</div><div class="line">     bool UseSharedSpaces                           = true                                &#123;product&#125;Use shared spaces for metadata</div><div class="line">     bool UseSignalChaining                         = true                                &#123;product&#125;Use signal-chaining to invoke signal handlers installed by the application (Solaris &amp; Linux only)</div><div class="line">     bool UseSlowPath                               = false                               &#123;C1 develop&#125;For debugging: test slow cases by always using them</div><div class="line">     bool UseSquareToLenIntrinsic                   = false                               &#123;C2 product&#125;Enables intrinsification of BigInteger.squareToLen()</div><div class="line">     bool UseStackBanging                           = true                                &#123;develop&#125;use stack banging for stack overflow checks (required for proper StackOverflow handling; disable only to measure cost of stackbanging)</div><div class="line">     bool UseStoreImmI16                            = true                                &#123;ARCH product&#125;Use store immediate 16-bits value instruction on x86</div><div class="line">     bool UseStrictFP                               = true                                &#123;develop&#125;use strict fp if modifier strictfp is set</div><div class="line">     bool UseStringDeduplication                    = false                               &#123;product&#125;Use string deduplication</div><div class="line">     bool UseSuperWord                              = true                                &#123;C2 product&#125;Transform scalar operations into superword operations</div><div class="line">     bool UseTLAB                                   = true                                &#123;pd product&#125;Use thread-local object allocation</div><div class="line">     bool UseTableRanges                            = true                                &#123;C1 develop&#125;Faster versions of lookup table using ranges</div><div class="line">     bool UseThreadPriorities                       = true                                &#123;pd product&#125;Use native thread priorities</div><div class="line">     bool UseTransparentHugePages                   = false                               &#123;product&#125;Use MADV_HUGEPAGE for large pages</div><div class="line">     bool UseTypeProfile                            = true                                &#123;product&#125;Check interpreter profile for historically monomorphic calls</div><div class="line">     bool UseTypeSpeculation                        = true                                &#123;C2 product&#125;Speculatively propagate types from profiles</div><div class="line">     bool UseUnalignedLoadStores                    = false                               &#123;ARCH product&#125;Use SSE2 MOVDQU instruction for Arraycopy</div><div class="line">     bool UseUniqueSubclasses                       = true                                &#123;C2 develop&#125;Narrow an abstract reference to the unique concrete subclass</div><div class="line">     bool UseVMInterruptibleIO                      = false                               &#123;product&#125;(Unstable, Solaris-specific) Thread interrupt before or with EINTR for I/O operations results in OS_INTRPT. The default value of this flag is true for JDK 6 and earlier</div><div class="line">     bool UseXMMForArrayCopy                        = false                               &#123;product&#125;Use SSE2 MOVQ instruction for Arraycopy</div><div class="line">     bool UseXmmI2D                                 = false                               &#123;ARCH product&#125;Use SSE2 CVTDQ2PD instruction to convert Integer to Double</div><div class="line">     bool UseXmmI2F                                 = false                               &#123;ARCH product&#125;Use SSE2 CVTDQ2PS instruction to convert Integer to Float</div><div class="line">     bool UseXmmLoadAndClearUpper                   = true                                &#123;ARCH product&#125;Load low part of XMM register and clear upper part</div><div class="line">     bool UseXmmRegToRegMoveAll                     = false                               &#123;ARCH product&#125;Copy all XMM register bits when moving value between registers</div><div class="line">     bool VMThreadHintNoPreempt                     = false                               &#123;product&#125;(Solaris only) Give VM thread an extra quanta</div><div class="line">     intx VMThreadPriority                          = -1                                  &#123;product&#125;The native priority at which the VM thread should run (-1 means no change)</div><div class="line">     intx VMThreadStackSize                         = 1024                                &#123;pd product&#125;Non-Java Thread Stack Size (in Kbytes)</div><div class="line">     intx ValueMapInitialSize                       = 11                                  &#123;C1 product&#125;Initial size of a value map</div><div class="line">     intx ValueMapMaxLoopSize                       = 8                                   &#123;C1 product&#125;maximum size of a loop optimized by global value numbering</div><div class="line">     intx ValueSearchLimit                          = 1000                                &#123;C2 product&#125;Recursion limit in PhaseMacroExpand::value_from_mem_phi</div><div class="line">     bool Verbose                                   = false                               &#123;develop&#125;Print additional debugging information from other modes</div><div class="line">     bool VerboseInternalVMTests                    = false                               &#123;notproduct&#125;Turn on logging for internal VM tests.</div><div class="line">     bool VerboseVerification                       = false                               &#123;diagnostic&#125;Display detailed verification details</div><div class="line">     bool VerifyActivationFrameSize                 = false                               &#123;develop&#125;Verify that activation frame didn&apos;t become smaller than its minimal size</div><div class="line">     bool VerifyAdapterCalls                        = true                                &#123;diagnostic&#125;Verify that i2c/c2i adapters are called properly</div><div class="line">     bool VerifyAdapterSharing                      = false                               &#123;develop&#125;Verify that the code for shared adapters is the equivalent</div><div class="line">     bool VerifyAfterGC                             = false                               &#123;diagnostic&#125;Verify memory system after GC</div><div class="line">     bool VerifyAliases                             = false                               &#123;C2 develop&#125;perform extra checks on the results of alias analysis</div><div class="line">     bool VerifyBeforeExit                          = true                                &#123;diagnostic&#125;Verify system before exiting</div><div class="line">     bool VerifyBeforeGC                            = false                               &#123;diagnostic&#125;Verify memory system before GC</div><div class="line">     bool VerifyBeforeIteration                     = false                               &#123;diagnostic&#125;Verify memory system before JVMTI iteration</div><div class="line">     bool VerifyBlockOffsetArray                    = false                               &#123;develop&#125;Do (expensive) block offset array verification</div><div class="line">     bool VerifyCodeCacheOften                      = false                               &#123;notproduct&#125;Verify compiled-code cache often</div><div class="line">     bool VerifyCompiledCode                        = false                               &#123;develop&#125;Include miscellaneous runtime verifications in nmethod code; default off because it disturbs nmethod size heuristics</div><div class="line">     bool VerifyConnectionGraph                     = true                                &#123;C2 notproduct&#125;Verify Connection Graph construction in Escape Analysis</div><div class="line">     bool VerifyDUIterators                         = true                                &#123;C2 notproduct&#125;Verify the safety of all iterations of Bi-directional Edges</div><div class="line">     bool VerifyDataPointer                         = true                                &#123;develop&#125;Verify the method data pointer during interpreter profiling</div><div class="line">     bool VerifyDependencies                        = true                                &#123;develop&#125;Exercise and verify the compilation dependency mechanism</div><div class="line">     bool VerifyDuringGC                            = false                               &#123;diagnostic&#125;Verify memory system during GC (between phases)</div><div class="line">     bool VerifyDuringStartup                       = false                               &#123;diagnostic&#125;Verify memory system before executing any Java code during VM initialization</div><div class="line">     bool VerifyFPU                                 = false                               &#123;develop&#125;Verify FPU state (check for NaN&apos;s, etc.)</div><div class="line">     intx VerifyGCLevel                             = 0                                   &#123;diagnostic&#125;Generation level at which to start +VerifyBefore/AfterGC</div><div class="line">    uintx VerifyGCStartAt                           = 0                                   &#123;diagnostic&#125;GC invoke count where +VerifyBefore/AfterGC kicks in</div><div class="line">     bool VerifyGenericSignatures                   = false                               &#123;develop&#125;Abort VM on erroneous or inconsistent generic signatures</div><div class="line">     bool VerifyGraphEdges                          = false                               &#123;C2 notproduct&#125;Verify Bi-directional Edges</div><div class="line">     bool VerifyHashTableKeys                       = true                                &#123;C2 notproduct&#125;Verify the immutability of keys in the VN hash tables</div><div class="line">     bool VerifyIdealNodeCount                      = false                               &#123;C2 notproduct&#125;Verify that tracked dead ideal node count is accurate</div><div class="line">     bool VerifyIterativeGVN                        = false                               &#123;C2 develop&#125;Verify Def-Use modifications during sparse Iterative Global Value Numbering</div><div class="line">     bool VerifyJNIEnvThread                        = false                               &#123;notproduct&#125;Verify JNIEnv.thread == Thread::current() when entering VM from JNI</div><div class="line">     bool VerifyJNIFields                           = true                                &#123;develop&#125;Verify jfieldIDs for instance fields</div><div class="line">     bool VerifyLastFrame                           = false                               &#123;notproduct&#125;Verify oops on last frame on entry to VM</div><div class="line">     bool VerifyLoopOptimizations                   = false                               &#123;C2 notproduct&#125;verify major loop optimizations</div><div class="line">     bool VerifyMergedCPBytecodes                   = true                                &#123;product&#125;Verify bytecodes after RedefineClasses constant pool merging</div><div class="line">     bool VerifyMethodHandles                       = true                                &#123;diagnostic&#125;perform extra checks when constructing method handles</div><div class="line">     bool VerifyObjectStartArray                    = true                                &#123;diagnostic&#125;Verify GC object start array if verify before/after</div><div class="line">     bool VerifyOops                                = false                               &#123;develop&#125;Do plausibility checks for oops</div><div class="line">     bool VerifyOpto                                = false                               &#123;C2 notproduct&#125;Apply more time consuming verification during compilation</div><div class="line">     bool VerifyOptoOopOffsets                      = false                               &#123;C2 notproduct&#125;Check types of base addresses in field references</div><div class="line">     bool VerifyReflectionBytecodes                 = false                               &#123;develop&#125;Force verification of 1.4 reflection bytecodes. Does not work in situations like that described in 4486457 or for constructors generated for serialization, so can not be enabled in product.</div><div class="line">     bool VerifyRegisterAllocator                   = false                               &#123;C2 notproduct&#125;Verify Register Allocator</div><div class="line">     bool VerifyRememberedSets                      = false                               &#123;diagnostic&#125;Verify GC remembered sets</div><div class="line">     bool VerifySharedSpaces                        = false                               &#123;product&#125;Verify shared spaces (false for default archive, true for archive specified by -XX:SharedArchiveFile)</div><div class="line">     bool VerifySilently                            = false                               &#123;diagnostic&#125;Do not print the verification progress</div><div class="line">     bool VerifyStack                               = false                               &#123;develop&#125;Verify stack of each thread when it is entering a runtime call</div><div class="line">     bool VerifyStackAtCalls                        = false                               &#123;develop&#125;Verify that the stack pointer is unchanged after calls</div><div class="line">     bool VerifyStringTableAtExit                   = false                               &#123;diagnostic&#125;verify StringTable contents at exit</div><div class="line">ccstrlist VerifySubSet                              =                                     &#123;diagnostic&#125;Memory sub-systems to verify when Verify*GC flag(s) are enabled. One or more sub-systems can be specified in a comma separated string. Sub-systems are: threads, heap, symbol_table, string_table, codecache, dictionary, classloader_data_graph, metaspace, jni_handles, c-heap, codecache_oops</div><div class="line">     bool VerifyThread                              = false                               &#123;develop&#125;Watch the thread register for corruption (SPARC only)</div><div class="line">     bool WalkStackALot                             = false                               &#123;notproduct&#125;Trace stack (no print) at every exit from the runtime system</div><div class="line">     intx WarmCallMaxSize                           = 999999                              &#123;C2 develop&#125;size of the largest inlinable method</div><div class="line">     intx WarmCallMaxWork                           = 999999                              &#123;C2 develop&#125;execution time of the largest inlinable method</div><div class="line">     intx WarmCallMinCount                          = -1                                  &#123;C2 develop&#125;number of calls (per method invocation) to enable inlining</div><div class="line">     intx WarmCallMinProfit                         = -1                                  &#123;C2 develop&#125;number of calls (per method invocation) to enable inlining</div><div class="line">    uintx WarnOnStalledSpinLock                     = 0                                   &#123;notproduct&#125;Print warnings for stalled SpinLocks</div><div class="line">     bool WhiteBoxAPI                               = false                               &#123;diagnostic&#125;Enable internal testing APIs</div><div class="line">     bool WizardMode                                = false                               &#123;develop&#125;Print much more debugging information</div><div class="line">     intx WorkAroundNPTLTimedWaitHang               = 1                                   &#123;product&#125;(Unstable, Linux-specific) avoid NPTL-FUTEX hang pthread_cond_timedwait</div><div class="line">    uintx YoungGenerationSizeIncrement              = 20                                  &#123;product&#125;Adaptive size percentage change in young generation</div><div class="line">    uintx YoungGenerationSizeSupplement             = 80                                  &#123;product&#125;Supplement to YoungedGenerationSizeIncrement used at startup</div><div class="line">    uintx YoungGenerationSizeSupplementDecay        = 8                                   &#123;product&#125;Decay factor to YoungedGenerationSizeSupplement</div><div class="line">    uintx YoungPLABSize                             = 4096                                &#123;product&#125;Size of young gen promotion LAB&apos;s (in HeapWords)</div><div class="line">     bool ZapDeadCompiledLocals                     = false                               &#123;develop&#125;Zap dead locals in compiler frames</div><div class="line">     intx ZapDeadCompiledLocalsFirst                = 0                                   &#123;C2 notproduct&#125;If +ZapDeadCompiledLocals, skip this many before really doing it</div><div class="line">     intx ZapDeadCompiledLocalsLast                 = -1                                  &#123;C2 notproduct&#125;If +ZapDeadCompiledLocals, do this many after skipping (incl. skip count, -1 = all)</div><div class="line">     bool ZapDeadLocalsOld                          = false                               &#123;notproduct&#125;Zap dead locals (old version, zaps all frames when entering the VM</div><div class="line">     bool ZapFillerObjects                          = true                                &#123;develop&#125;Zap filler objects with 0xDEAFBABE</div><div class="line">     bool ZapJNIHandleArea                          = true                                &#123;develop&#125;Zap freed JNI handle space with 0xFEFEFEFE</div><div class="line">     bool ZapResourceArea                           = true                                &#123;develop&#125;Zap freed resource/arena space with 0xABABABAB</div><div class="line">     bool ZapStackSegments                          = true                                &#123;notproduct&#125;Zap allocated/freed stack segments with 0xFADFADED</div><div class="line">     bool ZapUnusedHeapArea                         = true                                &#123;develop&#125;Zap unused heap space with 0xBAADBABE</div><div class="line">     bool ZapVMHandleArea                           = true                                &#123;notproduct&#125;Zap freed VM handle space with 0xBCBCBCBC</div><div class="line">     bool ZeroTLAB                                  = false                               &#123;product&#125;Zero out the newly created TLAB</div><div class="line">     bool ZombieALot                                = false                               &#123;notproduct&#125;Create zombies (non-entrant) at exit from the runtime system</div><div class="line">     intx ZombieALotInterval                        = 5                                   &#123;notproduct&#125;Number of exits until ZombieALot kicks in</div><div class="line">     intx hashCode                                  = 5                                   &#123;product&#125;(Unstable) select hashCode generation algorithm</div></pre></td></tr></table></figure>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/09/23/jvm/java-xx-command/" class="archive-article-date">
  	<time datetime="2016-09-23T03:30:40.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-09-23</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/JAVA/">JAVA</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-jvm/symbol-table-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/23/jvm/symbol-table-1/">JVM之SymbolTable(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虚拟机中重要的数据结构之一，可以看到虚拟机的代码中到处可以看到这个数据结构的使用，虚拟机运行时的符号等都是保存在这个数据结构中的。<br>文中介绍SymbolTable的实现，初始化和基本用法。</p>
<h2 id="SymbolTable初始化"><a href="#SymbolTable初始化" class="headerlink" title="SymbolTable初始化"></a>SymbolTable初始化</h2><p>符号表是一个Hash表<br>SymbolTable是通过调用initialize_symbols进行初始化的。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">void</span> SymbolTable::initialize_symbols(<span class="keyword">int</span> arena_alloc_size) &#123;</div><div class="line">  <span class="comment">// Initialize the arena for global symbols, size passed in depends on CDS.</span></div><div class="line">  <span class="keyword">if</span> (arena_alloc_size == <span class="number">0</span>) &#123;</div><div class="line">    <span class="number">_</span>arena = <span class="keyword">new</span> (mtSymbol) Arena();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="number">_</span>arena = <span class="keyword">new</span> (mtSymbol) Arena(arena_alloc_size);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以知道符号表的初始化时通过使用Arena来管理内存的，可以参考<a href="/2016/09/21/jvm-memory-allocate/">JVM 基础设施之内存分配</a>。我们可以知道符号表的内存类型mtSymbol，在MemTrack的类型也是mtSymbol。对应的内存是单独向操作系统申请的，和虚拟机的内存管理是独立的。</p>
<h2 id="创建符号"><a href="#创建符号" class="headerlink" title="创建符号"></a>创建符号</h2><p>可以通过调用<strong>SymbolTable::new_permanent_symbol</strong>在符号表中创建符号，看一下实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">Symbol* SymbolTable::new_permanent_symbol(<span class="keyword">const</span> <span class="keyword">char</span>* name, TRAPS) &#123;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> hash;</div><div class="line">  Symbol* result = SymbolTable::lookup_only((<span class="keyword">char</span>*)name, (<span class="keyword">int</span>)<span class="built_in">strlen</span>(name), hash);</div><div class="line">  <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// Grab SymbolTable_lock first.</span></div><div class="line">  <span class="function">MutexLocker <span class="title">ml</span><span class="params">(SymbolTable_lock, THREAD)</span></span>;</div><div class="line"></div><div class="line">  SymbolTable* table = the_table();</div><div class="line">  <span class="keyword">int</span> index = table-&gt;hash_to_index(hash);</div><div class="line">  <span class="keyword">return</span> table-&gt;basic_add(index, (u1*)name, (<span class="keyword">int</span>)<span class="built_in">strlen</span>(name), hash, <span class="literal">false</span>, THREAD);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在创建之前我们需要先检查这个符号我们是否已经建立了，从缓存中获取，先看看查找的过程。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\classfile\symbolTable.cpp:</div><div class="line"></div><div class="line">Symbol* SymbolTable::lookup_only(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> len,</div><div class="line">                                   <span class="keyword">unsigned</span> <span class="keyword">int</span>&amp; hash) &#123;</div><div class="line">  hash = hash_symbol(name, len);</div><div class="line">  <span class="keyword">int</span> index = the_table()-&gt;hash_to_index(hash);</div><div class="line"></div><div class="line">  Symbol* s = the_table()-&gt;lookup(index, name, len, hash);</div><div class="line">  <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了提升查找的效率，采用的是hash算法，首先先算出这个name对应的hash值。hash算法在内核和性能要求比较高的实现中，是普遍的算法之一。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">unsigned int SymbolTable::hash_symbol(const char* s, int len) &#123;</div><div class="line">  return use_alternate_hashcode() ?</div><div class="line">           AltHashing::murmur3_32(seed(), (const jbyte*)s, len) :</div><div class="line">           java_lang_String::to_hash(s, len);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/09/23/jvm/symbol-table-1/" class="archive-article-date">
  	<time datetime="2016-09-23T03:30:40.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-09-23</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/JAVA/">JAVA</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-jvm/jvm-hash-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/23/jvm/jvm-hash-1/">JVM之Hash算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虚拟机中重要的算法之一。虚拟机采用Murmur3算法。</p>
<h2 id="虚拟机中的Hash算法"><a href="#虚拟机中的Hash算法" class="headerlink" title="虚拟机中的Hash算法"></a>虚拟机中的Hash算法</h2><p>虚拟机中采用的Hash算法是Murmur3，Murmur3算法是高运算性能，低碰撞率，由Austin Appleby创建于2008年，现已应用到Hadoop、libstdc++、nginx、libmemcached等开源系统。2011年Appleby被Google雇佣，随后Google推出其变种的CityHash算法。<br>目前Murmur3官方实现版本已经迁移到github上，地址<a href="https://github.com/aappleby/smhasher" target="_blank" rel="external">https://github.com/aappleby/smhasher</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/09/23/jvm/jvm-hash-1/" class="archive-article-date">
  	<time datetime="2016-09-23T03:30:40.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-09-23</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/JAVA/">JAVA</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-jvm/klass-desc-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/23/jvm/klass-desc-3/">JVM之Klass结构介绍(一)-----Klass结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>前面介绍了Klass总体结构以及oopDesc各个详细介绍，这里我们开始进入正题，重点介绍Klass，Klass作为JVM运行时的重要结构，提供了class运行时的内存结构，需要注意class和Klass的区分，Klass和Class类的区分，运行时期的Class类在内存中的结构并不是Klass。</p>
<h2 id="Klass-类"><a href="#Klass-类" class="headerlink" title="Klass 类"></a>Klass 类</h2><p>这个类是整个Klass体系的基类，所有的子类都会有这个特性，下面描述的内容适合任何继承这个类的子类。<br>先看看它的定义,只看他的成员：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> oopDesc &#123;</div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> VMStructs;</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keyword">volatile</span> markOop  <span class="number">_</span>mark;</div><div class="line">  <span class="keyword">union</span> <span class="number">_</span>metadata &#123;</div><div class="line">    wideKlassOop    <span class="number">_</span>klass;</div><div class="line">    narrowOop       <span class="number">_</span>compressed_klass;</div><div class="line">  &#125; <span class="number">_</span>metadata;</div><div class="line"></div><div class="line"> ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>oopDesc</strong>结构如下：<br><img src="/img/jvm/oopDesc_class.png" alt=""><br>我们分别看一下这个结构的成员，先看看第一个成员：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">volatile</span> markOop  <span class="number">_</span>mark;</div></pre></td></tr></table></figure></p>
<p>这个成员的介绍可以参考<strong>markOopDesc</strong>结构。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">union</span> <span class="number">_</span>metadata &#123;</div><div class="line">  wideKlassOop    <span class="number">_</span>klass;</div><div class="line">  narrowOop       <span class="number">_</span>compressed_klass;</div><div class="line">&#125; <span class="number">_</span>metadata;</div></pre></td></tr></table></figure></p>
<p>这个成员主要用于为每个Klass维护一个对应的OopDesc指针。这是一个union结构，根据不同的场景解释，JVM提供一个压缩指针的特性，可以降低内存的使用，这里_compressed_klass指针指向的就是开启此功能会使用的指针。</p>
<h2 id="markOopDesc"><a href="#markOopDesc" class="headerlink" title="markOopDesc"></a>markOopDesc</h2><p>每一个<strong>oopDesc</strong>以及子类都会有这个类的成员，这个成员控制了一些控制信息，各个控制位的功能，现在也不清楚，先做一个<strong>Mark</strong>,后面补充。<br>目前可以知道这个结构其实和oopDesc体系没有直接关系，只是由于历史原因导致。这个结构直接使用为oopDesc分配的内存空间作为真正的存储控制位的位置。所有解释的内容都来自oopDesc。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">//  64 bits:</span></div><div class="line"><span class="comment">//  --------</span></div><div class="line"><span class="comment">//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span></div><div class="line"><span class="comment">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span></div><div class="line"><span class="comment">//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></div><div class="line"><span class="comment">//  size:64 -----------------------------------------------------&gt;| (CMS free block)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)</span></div><div class="line"><span class="comment">//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)</span></div><div class="line"><span class="comment">//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)</span></div><div class="line"><span class="comment">//  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)</span></div></pre></td></tr></table></figure></p>
<h2 id="instanceKlass"><a href="#instanceKlass" class="headerlink" title="instanceKlass"></a>instanceKlass</h2><h3 id="instanceMirrorKlass"><a href="#instanceMirrorKlass" class="headerlink" title="instanceMirrorKlass"></a>instanceMirrorKlass</h3><h3 id="instanceRefKlass"><a href="#instanceRefKlass" class="headerlink" title="instanceRefKlass"></a>instanceRefKlass</h3><h2 id="methodKlass"><a href="#methodKlass" class="headerlink" title="methodKlass"></a>methodKlass</h2><h2 id="constMethodKlass"><a href="#constMethodKlass" class="headerlink" title="constMethodKlass"></a>constMethodKlass</h2><h2 id="methodDataKlass"><a href="#methodDataKlass" class="headerlink" title="methodDataKlass"></a>methodDataKlass</h2><h2 id="klassKlass"><a href="#klassKlass" class="headerlink" title="klassKlass"></a>klassKlass</h2><h3 id="instanceKlassKlass"><a href="#instanceKlassKlass" class="headerlink" title="instanceKlassKlass"></a>instanceKlassKlass</h3><h3 id="arrayKlassKlass"><a href="#arrayKlassKlass" class="headerlink" title="arrayKlassKlass"></a>arrayKlassKlass</h3><h4 id="objArrayKlassKlass"><a href="#objArrayKlassKlass" class="headerlink" title="objArrayKlassKlass"></a>objArrayKlassKlass</h4><h4 id="typeArrayKlassKlass"><a href="#typeArrayKlassKlass" class="headerlink" title="typeArrayKlassKlass"></a>typeArrayKlassKlass</h4><h2 id="arrayKlass"><a href="#arrayKlass" class="headerlink" title="arrayKlass"></a>arrayKlass</h2><h3 id="objArrayKlass"><a href="#objArrayKlass" class="headerlink" title="objArrayKlass"></a>objArrayKlass</h3><h3 id="typeArrayKlass"><a href="#typeArrayKlass" class="headerlink" title="typeArrayKlass"></a>typeArrayKlass</h3><h2 id="constantPoolKlass"><a href="#constantPoolKlass" class="headerlink" title="constantPoolKlass"></a>constantPoolKlass</h2><h2 id="klassOopDesc"><a href="#klassOopDesc" class="headerlink" title="klassOopDesc"></a>klassOopDesc</h2><h2 id="constantPoolCacheKlass"><a href="#constantPoolCacheKlass" class="headerlink" title="constantPoolCacheKlass"></a>constantPoolCacheKlass</h2><h2 id="compiledICHolderKlass"><a href="#compiledICHolderKlass" class="headerlink" title="compiledICHolderKlass"></a>compiledICHolderKlass</h2>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/09/23/jvm/klass-desc-3/" class="archive-article-date">
  	<time datetime="2016-09-23T01:52:40.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-09-23</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/JAVA/">JAVA</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-jvm/klass-desc-4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/23/jvm/klass-desc-4/">JVM之Klass结构介绍(三)-----Klass初始化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>之前我们已经对数据结构有了一定的了解，这里我们看一下Klass对应结构的初始化。</p>
<h2 id="klassKlassObj对象"><a href="#klassKlassObj对象" class="headerlink" title="klassKlassObj对象"></a>klassKlassObj对象</h2><p><strong>klassKlassObj</strong>对象是一个<strong>klassOop</strong>结构的实例。<br><img src="/img/jvm/klassKlassObj.png" alt=""><br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\memory\universe.cpp:</div><div class="line"></div><div class="line"><span class="keyword">void</span> Universe::genesis(TRAPS) &#123;</div><div class="line">...</div><div class="line"></div><div class="line">        <span class="number">_</span>klassKlassObj          = klassKlass::create_klass(CHECK);</div><div class="line">&#125;</div><div class="line"></div><div class="line">hotspot\src\share\vm\oops\klassKlass.cpp:</div><div class="line"></div><div class="line">klassOop klassKlass::create_klass(TRAPS) &#123;</div><div class="line">  KlassHandle h_this_klass; </div><div class="line">  klassKlass o;</div><div class="line">  <span class="comment">// for bootstrapping, handles may not be available yet.</span></div><div class="line">  klassOop k = base_create_klass_oop(h_this_klass, header_size(), o.vtbl_value(), CHECK_NULL);</div><div class="line">  k-&gt;set_klass(k); <span class="comment">// point to thyself</span></div><div class="line">  <span class="comment">// Do not try to allocate mirror, java.lang.Class not loaded at this point.</span></div><div class="line">  <span class="comment">// See Universe::fixup_mirrors()</span></div><div class="line">  <span class="keyword">return</span> k;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意这里h_this_klass以及o变量实在栈中分配。JVM为<strong>Klass</strong>提供了方便的<strong>KlassHandle</strong>，可以很方便的访问以及控制<strong>Klass</strong>。调用base_create_klass_oop创建对应的oop结构。注意这个方法的参数：<br>KlassHandle&amp; klass：这个是我们刚刚说的<strong>KlassHandle</strong>，指向的对应为null<br>int size：指的是对象大小，这里是oopDesc+klassKlass。<br>const Klass_vtbl&amp; vtbl：这是vtbl的结构，也就是klassKlass，由其分配内存空间。<br>TRAPS：可以看到这个的预定义,可以知道指的是THREAD <strong>the_thread</strong>，那么为什么这么写呢：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\utilities\exceptions.hpp：</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD __the_thread__</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TRAPS  Thread* THREAD</span></div></pre></td></tr></table></figure></p>
<p>先看看这里专递的参数，也是一个预定义：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\utilities\exceptions.hpp：</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK_NULL                               CHECK_(NULL)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK_(result)                           THREAD); <span class="meta-keyword">if</span> (HAS_PENDING_EXCEPTION) return result; (0</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HAS_PENDING_EXCEPTION                    (((ThreadShadow*)THREAD)-&gt;has_pending_exception())</span></div></pre></td></tr></table></figure></p>
<p>可以看到这里定义了一个处理异常的方式，如果线程对象有一个挂起的异常，那么就直接返回。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\oops\klass.cpp:</div><div class="line"></div><div class="line">klassOop Klass::base_create_klass_oop(KlassHandle&amp; klass, <span class="keyword">int</span> size,</div><div class="line">                                      <span class="keyword">const</span> Klass_vtbl&amp; vtbl, TRAPS) &#123;</div><div class="line">  size = align_object_size(size);</div><div class="line">  <span class="comment">// allocate and initialize vtable</span></div><div class="line">  Klass*   kl = (Klass*) vtbl.allocate_permanent(klass, size, CHECK_NULL);</div><div class="line">  klassOop k  = kl-&gt;as_klassOop();</div><div class="line"></div><div class="line">  &#123; <span class="comment">// Preinitialize supertype information.</span></div><div class="line">    <span class="comment">// A later call to initialize_supers() may update these settings:</span></div><div class="line">    kl-&gt;set_super(<span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">for</span> (juint i = <span class="number">0</span>; i &lt; Klass::primary_super_limit(); i++) &#123;</div><div class="line">      kl-&gt;<span class="number">_</span>primary_supers[i] = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    kl-&gt;set_secondary_supers(<span class="literal">NULL</span>);</div><div class="line">    oop_store_without_check((oop*) &amp;kl-&gt;<span class="number">_</span>primary_supers[<span class="number">0</span>], k);</div><div class="line">    kl-&gt;set_super_check_offset(in_bytes(primary_supers_offset()));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  kl-&gt;set_java_mirror(<span class="literal">NULL</span>);</div><div class="line">  kl-&gt;set_modifier_flags(<span class="number">0</span>);</div><div class="line">  kl-&gt;set_layout_helper(Klass::<span class="number">_l</span>h_neutral_value);</div><div class="line">  kl-&gt;set_name(<span class="literal">NULL</span>);</div><div class="line">  AccessFlags af;</div><div class="line">  af.set_flags(<span class="number">0</span>);</div><div class="line">  kl-&gt;set_access_flags(af);</div><div class="line">  kl-&gt;set_subklass(<span class="literal">NULL</span>);</div><div class="line">  kl-&gt;set_next_sibling(<span class="literal">NULL</span>);</div><div class="line">  kl-&gt;set_alloc_count(<span class="number">0</span>);</div><div class="line">  kl-&gt;set_alloc_size(<span class="number">0</span>);</div><div class="line">  TRACE_INIT_ID(kl);</div><div class="line"></div><div class="line">  kl-&gt;set_prototype_header(markOopDesc::prototype());</div><div class="line">  kl-&gt;set_biased_lock_revocation_count(<span class="number">0</span>);</div><div class="line">  kl-&gt;set_last_biased_lock_bulk_revocation_time(<span class="number">0</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> k;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们已经知道了分配内存空间，在这个场景是调用的是<strong>klassKlass::allocate_permanent</strong>（其实就是Klass::allocate_permanent）。程序中定义了一个统一的处理函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\oops\klass.hpp:</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_ALLOCATE_PERMANENT(thisKlass)                                  \</span></div><div class="line">  void* allocate_permanent(KlassHandle&amp; klass_klass, int size, TRAPS) const &#123; \</div><div class="line">    void* result = new(klass_klass, size, THREAD) thisKlass();                \</div><div class="line">    <span class="meta-keyword">if</span> (HAS_PENDING_EXCEPTION) return NULL;                                   \</div><div class="line">    klassOop new_klass = ((Klass*) result)-&gt;as_klassOop();                    \</div><div class="line">    OrderAccess::storestore();                                                \</div><div class="line">    post_new_init_klass(klass_klass, new_klass);                              \</div><div class="line">    return result;                                                            \</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>Klass定义了一个预处理函数，在KlassKlass中调用了这个预定义：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\oops\klassKlass.hpp:</div><div class="line"></div><div class="line">  DEFINE_ALLOCATE_PERMANENT(klassKlass);</div></pre></td></tr></table></figure></p>
<p>展开就是：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span>* <span class="title">allocate_permanent</span><span class="params">(KlassHandle&amp; klass_klass, <span class="keyword">int</span> size, Thread* <span class="number">__</span>the_thread__)</span> <span class="keyword">const</span> </span>&#123; \</div><div class="line">    <span class="keyword">void</span>* result = <span class="keyword">new</span>(klass_klass, size, <span class="number">__</span>the_thread__) klassKlass();                \</div><div class="line">    <span class="keyword">if</span> ((((ThreadShadow*)<span class="number">__</span>the_thread__)-&gt;has_pending_exception())) <span class="keyword">return</span> <span class="number">0</span>;                                   \</div><div class="line">    klassOop new_klass = ((Klass*) result)-&gt;as_klassOop();                    \</div><div class="line">    OrderAccess::storestore();                                                \</div><div class="line">    post_new_init_klass(klass_klass, new_klass);                              \</div><div class="line">    <span class="keyword">return</span> result;                                                            \</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到new的调用是klassKlass类的new：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\oops\klass.cpp:</div><div class="line"></div><div class="line">void* Klass_vtbl::operator new(size_t ignored, KlassHandle&amp; klass,</div><div class="line">                               int size, TRAPS) &#123;</div><div class="line">  // The vtable pointer is installed during the execution of</div><div class="line">  // constructors in the call to permanent_obj_allocate().  Delay</div><div class="line">  // the installation of the klass pointer into the new klass &quot;k&quot;</div><div class="line">  // until after the vtable pointer has been installed (i.e., until</div><div class="line">  // after the return of permanent_obj_allocate().</div><div class="line">  klassOop k =</div><div class="line">    (klassOop) CollectedHeap::permanent_obj_allocate_no_klass_install(klass,</div><div class="line">      size, CHECK_NULL);</div><div class="line">  return k-&gt;klass_part();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以知道new的第一个参数没有使用，这个参数指的是klassKlass的大小，那么为什么不使用呢，我们在前面看到了size中已经包含了这个参数的大小，由内存分配统一管理。继续往下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\gc_interface\collectedHeap.<span class="keyword">inline</span>.hpp:</div><div class="line"></div><div class="line">oop CollectedHeap::permanent_obj_allocate_no_klass_install(KlassHandle klass,</div><div class="line">                                                           <span class="keyword">int</span> size,</div><div class="line">                                                           TRAPS) &#123;</div><div class="line">  debug_only(check_for_valid_allocation_state());</div><div class="line">  assert(!Universe::heap()-&gt;is_gc_active(), <span class="string">"Allocation during gc not allowed"</span>);</div><div class="line">  assert(size &gt;= <span class="number">0</span>, <span class="string">"int won't convert to size_t"</span>);</div><div class="line">  HeapWord* obj = common_permanent_mem_allocate_init(size, CHECK_NULL);</div><div class="line">  post_allocation_setup_no_klass_install(klass, obj);</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PRODUCT</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> hs = oopDesc::header_size();</div><div class="line">  Universe::heap()-&gt;check_for_bad_heap_word_value(obj+hs, size-hs);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">  <span class="keyword">return</span> (oop)obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">HeapWord* CollectedHeap::common_permanent_mem_allocate_init(<span class="keyword">size_t</span> size, TRAPS) &#123;</div><div class="line">  HeapWord* obj = common_permanent_mem_allocate_noinit(size, CHECK_NULL);</div><div class="line">  init_obj(obj, size);</div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">HeapWord* CollectedHeap::common_permanent_mem_allocate_noinit(<span class="keyword">size_t</span> size, TRAPS) &#123;</div><div class="line">  <span class="keyword">if</span> (HAS_PENDING_EXCEPTION) &#123;</div><div class="line">    NOT_PRODUCT(guarantee(<span class="literal">false</span>, <span class="string">"Should not allocate with exception pending"</span>));</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// caller does a CHECK_NULL too</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></div><div class="line">  <span class="keyword">if</span> (CIFireOOMAt &gt; <span class="number">0</span> &amp;&amp; THREAD-&gt;is_Compiler_thread() &amp;&amp;</div><div class="line">      ++<span class="number">_f</span>ire_out_of_memory_count &gt;= CIFireOOMAt) &#123;</div><div class="line">    <span class="comment">// For testing of OOM handling in the CI throw an OOM and see how</span></div><div class="line">    <span class="comment">// it does.  Historically improper handling of these has resulted</span></div><div class="line">    <span class="comment">// in crashes which we really don't want to have in the CI.</span></div><div class="line">    THROW_OOP_0(Universe::out_of_memory_error_perm_gen());</div><div class="line">  &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">  HeapWord* result = Universe::heap()-&gt;permanent_mem_allocate(size);</div><div class="line">  <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</div><div class="line">    NOT_PRODUCT(Universe::heap()-&gt;</div><div class="line">      check_for_non_bad_heap_word_value(result, size));</div><div class="line">    assert(!HAS_PENDING_EXCEPTION,</div><div class="line">           <span class="string">"Unexpected exception, will result in uninitialized storage"</span>);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// -XX:+HeapDumpOnOutOfMemoryError and -XX:OnOutOfMemoryError support</span></div><div class="line">  report_java_out_of_memory(<span class="string">"PermGen space"</span>);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (JvmtiExport::should_post_resource_exhausted()) &#123;</div><div class="line">    JvmtiExport::post_resource_exhausted(</div><div class="line">        JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR,</div><div class="line">        <span class="string">"PermGen space"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  THROW_OOP_0(Universe::out_of_memory_error_perm_gen());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> CollectedHeap::init_obj(HeapWord* obj, <span class="keyword">size_t</span> size) &#123;</div><div class="line">  assert(obj != <span class="literal">NULL</span>, <span class="string">"cannot initialize NULL object"</span>);</div><div class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> hs = oopDesc::header_size();</div><div class="line">  assert(size &gt;= hs, <span class="string">"unexpected object size"</span>);</div><div class="line">  ((oop)obj)-&gt;set_klass_gap(<span class="number">0</span>);</div><div class="line">  Copy::fill_to_aligned_words(obj + hs, size - hs);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，这里其实已经交给内存管理器分配内存了，交给Java内存堆分配内存了，我们主要注意的是这个分配内存是在内存结构中的持久区，后面写一个专门介绍Java内存和GC的。这里就不详细描述了，只要知道我们获取了需要的内存就行了(JVM8已经取消了持久区)。fill_to_aligned_words的作用就是初始化KlassKlass。重点往下看：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\gc_interface\collectedHeap.<span class="keyword">inline</span>.hpp:</div><div class="line"></div><div class="line"><span class="keyword">void</span> CollectedHeap::post_allocation_setup_no_klass_install(KlassHandle klass,</div><div class="line">                                                           HeapWord* objPtr) &#123;</div><div class="line">  oop obj = (oop)objPtr;</div><div class="line"></div><div class="line">  assert(obj != <span class="literal">NULL</span>, <span class="string">"NULL object pointer"</span>);</div><div class="line">  <span class="keyword">if</span> (UseBiasedLocking &amp;&amp; (klass() != <span class="literal">NULL</span>)) &#123;</div><div class="line">    obj-&gt;set_mark(klass-&gt;prototype_header());</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// May be bootstrapping</span></div><div class="line">    obj-&gt;set_mark(markOopDesc::prototype());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到这里klass为null，所以KlassOopDesc的mark为markOopDesc::prototype()，即：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\oops\markOop.hpp:</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">static</span> markOop <span class="title">prototype</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> markOop( no_hash_in_place | no_lock_in_place );</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>返回到allocate_permanent，<strong>OrderAccess::storestore()</strong>这个是实现Java内存模型重要的一步，涉及到处理器的内存模型，及其复杂，有时间也写一个这个相关的知识。这里只要知道调用这个方法后，后续处理器看到的内容是一致的就行了。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\oops\klass.cpp:</div><div class="line"></div><div class="line"><span class="keyword">void</span> Klass_vtbl::post_new_init_klass(KlassHandle&amp; klass,</div><div class="line">                                     klassOop new_klass) <span class="keyword">const</span> &#123;</div><div class="line">  assert(!new_klass-&gt;klass_part()-&gt;null_vtbl(), <span class="string">"Not a complete klass"</span>);</div><div class="line">  CollectedHeap::post_allocation_install_obj_klass(klass, new_klass);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> CollectedHeap::post_allocation_install_obj_klass(KlassHandle klass,</div><div class="line">                                                   oop obj) &#123;</div><div class="line">  <span class="comment">// These asserts are kind of complicated because of klassKlass</span></div><div class="line">  <span class="comment">// and the beginning of the world.</span></div><div class="line">  assert(klass() != <span class="literal">NULL</span> || !Universe::is_fully_initialized(), <span class="string">"NULL klass"</span>);</div><div class="line">  assert(klass() == <span class="literal">NULL</span> || klass()-&gt;is_klass(), <span class="string">"not a klass"</span>);</div><div class="line">  assert(klass() == <span class="literal">NULL</span> || klass()-&gt;klass_part() != <span class="literal">NULL</span>, <span class="string">"not a klass"</span>);</div><div class="line">  assert(obj != <span class="literal">NULL</span>, <span class="string">"NULL object pointer"</span>);</div><div class="line">  obj-&gt;set_klass(klass());</div><div class="line">  assert(!Universe::is_fully_initialized() || obj-&gt;blueprint() != <span class="literal">NULL</span>,</div><div class="line">         <span class="string">"missing blueprint"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于klass()为null，所以这里KlassOopDesc的_metadata成员为空。后面会修正这个指针。调用完，我们回到create_klass：<br>这个需要重点注意的是<strong>k-&gt;set_klass(k);</strong>,表明klassKlassObj的Klass指向的是自己，这个也是所有Klass的根。klassKlass作为Klass的描述结构，klassKlass指向的是自己。正如图中的箭头一样，_metadata指向的是klassKlassObj自己。</p>
<p>后面的就是初始化KlassOopDesc和KlassKlass，至此这个对象的初始化已经完成。通过前面的图中，我们可以知道，在低地址是描述结构KlassOop，高地址存放的是KlassKlass结构。</p>
<p>我们来看看几个比较重要的辅助函数：<br>Klass-&gt;as_klassOop()可以从Klass得到描述结构klassOop的指针，看一下这个函数：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\oops\klass.hpp:</div><div class="line"></div><div class="line">  <span class="function">klassOop <span class="title">as_klassOop</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">    <span class="comment">// see klassOop.hpp for layout.</span></div><div class="line">    <span class="keyword">return</span> (klassOop) (((<span class="keyword">char</span>*) <span class="keyword">this</span>) - <span class="keyword">sizeof</span>(klassOopDesc));</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>通过前面可以知道在低地址是描述结构KlassOop(指针)，高地址存放的是KlassKlass结构。Klass前面就是KlassOopDesc，Klass指针减去头的大小就是klassOop地址了。<br>类似，知道klassOop就可以访问Klass，klassOopDesc中的函数klass_part可以快速获取Klass结构：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\oops\klassOop.hpp:</div><div class="line"></div><div class="line">  <span class="function">Klass* <span class="title">klass_part</span><span class="params">()</span> <span class="keyword">const</span>                      </span>&#123; <span class="keyword">return</span> (Klass*)((address)<span class="keyword">this</span> + <span class="keyword">sizeof</span>(klassOopDesc)); &#125;</div></pre></td></tr></table></figure></p>
<p>KlassOopDesc指针加上头的大小就可以特岛Klass的地址了。</p>
<p>需要特别注意的是KlassOop是指向KlassOopDesc的指针，也就是Oop是指针，而OopDesc是真正的数据结构。</p>
<h2 id="arrayKlassKlassObj-objArrayKlassKlassObj-instanceKlassKlassObj-typeArrayKlassKlassObj"><a href="#arrayKlassKlassObj-objArrayKlassKlassObj-instanceKlassKlassObj-typeArrayKlassKlassObj" class="headerlink" title="arrayKlassKlassObj,objArrayKlassKlassObj,instanceKlassKlassObj,typeArrayKlassKlassObj"></a>arrayKlassKlassObj,objArrayKlassKlassObj,instanceKlassKlassObj,typeArrayKlassKlassObj</h2><p>arrayKlassKlass是所有数组的基类。<br><figure class="highlight"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\memory\universe.cpp:</div><div class="line"></div><div class="line">        _arrayKlassKlassObj     = arrayKlassKlass::create_klass(CHECK);</div><div class="line"></div><div class="line"></div><div class="line">hotspot\src\share\vm\oops\arrayKlassKlass.cpp:</div><div class="line"></div><div class="line">klassOop arrayKlassKlass::create_klass(TRAPS) &#123;</div><div class="line">  arrayKlassKlass o;</div><div class="line">  KlassHandle h_this_klass(THREAD, Universe::klassKlassObj());</div><div class="line">  KlassHandle k = base_create_klass(h_this_klass, header_size(), o.vtbl_value(), CHECK_NULL);</div><div class="line">  // Make sure size calculation is right</div><div class="line">  assert(k()-&gt;size() == align_object_size(header_size()), "wrong size for object");</div><div class="line">  java_lang_Class::create_mirror(k, CHECK_NULL); // Allocate mirror, make links</div><div class="line">  return k();</div><div class="line">&#125;</div><div class="line"></div><div class="line">hotspot\src\share\vm\oops\klass.cpp:</div><div class="line"></div><div class="line">KlassHandle Klass::base_create_klass(KlassHandle&amp; klass, int size,</div><div class="line">                                     const Klass_vtbl&amp; vtbl, TRAPS) &#123;</div><div class="line">  klassOop ek = base_create_klass_oop(klass, size, vtbl, THREAD);</div><div class="line">  return KlassHandle(THREAD, ek);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以知道这个创建和klassKlassObj大同小异，主要注意的是：<br>Klass_vtbl指的是arrayKlassKlass<br>KlassHandle&amp; klass指的是指向klassKlassObj的KlassHandle<br>所以arrayKlassKlassObj的_metadata指向的是klassKlassObj。还有一个特别的是，在这里多调用了java_lang_Class::create_mirror。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\classfile\javaClasses.hpp:</div><div class="line">  <span class="function"><span class="keyword">static</span> oop  <span class="title">create_mirror</span><span class="params">(KlassHandle k, TRAPS)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> create_mirror(k, Handle(), THREAD);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">oop java_lang_Class::create_mirror(KlassHandle k, Handle class_loader, TRAPS) &#123;</div><div class="line">  assert(k-&gt;java_mirror() == <span class="literal">NULL</span>, <span class="string">"should only assign mirror once"</span>);</div><div class="line">  <span class="comment">// Use this moment of initialization to cache modifier_flags also,</span></div><div class="line">  <span class="comment">// to support Class.getModifiers().  Instance classes recalculate</span></div><div class="line">  <span class="comment">// the cached flags after the class file is parsed, but before the</span></div><div class="line">  <span class="comment">// class is put into the system dictionary.</span></div><div class="line">  <span class="keyword">int</span> computed_modifiers = k-&gt;compute_modifier_flags(CHECK_0);</div><div class="line">  k-&gt;set_modifier_flags(computed_modifiers);</div><div class="line">  <span class="keyword">if</span> (SystemDictionary::Class_klass_loaded() &amp;&amp; (k-&gt;oop_is_instance() || k-&gt;oop_is_javaArray())) &#123;</div><div class="line">    <span class="comment">// Allocate mirror (java.lang.Class instance)</span></div><div class="line">    Handle mirror = instanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(k, CHECK_0);</div><div class="line"></div><div class="line">    instanceMirrorKlass* mk = instanceMirrorKlass::cast(mirror-&gt;klass());</div><div class="line">    java_lang_Class::set_static_oop_field_count(mirror(), mk-&gt;compute_static_oop_field_count(mirror()));</div><div class="line"></div><div class="line">    <span class="comment">// It might also have a component mirror.  This mirror must already exist.</span></div><div class="line">    <span class="keyword">if</span> (k-&gt;oop_is_javaArray()) &#123;</div><div class="line">      Handle comp_mirror;</div><div class="line">      <span class="keyword">if</span> (k-&gt;oop_is_typeArray()) &#123;</div><div class="line">        BasicType type = typeArrayKlass::cast(k-&gt;as_klassOop())-&gt;element_type();</div><div class="line">        comp_mirror = Universe::java_mirror(type);</div><div class="line">        assert(comp_mirror.not_null(), <span class="string">"must have primitive mirror"</span>);</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k-&gt;oop_is_objArray()) &#123;</div><div class="line">        klassOop element_klass = objArrayKlass::cast(k-&gt;as_klassOop())-&gt;element_klass();</div><div class="line">        <span class="keyword">if</span> (element_klass != <span class="literal">NULL</span></div><div class="line">            &amp;&amp; (Klass::cast(element_klass)-&gt;oop_is_instance() ||</div><div class="line">                Klass::cast(element_klass)-&gt;oop_is_javaArray())) &#123;</div><div class="line">          comp_mirror = Klass::cast(element_klass)-&gt;java_mirror();</div><div class="line">          assert(comp_mirror.not_null(), <span class="string">"must have element mirror"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// else some object array internal to the VM, like systemObjArrayKlassObj</span></div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (comp_mirror.not_null()) &#123;</div><div class="line">        <span class="comment">// Two-way link between the array klass and its component mirror:</span></div><div class="line">        arrayKlass::cast(k-&gt;as_klassOop())-&gt;set_component_mirror(comp_mirror());</div><div class="line">        set_array_klass(comp_mirror(), k-&gt;as_klassOop());</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k-&gt;oop_is_instance()) &#123;</div><div class="line">      <span class="comment">// Initialize static fields</span></div><div class="line">      instanceKlass::cast(k())-&gt;do_local_static_fields(&amp;initialize_static_field, CHECK_NULL);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// set the classLoader field in the java_lang_Class instance</span></div><div class="line">    assert(class_loader() == k-&gt;class_loader(), <span class="string">"should be same"</span>);</div><div class="line">    set_class_loader(mirror(), class_loader());</div><div class="line">    <span class="keyword">return</span> mirror();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然调用了，但其实这里基本不做任何操作。可以先了解这个的作用，后面还会详细的介绍，这里其实就是创建Class类对应的内存结构。</p>
<p>objArrayKlassKlass是所有arrayKlassKlass的klass。初始化和arrayKlassKlassObj差不多。objArrayKlassKlassObj就不写了。<br>instanceKlassKlass是所有instanceKlass的klass。初始化和arrayKlassKlassObj差不多。instanceKlassKlassObj就不写了。<br>typeArrayKlassKlass是所有typeArrayKlassKlass的klass。初始化和arrayKlassKlassObj差不多。typeArrayKlassKlassObj就不写了。</p>
<h2 id="boolArrayKlassObj-charArrayKlassObj-singleArrayKlassObj-doubleArrayKlassObj-byteArrayKlassObj-shortArrayKlassObj-intArrayKlassObj-longArrayKlassObj"><a href="#boolArrayKlassObj-charArrayKlassObj-singleArrayKlassObj-doubleArrayKlassObj-byteArrayKlassObj-shortArrayKlassObj-intArrayKlassObj-longArrayKlassObj" class="headerlink" title="_boolArrayKlassObj,_charArrayKlassObj,_singleArrayKlassObj,_doubleArrayKlassObj,_byteArrayKlassObj,_shortArrayKlassObj,_intArrayKlassObj,_longArrayKlassObj"></a>_boolArrayKlassObj,_charArrayKlassObj,_singleArrayKlassObj,_doubleArrayKlassObj,_byteArrayKlassObj,_shortArrayKlassObj,_intArrayKlassObj,_longArrayKlassObj</h2><p>这些对象的初始化都是类似的，只介绍_boolArrayKlassObj的初始化。这个对应了Java语言的基本类型数组。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">hotspot\src\share\vm\memory\universe.cpp:</div><div class="line"></div><div class="line">        <span class="number">_b</span>oolArrayKlassObj      = typeArrayKlass::create_klass(T_BOOLEAN, <span class="keyword">sizeof</span>(jboolean), CHECK);</div><div class="line">        <span class="number">_</span>charArrayKlassObj      = typeArrayKlass::create_klass(T_CHAR,    <span class="keyword">sizeof</span>(jchar),    CHECK);</div><div class="line">        <span class="number">_</span>singleArrayKlassObj    = typeArrayKlass::create_klass(T_FLOAT,   <span class="keyword">sizeof</span>(jfloat),   CHECK);</div><div class="line">        <span class="number">_</span>doubleArrayKlassObj    = typeArrayKlass::create_klass(T_DOUBLE,  <span class="keyword">sizeof</span>(jdouble),  CHECK);</div><div class="line">        <span class="number">_b</span>yteArrayKlassObj      = typeArrayKlass::create_klass(T_BYTE,    <span class="keyword">sizeof</span>(jbyte),    CHECK);</div><div class="line">        <span class="number">_</span>shortArrayKlassObj     = typeArrayKlass::create_klass(T_SHORT,   <span class="keyword">sizeof</span>(jshort),   CHECK);</div><div class="line">        <span class="number">_</span>intArrayKlassObj       = typeArrayKlass::create_klass(T_INT,     <span class="keyword">sizeof</span>(jint),     CHECK);</div><div class="line">        <span class="number">_l</span>ongArrayKlassObj      = typeArrayKlass::create_klass(T_LONG,    <span class="keyword">sizeof</span>(jlong),    CHECK);</div><div class="line"></div><div class="line">hotspot\src\share\vm\oops\typeArrayKlass.hpp:</div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> klassOop <span class="title">create_klass</span><span class="params">(BasicType type, <span class="keyword">int</span> scale, TRAPS)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> create_klass(type, scale, external_name(type), CHECK_NULL);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>type:指的数据类型。可以的值为：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">enum</span> BasicType &#123;</div><div class="line">  T_BOOLEAN  =  <span class="number">4</span>,</div><div class="line">  T_CHAR     =  <span class="number">5</span>,</div><div class="line">  T_FLOAT    =  <span class="number">6</span>,</div><div class="line">  T_DOUBLE   =  <span class="number">7</span>,</div><div class="line">  T_BYTE     =  <span class="number">8</span>,</div><div class="line">  T_SHORT    =  <span class="number">9</span>,</div><div class="line">  T_INT      = <span class="number">10</span>,</div><div class="line">  T_LONG     = <span class="number">11</span>,</div><div class="line">  T_OBJECT   = <span class="number">12</span>,</div><div class="line">  T_ARRAY    = <span class="number">13</span>,</div><div class="line">  T_VOID     = <span class="number">14</span>,</div><div class="line">  T_ADDRESS  = <span class="number">15</span>,</div><div class="line">  T_NARROWOOP= <span class="number">16</span>,</div><div class="line">  T_CONFLICT = <span class="number">17</span>, <span class="comment">// for stack value type with conflicting contents</span></div><div class="line">  T_ILLEGAL  = <span class="number">99</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这里使用了几个基本类型。<br>scale:指的是对应数据类型的大小，单位为字节。</p>
<h3 id="instanceRefKlass"><a href="#instanceRefKlass" class="headerlink" title="instanceRefKlass"></a>instanceRefKlass</h3><h2 id="methodKlass"><a href="#methodKlass" class="headerlink" title="methodKlass"></a>methodKlass</h2><h2 id="constMethodKlass"><a href="#constMethodKlass" class="headerlink" title="constMethodKlass"></a>constMethodKlass</h2><h2 id="methodDataKlass"><a href="#methodDataKlass" class="headerlink" title="methodDataKlass"></a>methodDataKlass</h2><h2 id="klassKlass"><a href="#klassKlass" class="headerlink" title="klassKlass"></a>klassKlass</h2><h3 id="instanceKlassKlass"><a href="#instanceKlassKlass" class="headerlink" title="instanceKlassKlass"></a>instanceKlassKlass</h3><h3 id="arrayKlassKlass"><a href="#arrayKlassKlass" class="headerlink" title="arrayKlassKlass"></a>arrayKlassKlass</h3><h4 id="objArrayKlassKlass"><a href="#objArrayKlassKlass" class="headerlink" title="objArrayKlassKlass"></a>objArrayKlassKlass</h4><h4 id="typeArrayKlassKlass"><a href="#typeArrayKlassKlass" class="headerlink" title="typeArrayKlassKlass"></a>typeArrayKlassKlass</h4><h2 id="arrayKlass"><a href="#arrayKlass" class="headerlink" title="arrayKlass"></a>arrayKlass</h2><h3 id="objArrayKlass"><a href="#objArrayKlass" class="headerlink" title="objArrayKlass"></a>objArrayKlass</h3><h3 id="typeArrayKlass"><a href="#typeArrayKlass" class="headerlink" title="typeArrayKlass"></a>typeArrayKlass</h3><h2 id="constantPoolKlass"><a href="#constantPoolKlass" class="headerlink" title="constantPoolKlass"></a>constantPoolKlass</h2><h2 id="klassOopDesc"><a href="#klassOopDesc" class="headerlink" title="klassOopDesc"></a>klassOopDesc</h2><h2 id="constantPoolCacheKlass"><a href="#constantPoolCacheKlass" class="headerlink" title="constantPoolCacheKlass"></a>constantPoolCacheKlass</h2><h2 id="compiledICHolderKlass"><a href="#compiledICHolderKlass" class="headerlink" title="compiledICHolderKlass"></a>compiledICHolderKlass</h2>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/09/23/jvm/klass-desc-4/" class="archive-article-date">
  	<time datetime="2016-09-23T01:52:40.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-09-23</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/JAVA/">JAVA</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-jvm/klass-desc-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/23/jvm/klass-desc-2/">JVM之Klass结构介绍(一)-----oopDesc结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="/2016/09/22/jvm/klass-desc-1/">JVM之Klass结构介绍概述</a>介绍了Klass的概况，这篇主要介绍了Klass的描述结构oopDesc，这个类在Klass体系中很重要。我们在概述中介绍了这个类对应各个子类的继承关系。这里一个描述各个类的作用以及更加细致的极少各个类。</p>
<h2 id="oopDesc-类"><a href="#oopDesc-类" class="headerlink" title="oopDesc 类"></a>oopDesc 类</h2><p>这个类是整个OopDesc体系的基类，所有的子类都会有这个特性，下面描述的内容适合任何继承这个类的子类。<br>先看看它的定义,只看他的成员：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> oopDesc &#123;</div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> VMStructs;</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keyword">volatile</span> markOop  <span class="number">_</span>mark;</div><div class="line">  <span class="keyword">union</span> <span class="number">_</span>metadata &#123;</div><div class="line">    wideKlassOop    <span class="number">_</span>klass;</div><div class="line">    narrowOop       <span class="number">_</span>compressed_klass;</div><div class="line">  &#125; <span class="number">_</span>metadata;</div><div class="line"></div><div class="line"> ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>oopDesc</strong>结构如下：<br><img src="/img/jvm/oopDesc_class.png" alt=""><br>我们分别看一下这个结构的成员，先看看第一个成员：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">volatile</span> markOop  <span class="number">_</span>mark;</div></pre></td></tr></table></figure></p>
<p>这个成员的介绍可以参考<strong>markOopDesc</strong>结构。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">union</span> <span class="number">_</span>metadata &#123;</div><div class="line">  wideKlassOop    <span class="number">_</span>klass;</div><div class="line">  narrowOop       <span class="number">_</span>compressed_klass;</div><div class="line">&#125; <span class="number">_</span>metadata;</div></pre></td></tr></table></figure></p>
<p>这个成员主要用于为每个Klass维护一个对应的OopDesc指针。这是一个union结构，根据不同的场景解释，JVM提供一个压缩指针的特性，可以降低内存的使用，这里_compressed_klass指针指向的就是开启此功能会使用的指针。</p>
<h2 id="markOopDesc"><a href="#markOopDesc" class="headerlink" title="markOopDesc"></a>markOopDesc</h2><p>每一个<strong>oopDesc</strong>以及子类都会有这个类的成员，这个成员控制了一些控制信息，各个控制位的功能，现在也不清楚，先做一个<strong>Mark</strong>,后面补充。<br>目前可以知道这个结构其实和oopDesc体系没有直接关系，只是由于历史原因导致。这个结构直接使用为oopDesc分配的内存空间作为真正的存储控制位的位置。所有解释的内容都来自oopDesc。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">//  64 bits:</span></div><div class="line"><span class="comment">//  --------</span></div><div class="line"><span class="comment">//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span></div><div class="line"><span class="comment">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span></div><div class="line"><span class="comment">//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></div><div class="line"><span class="comment">//  size:64 -----------------------------------------------------&gt;| (CMS free block)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)</span></div><div class="line"><span class="comment">//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)</span></div><div class="line"><span class="comment">//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)</span></div><div class="line"><span class="comment">//  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)</span></div></pre></td></tr></table></figure></p>
<h2 id="instanceOopDesc"><a href="#instanceOopDesc" class="headerlink" title="instanceOopDesc"></a>instanceOopDesc</h2><h2 id="methodOopDesc"><a href="#methodOopDesc" class="headerlink" title="methodOopDesc"></a>methodOopDesc</h2><h2 id="constMethodOopDesc"><a href="#constMethodOopDesc" class="headerlink" title="constMethodOopDesc"></a>constMethodOopDesc</h2><h2 id="methodDataOopDesc"><a href="#methodDataOopDesc" class="headerlink" title="methodDataOopDesc"></a>methodDataOopDesc</h2><h2 id="arrayOopDesc"><a href="#arrayOopDesc" class="headerlink" title="arrayOopDesc"></a>arrayOopDesc</h2><h3 id="objArrayOopDesc"><a href="#objArrayOopDesc" class="headerlink" title="objArrayOopDesc"></a>objArrayOopDesc</h3><h3 id="typeArrayOopDesc"><a href="#typeArrayOopDesc" class="headerlink" title="typeArrayOopDesc"></a>typeArrayOopDesc</h3><h2 id="constantPoolOopDesc"><a href="#constantPoolOopDesc" class="headerlink" title="constantPoolOopDesc"></a>constantPoolOopDesc</h2><h2 id="constantPoolCacheOopDesc"><a href="#constantPoolCacheOopDesc" class="headerlink" title="constantPoolCacheOopDesc"></a>constantPoolCacheOopDesc</h2><h2 id="klassOopDesc"><a href="#klassOopDesc" class="headerlink" title="klassOopDesc"></a>klassOopDesc</h2><h2 id="markOopDesc-1"><a href="#markOopDesc-1" class="headerlink" title="markOopDesc"></a>markOopDesc</h2><h2 id="compiledICHolderOopDesc"><a href="#compiledICHolderOopDesc" class="headerlink" title="compiledICHolderOopDesc"></a>compiledICHolderOopDesc</h2>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/09/23/jvm/klass-desc-2/" class="archive-article-date">
  	<time datetime="2016-09-23T01:22:40.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-09-23</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/JAVA/">JAVA</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-jvm/klass-desc-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/22/jvm/klass-desc-1/">JVM之Klass结构介绍概述</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们知道Java编译器把Java源文件编译为class文件，JVM对class文件进行加载解释，那么JVM在虚拟机对class控制管理的结构又是什么呢？这里就是我们这里重点描述的Kclass结构。<br>
        <p class="article-more-link">
          <a  href="/2016/09/22/jvm/klass-desc-1/#more">more >></a>
        </p>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/09/22/jvm/klass-desc-1/" class="archive-article-date">
  	<time datetime="2016-09-22T02:52:40.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-09-22</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/JAVA/">JAVA</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 Corner XX
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/"
	}
</script>

<script src="/./main.js"></script>





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/Hadoop-Hdfs/" style="font-size: 10px;">Hadoop Hdfs</a> <a href="/tags/Hadoop-Yran/" style="font-size: 10px;">Hadoop Yran</a> <a href="/tags/Hbase/" style="font-size: 16.67px;">Hbase</a> <a href="/tags/Hdfs/" style="font-size: 13.33px;">Hdfs</a> <a href="/tags/JVM/" style="font-size: 20px;">JVM</a> <a href="/tags/Kernel/" style="font-size: 13.33px;">Kernel</a> <a href="/tags/OpenJDK/" style="font-size: 13.33px;">OpenJDK</a> <a href="/tags/Phoenix/" style="font-size: 10px;">Phoenix</a> <a href="/tags/algorithm/" style="font-size: 16.67px;">algorithm</a> <a href="/tags/streamset/" style="font-size: 10px;">streamset</a>
    			</div>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">记录点点滴滴</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>